/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2018, Joyent, Inc.
 *
 * SyseventStream subscriptions Stream
 */

var spawn = require('child_process').spawn;
var stream = require('stream');
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var hrtime = require('/usr/vm/node_modules/hrtime');
var LineStream = require('/usr/node/node_modules/linestream');

function noop() {}

var READY_TIMEOUT = 30 * 1000;

module.exports = SyseventStream;

/*
 * Create a new sysevent stream by forking sysevent(8).
 *
 * Arguments - (all properties are optional)
 *
 * opts.channel (String) sysevent channel to bind to
 *   - defaults to no channel if undefined or null
 * opts.class (String) sysevent class
 *   - defaults to all if undefined or null
 * opts.subclasses (Array) sysevent subclasses
 *   - defaults to all if undefined or null
 * opts.logger - bunyan logger object to use
 *   - defaults to noop's
 *
 * Events
 *
 * The object returned is a stream and will emit any "error" events
 * from the underlying child process, as well as "event" events with
 * a single argument: an object representing the sysevent.
 *
 * Example Construction
 *
 * // watch all sysevents
 * new SyseventStream();
 *
 * // watch for events in class "foo_class"
 * new SyseventStream({class: 'foo_class'});
 *
 * // watch for events in class "foo_class" and subclass "foo_subclass" or
 * // "bar_subclass"
 * new SyseventStream({
 *     class: 'foo_class',
 *     subclasses: ['foo_subclass', 'bar_subclass']
 *  });
 *
 * // watch for events in class "foo_class" and channel "foo_channel"
 * new SyseventStream({channel: 'foo_channel', class: 'foo_class'});
 *
 * // watch all sysevents and log to a bunyan logger instance
 * new SyseventStream({logger: bunyan_logger});
 *
 * Example Usage
 *
 *     var se = new SyseventStream({
 *         class: 'EC_ZFS',
 *         subclasses: ['ESC_ZFS_history_event']
 *     });
 *     se.on('readable', function () {
 *         var ev;
 *         while ((ev = se.read()) !== null)
 *             console.log(JSON.sringify(ev, null, 2));
 *     });
 *     se.once('ready', function () {
 *         // ready to emit sysevents
 *     });
 *
 * yields
 *
 *     {
 *       "date": "2015-07-21T00:18:18.196Z",
 *       "vendor": "SUNW",
 *       "publisher": "zfs",
 *       "class": "EC_zfs",
 *       "subclass": "ESC_ZFS_history_event",
 *       "pid": 0,
 *       "data": {
 *         "pool_name": "zones",
 *         "pool_guid": 4668373440529934000,
 *         "history_record": {
 *           "history command": "zfs create zones/foobar",
 *           "history who": 0,
 *           "history time": 1437437898,
 *           "history hostname": "gz"
 *         }
 *       }
 *     }
 *
 */
function SyseventStream(opts) {
    var self = this;

    assert.optionalObject(opts, 'opts');
    opts = opts || {};
    assert.optionalNumber(opts.highWaterMark, 'opts.highWaterMark');

    self.ses_stopped = false;
    self.ses_started = process.hrtime();

    // become a transform stream
    stream.Transform.call(self, {objectMode: true});

    // process opts
    self.ses_class = opts.class;
    self.ses_subclasses = opts.subclasses;
    self.ses_channel = opts.channel;
    self.ses_highWaterMark = opts.highWaterMark;

    // create child logger
    if (opts.logger) {
        var obj = {
            class: self.ses_class,
            subclasses: self.ses_subclasses
        };
        if (self.ses_channel)
            obj.channel = self.ses_channel;
        self.ses_logger = opts.logger.child(obj);
    } else {
        self.ses_logger = {
            trace: noop,
            debug: noop,
            log: noop,
            info: noop,
            warn: noop,
            error: noop
        };
    }

    // construct arguments to give to sysevent(8)
    var args = ['-rj'];
    if (self.ses_channel)
        args.push('-c', self.ses_channel);
    if (self.ses_class) {
        args.push(self.ses_class);
        if (self.ses_subclasses)
            args = args.concat(self.ses_subclasses);
    }

    // fork sysevent(8)
    self.ses_logger.info({args: args}, 'calling /usr/sbin/sysevent %s',
        args.join(' '));

    self.ses_child = spawn('/usr/sbin/sysevent', args);
    self.ses_child.stdout.setEncoding('utf8');
    self.ses_child.stderr.setEncoding('utf8');

    // any child error will be logged and re-emitted
    self.ses_child.on('error', function (e) {
        self.ses_logger.error({err: e}, 'child process error');
        self.emit('error', e);
    });

    // a child dying is either an info or error message depending
    // on if it was intentional (ie. .stop() was called)
    self.ses_child.on('close', function (code, signal) {
        if (self.ses_stopped) {
            self.ses_logger.info({code: code, signal: signal},
                'sysevent stopped');
            return;
        }

        var e = new Error('child exited');
        self.ses_logger.error({err: e, code: code, signal: signal},
            'child process closed');
        self.emit('error', e);
    });

    // stdin is not needed
    self.ses_child.stdin.end();

    // parse stdout line by line by piping to ourselves
    var lstreamOpts = {
        encoding: 'utf8'
    };
    if (self.ses_highWaterMark) {
        lstreamOpts.highWaterMark = self.ses_highWaterMark;
    }
    var stdoutls = new LineStream(lstreamOpts);
    self.ses_child.stdout.pipe(stdoutls).pipe(self);

    // parse stderr line by line - any stderr produced is a fatal error
    // unexpected by the child process, so we log the error and abort the child
    // process to generate a core dump
    var stderrls = new LineStream();
    self.ses_child.stderr.pipe(stderrls).on('readable', function () {
        var lines = [];
        var line;
        while ((line = stderrls.read()) !== null)
            lines.push(line);

        self.ses_logger.error({stderr: lines.join('\n')}, 'stderr produced');
        self._abort();
    });

    // create a timer to ensure that the "ready" event seen.  This also allows
    // us to ensure the "ready" event is only seen once.  We abort the child
    // process if the ready event is not seen, as this represents a serious and
    // unrecoverable error in the child.
    self.ses_ready_timeout = setTimeout(function readyTimeout() {
        var e = new Error('ready timeout exceeded');

        self.ses_logger.error({err: e}, e.message);
        self.ses_ready_timeout = null;
        self._abort();
    }, READY_TIMEOUT);
}
util.inherits(SyseventStream, stream.Transform);

/*
 * the transform method to process sysevent(8) stdout line-by-line
 */
SyseventStream.prototype._transform = function _transform(chunk, encoding, cb) {
    var self = this;

    var line = chunk.toString('utf8');
    var ev;
    try {
        ev = JSON.parse(line);
        assert.object(ev, 'ev');
        assert.string(ev.type, 'ev.type');
        assert.string(ev.date, 'ev.date');

        ev.date = new Date(ev.date);
        assert.ok(isFinite(ev.date), 'invalid ev.date');
    } catch (e) {
        // any JSON parse failure is a fatal error where we abort the child
        // process to generate a core dump
        self.ses_logger.error({err: e, line: line},
            'failed to parse output line');
        self._abort();
        return;
    }

    switch (ev.type) {
    case 'ready':
        assert(self.ses_ready_timeout, '"ready" event already seen');
        self.ses_logger.debug('sysevent stream ready, took %s',
            hrtime.prettyHrtime(process.hrtime(self.ses_started)));
        self.emit('ready');
        self._clear_ready_timeout();
        break;
    default:
        self.push(ev);
        break;
    }
    cb();
};

/*
 * cleanly stop the SyseventStream by killing the child process
 * with a SIGTERM
 */
SyseventStream.prototype.stop = function stop() {
    var self = this;

    self._clear_ready_timeout();
    self.ses_stopped = true;
    self.ses_child.kill();
};

/*
 * stop the SyseventStream and force sysevent(8) to dump core -
 * this should only be called from within this module.
 *
 * This is only to be called when the child process does something unexpected
 * in a way where it can't recover.  Currently, this includes not emitting the
 * "ready" event, generating a line on stdout that can't be parsed as JSON, or
 * generating any data on stderr.
 *
 * When the child process enters an unexpected state we send a SIGABRT to
 * generate a core dump, and emit an error from this module. It is possible to
 * catch this error and recreate the sysevent stream to deal with this
 * situation, but it may be best to just let the error event crash the running
 * node process.
 */
SyseventStream.prototype._abort = function _abort() {
    var self = this;

    self._clear_ready_timeout();
    self.ses_stopped = true;
    self.ses_logger.error({child: self.ses_child.pid},
        '_abort() called - sending SIGABRT');
    self.ses_child.kill('SIGABRT');
    var e = new Error('sysevent(8) aborted');
    self.emit('error', e);
};

/*
 * Convenience function to clear the ready timeout if it is set
 */
SyseventStream.prototype._clear_ready_timeout =
    function _clear_ready_timeout() {

    var self = this;

    if (self.ses_ready_timeout) {
        self.ses_logger.trace('clearing ready timeout');
        clearTimeout(self.ses_ready_timeout);
        self.ses_ready_timeout = null;
    }
};

/*
 * if called directly, just hook up a sysevent stream and emit
 * JSON on stdout
 */
if (require.main === module) {
    var logger = require('./bunyan').createLogger({name: 'sysevent'});
    var se = new SyseventStream({logger: logger});
    se.once('ready', function () {
        console.log('ready');
    });
    se.on('readable', function () {
        var ev;
        while ((ev = se.read()) !== null) {
            console.log('- event received -');
            console.log(JSON.stringify(ev, null, 2));
        }
    });
}
