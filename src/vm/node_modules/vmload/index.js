#!/usr/node/bin/node
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2014, Joyent, Inc. All rights reserved.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var fs = require('fs');
var getDatasets = require('./vmload-datasets').getDatasets;
var getVmobjJSON = require('./vmload-json').getVmobjJSON;
var getVmobjXMLFile = require('./vmload-xml').getVmobjXMLFile;
var getZoneinfo = require('./vmload-zoneinfo').getZoneinfo;
var getZoneRecords = require('./vmload-zoneadm').getZoneRecords;
var path = require('path');
var props = require('/usr/vm/node_modules/props');
var utils = require('utils');
var vmload_utils = require('./vmload-utils');
var wantAnyFields = vmload_utils.wantAnyFields;
var wantField = vmload_utils.wantField;

// utils
var assertSafeZonePath = utils.assertSafeZonePath;
var trim = utils.trim;

// load generated tables of data
var BRAND_OPTIONS = props.BRAND_OPTIONS;
var LOAD_DEPENDS = props.LOAD_DEPENDS;
var SYSINFO_PROPERTIES = props.SYSINFO_PROPERTIES;
var XML_PROPERTIES = props.XML_PROPERTIES;
var VMOBJ_JSON_FIELDS = props.VMOBJ_JSON_FIELDS;
var VMOBJ_SYSINFO_FIELDS = props.VMOBJ_SYSINFO_FIELDS;
var VMOBJ_XML_FIELDS = props.VMOBJ_XML_FIELDS;
var VMOBJ_ZFS_FIELDS = props.VMOBJ_ZFS_FIELDS;
var VMOBJ_ZONEINFO_FIELDS = props.VMOBJ_ZONEINFO_FIELDS;

// This is the number ZFS uses as 'none' for snapshot_limit and filesystem_limit
var ZFS_UNLIMITED = 18446744073709552000;

/*
 * dataset_objects contains all the information gathered from zfs. This
 * function dispatches the work of taking that data and applying the appropriate
 * properties to the vmobj.
 */
function addDatasetProperties(vmobj, dataset_objects, options, callback)
{
    var log = options.log;

    /*
     * In these states, we don't expect there to be dataset information in
     * all cases, so it's not a failure if it's missing.
     */
    if (['configured', 'incomplete'].indexOf(vmobj.zone_state) !== -1) {
        if (!vmobj.hasOwnProperty('zonepath')) {
            log.warn('VM ' + vmobj.uuid + ' in zone_state ' + vmobj.zone_state
                + ' and missing zonepath, not adding dataset properties.');
            callback();
            return;
        }
    }

    assert(vmobj.hasOwnProperty('zonepath'),
        'vmobj: ' + JSON.stringify(vmobj) + ' is missing "zonepath"');

    addRootDatasetProperties(vmobj, dataset_objects, options);
    addDelegatedDatasetProperties(vmobj, dataset_objects, options);

    if (wantField(options, 'disks') && vmobj.hasOwnProperty('disks')) {
        addDiskProperties(vmobj, dataset_objects, options);
    }

    if (wantField(options, 'snapshots')) {
        addSnapshots(vmobj, dataset_objects, options);
    }

    if (vmobj.state === 'receiving') {
        addMissingProperties(vmobj, dataset_objects, options);
    }

    callback();
}

/*
 * This adds the properties for the delegated dataset from dataset_objects to
 * vmobj.
 */
function addDelegatedDatasetProperties(vmobj, dataset_objects, options)
{
    var delegated;
    var dsobj;
    var indestructible_snapname;
    var log = options.log;
    var snapshot;

    /*
     * delegated datasets are keyed on the dataset name instead of
     * mountpoint, since mountpoint can change in a zone.
     */
    if (!vmobj.hasOwnProperty('zfs_filesystem')) {

        log.trace('addDelegatedDatasetProperties(' + vmobj.uuid + '): '
            + 'vmobj has no "zfs_filesystem"');
        return;
    }

    delegated = vmobj.zfs_filesystem + '/data';
    if (dataset_objects.datasets.hasOwnProperty(delegated)) {
        dsobj = dataset_objects.datasets[delegated];

        indestructible_snapname = delegated + '@indestructible';

        if (wantField(options, 'indestructible_delegated')
            && dataset_objects.datasets
            .hasOwnProperty(indestructible_snapname)) {

            snapshot = dataset_objects.datasets[indestructible_snapname];
            if (snapshot.hasOwnProperty('userrefs') && snapshot.userrefs > 0) {
                vmobj.indestructible_delegated = true;
            }
        }

        if (dsobj.hasOwnProperty('compression')
            && (dsobj.compression !== 'off')) {

            vmobj.zfs_data_compression = dsobj.compression;
        }
        if (dsobj.hasOwnProperty('recsize')) {
            vmobj.zfs_data_recsize = dsobj.recsize;
        }
    } else {
        log.trace('addDelegatedDatasetProperties(' + vmobj.uuid + '): no '
            + 'dataset_objects for delegated dataset: ' + delegated);
    }
}

/*
 * This adds the properties for the KVM-style disks (zvols) from dataset_objects
 * to vmobj.
 */
function addDiskProperties(vmobj, dataset_objects, options)
{
    var dsname;
    var dsobj;
    var log = options.log;

    vmobj.disks.forEach(function (d) {
        if (d.hasOwnProperty('path')
            && dataset_objects.mountpoints.hasOwnProperty(d.path)) {

            dsname = dataset_objects.mountpoints[d.path];
            dsobj = dataset_objects.datasets[dsname];
            d.zfs_filesystem = dataset_objects.mountpoints[d.path];
            d.zpool = d.zfs_filesystem.split('/')[0];

            if (dsobj.hasOwnProperty('volsize')) {
                // dsobj.volsize is in bytes, we want MiB
                d.size = (dsobj.volsize / (1024 * 1024));
                log.trace('found size=' + d.size + ' for ' + JSON.stringify(d));
            }

            if (dsobj.hasOwnProperty('compression')) {
                d.compression = dsobj.compression;
            }

            if (dsobj.hasOwnProperty('refreservation')) {
                // dsobj.refreservation is in bytes, want MiB
                d.refreservation = (dsobj.refreservation / (1024 * 1024));
                log.trace('found refreservation=' + d.refreservation + ' for '
                    + JSON.stringify(d));
            }

            if (dsobj.hasOwnProperty('volblocksize')) {
                d.block_size = dsobj.volblocksize;
            }
        } else if (d.hasOwnProperty('path')) {
            // disk has path, but is not found in zfs mountpoints list
            d.missing = true;
        } else {
            log.warn('no dataset_objects and no path for ' + JSON.stringify(d));
        }
    });
}

/*
 * This populates the "missing" member of VM objects which are in state
 * "receving".
 */
function addMissingProperties(vmobj, dataset_objects, options)
{
    var log = options.log;

    vmobj.missing = { 'datasets': [], 'disks': [], 'filesystems': [] };

    if (!vmobj.zfs_filesystem) {
        log.error('missing zfs_filesystem for ' + vmobj.uuid);

        /*
         * When we've not got the actual zfs_filesystem, we assume dataset name
         * is same as zonepath, just w/o leading '/'. It's better to put
         * something in the list even if it's wrong because fixing the root
         * dataset will also give us the correct zfs_filesystem. We know
         * something is wrong in this case, just not what.
         */
        assert(vmobj.zonepath, 'vmobj ' + JSON.stringify(vmobj) + ' is missing'
            + ' zonepath');

        vmobj.missing.datasets.push(vmobj.zonepath.substr(1));
    } else if (!dataset_objects.datasets.hasOwnProperty(vmobj.zfs_filesystem)) {
        vmobj.missing.datasets.push(vmobj.zfs_filesystem);
    }

    if (vmobj.hasOwnProperty('datasets')) {
        vmobj.datasets.forEach(function (ds) {
            if (!dataset_objects.datasets.hasOwnProperty(ds)) {
                vmobj.missing.datasets.push(ds);
            }
        });
    }

    if (vmobj.hasOwnProperty('filesystems')) {
        vmobj.filesystems.forEach(function (filesys) {
            if (filesys.hasOwnProperty('source')) {
                vmobj.missing.filesystems.push(filesys.source);
            }
        });
    }

    if (vmobj.hasOwnProperty('disks')) {
        vmobj.disks.forEach(function (disk) {
            if (disk.hasOwnProperty('missing')) {
                vmobj.missing.disks.push(disk.path);
            }
        });
    }

    log.trace('addMissingProperties(' + vmobj.uuid + ') found the following: '
        + JSON.stringify(vmobj.missing));
}

/*
 * This adds the properties for the root dataset from dataset_objects to vmobj.
 */
function addRootDatasetProperties(vmobj, dataset_objects, options)
{
    var dsname;
    var dsobj;
    var log = options.log;
    var indestructible_snapname;
    var snapshot;

    if (!dataset_objects.hasOwnProperty('mountpoints')) {
        log.trace('addRootDatasetProperties(' + vmobj.uuid + '): '
            + 'dataset_objects has no "mountpoints"');
        return;
    }

    if (!dataset_objects.hasOwnProperty('datasets')) {
        log.trace('addRootDatasetProperties(' + vmobj.uuid + '): '
            + 'dataset_objects has no "datasets"');
        return;
    }

    if (!dataset_objects.mountpoints.hasOwnProperty(vmobj.zonepath)) {
        log.trace('addRootDatasetProperties(' + vmobj.uuid + '): '
            + 'dataset_objects.mountpoints has no ' + vmobj.zonepath);
        return;
    }

    dsname = dataset_objects.mountpoints[vmobj.zonepath];

    assert(dataset_objects.datasets.hasOwnProperty(dsname), 'vmobj: '
        + JSON.stringify(vmobj) + ' cannot find dataset object for "'
        + dsname + '"');

    dsobj = dataset_objects.datasets[dsname];

    indestructible_snapname = dsname + '@indestructible';

    if (wantField(options, 'indestructible_zoneroot')
        && dataset_objects.datasets.hasOwnProperty(indestructible_snapname)) {

        snapshot = dataset_objects.datasets[indestructible_snapname];
        if (snapshot.hasOwnProperty('userrefs') && snapshot.userrefs > 0) {
            vmobj.indestructible_zoneroot = true;
        }
    }

    // dsobj.quota is in bytes, we want GiB for vmobj.quota
    if (wantField(options, 'quota') && dsobj.hasOwnProperty('quota')) {
        vmobj.quota = (dsobj.quota / (1024 * 1024 * 1024));
        log.trace('found quota "' + vmobj.quota + '" for '
            + vmobj.uuid);
    }

    if (wantField(options, 'create_timestamp')
        && !vmobj.hasOwnProperty('create_timestamp')
        && dsobj.hasOwnProperty('creation')) {

        log.debug('VM has no create_timestamp, using creation '
            + 'from ' + dsobj.name);
        vmobj.create_timestamp =
            (new Date(dsobj.creation * 1000)).toISOString();
    }

    if (wantField(options, 'zfs_root_compression')
        && dsobj.hasOwnProperty('compression')
        && (dsobj.compression !== 'off')) {

        vmobj.zfs_root_compression = dsobj.compression;
    }

    if (wantField(options, 'zfs_root_recsize')
        && dsobj.hasOwnProperty('recsize')) {

        vmobj.zfs_root_recsize = dsobj.recsize;
    }

    if (wantField(options, 'zfs_filesystem_limit')
        && dsobj.hasOwnProperty('filesystem_limit')
        && (dsobj.filesystem_limit !== ZFS_UNLIMITED)) {

        vmobj.zfs_filesystem_limit = dsobj.filesystem_limit;
    }

    if (wantField(options, 'zfs_snapshot_limit')
        && dsobj.hasOwnProperty('snapshot_limit')
        && (dsobj.snapshot_limit !== ZFS_UNLIMITED)) {

        vmobj.zfs_snapshot_limit = dsobj.snapshot_limit;
    }

    /*
     * Always add zfs_filesystem if we can because it's needed
     * to find other properties such as delegated_dataset.
     */
    vmobj.zfs_filesystem = dsobj.name;
    vmobj.zpool = vmobj.zfs_filesystem.split('/')[0];

    log.trace('found dataset "' + vmobj.zfs_filesystem
        + '" for ' + vmobj.uuid);
}

/*
 * This adds the properties for the vmsnap-* prefixed snapshots from
 * dataset_objects to vmobj.
 */
function addSnapshots(vmobj, dataset_objects, options)
{
    var log = options.log;
    var friendly_snapshots = [];
    var zoneroot_snapshots = [];

    if (!dataset_objects.hasOwnProperty('snapshots')) {
        log.warn('wanted snapshots for ' + vmobj.uuid + ' but no "snapshots" '
            + 'found in dataset list');
        return;
    }

    // first get the snapshots of the zoneroot's zfs_filesystem
    if (dataset_objects.snapshots.hasOwnProperty(vmobj.zfs_filesystem)) {
        zoneroot_snapshots = dataset_objects.snapshots[vmobj.zfs_filesystem];
    }

    // XXX OS-1750 exists for supporting snapshots on other datasets here.

    /*
     * Go through all the actual snapshots and pull out just the ones which have
     * the vmsnap- prefix adding them to the 'friendly_snapshots' list.
     */
    zoneroot_snapshots.forEach(function (snap) {
        var friendly_snap;
        var matches = snap.snapname.match(/^vmsnap-(.*)$/);
        var snap_time;

        if (matches && matches[1]) {
            friendly_snap = {name: matches[1]};
            if (snap.hasOwnProperty('created_at')) {
                snap_time
                    = new Date(snap.created_at * 1000); // in ms
                friendly_snap.created_at
                    = snap_time.toISOString();
            }
            friendly_snapshots.push(friendly_snap);
        } else {
            log.debug('ignoring snapshot w/o vmsnap- prefix: ' + snap.snapname);
        }
    });

    // sort the snapshots with newest first.
    friendly_snapshots.sort(function (a, b) {
        if (a.created_at > b.created_at) {
            return -1;
        }
        if (a.created_at < b.created_at) {
            return 1;
        }
        return 0; // equal
    });

    // attach the sorted friendly list as the 'snapshots' member of VM object
    vmobj.snapshots = friendly_snapshots;
}

function getLastExited(zonename, zonepath, log, callback)
{
    var filename;
    var result = {};

    assert(log, 'no logger passed to getLastExited()');

    if (!zonepath) {
        log.debug('getLastExited() no zonepath!');
        callback(new Error('no zonepath for ' + zonename));
        return;
    }

    filename = path.join(zonepath, '/lastexited');
    fs.readFile(filename, function (err, data) {
        var fields;
        var stat;

        if (err) {
            callback(err);
            return;
        }

        fields = trim(data.toString()).split(/\s/);
        if (fields.length !== 2) {
            callback(new Error('wrong number of fields in ['
                + trim(data.toString()) + ']'));
            return;
        }

        stat = Number(fields[1]);
        log.debug('found exit_status value: ' + stat);
        if (stat === -1) {
            // -1 is special status (OS-3429) that indicates normal exit
            result.exit_status = 0;
        } else if ((stat & 0xff) === 0) {
            // WIFEXITED == true, so we can use exit status
            result.exit_status = (stat >> 8);
        } else {
            // WIFEXITED != true, so we just pull out the non-exit bits * -1
            result.exit_status = ((stat & 0xff) * -1);
        }

        result.exit_timestamp = utils.epochTimestampSecs(fields[0]);
        callback(null, result);
    });
}

function getLastModified(zonename, zonepath, log, callback)
{
    var files = [];
    var timestamp = 0;

    assert(log, 'no logger passed to getLastModified()');

    if (zonepath) {
        files.push(path.join(zonepath, '/config/metadata.json'));
        files.push(path.join(zonepath, '/config/routes.json'));
        files.push(path.join(zonepath, '/config/tags.json'));
        files.push(path.join(zonepath, '/lastexited'));
    } else {
        log.debug('getLastModified() no zonepath!');
    }

    if (zonename) {
        files.push('/etc/zones/' + zonename + '.xml');
    } else {
        log.debug('getLastModified() no zonename!');
    }

    // stat all files in parallel, newest will be "last_modified"
    async.each(files, function (file, cb) {
        fs.stat(file, function (err, stats) {
            if (err) {
                if (err.code !== 'ENOENT') {
                    log.error(err, 'Unable to get timestamp for "' + file + '":'
                        + err.message);
                }
                cb();
                return;
            }

            if (!stats.isFile()) {
                cb();
                return;
            }

            if ((timestamp === 0) || (Date.parse(stats.mtime) > timestamp)) {
                // newest file so far!
                timestamp = Date.parse(stats.mtime);
            }

            cb();
        });
    }, function (err) {
        if (err) {
            callback(err);
            return;
        }
        if (timestamp === 0) {
            callback(new Error('unable to stat any files for VM ' + zonename));
            return;
        }

        callback(null, (new Date(timestamp)).toISOString());
    });
}

function getSysinfo(log, callback)
{
    var filename = '/tmp/.sysinfo.json';
    var sysinfo;

    /*
     * We take a shortcut here and read from the cache file the sysinfo tool
     * maintains. This is not a public interface, but we're also in control
     * of it so we'll have to remember to update this if we change sysinfo's
     * handling of storage.
     */
    fs.readFile(filename, function (error, filedata) {
        if (error) {
            callback(error);
            return;
        }

        // XXX should we remove this try {} here so we just blow up?
        try {
            sysinfo = JSON.parse(filedata.toString());
        } catch (e) {
            callback(e);
            return;
        }

        callback(null, sysinfo);
    });
}

/*
 * options can include:
 *
 *  fields: an array of field names we want in this object
 *  log: a bunyan logger (required)
 *  cache: (see comment at top of getZoneData())
 *
 * If any of the members of the 'cache' are not passed in, they will be looked
 * up from the live system. This means that if you want to do multiple lookups
 * and aren't concerned about possible changes in the meantime (or are watching
 * those yourself) the most efficient way to get VM objects is to preload this
 * data using something like:
 *
 *  getZoneData(<uuid>, options, callback(gzd_err, cache) {
 *      if (gzd_err) {
 *          ...
 *          return;
 *      }
 *      options.cache = cache;
 *      getVmobj(<uuid>, options, callback(gv_err, obj) {
 *          ...
 *      });
 *  }):
 *
 * but if you are just doing one lookup, you can skip passing in a 'cache'
 * option and it will be looked up for you.
 *
 */
function getVmobj(uuid, options, callback)
{
    var cache;
    var log;
    var vmobj = {};
    var zoneadm_info;

    assert(uuid, 'no uuid passed to getVmobj()');
    assert(options.log, 'no logger passed to getVmobj()');
    log = options.log;

    log.trace('getting vmobj for VM ' + uuid);

    async.series([
        function (cb) {
            if (options.hasOwnProperty(cache)) {
                cache = options.cache;
                cb();
                return;
            }

            // If cache was not prepopulated, load now, just for this VM's data.
            getZoneData(uuid, options, function (err, _cache) {
                if (err) {
                    cb(err);
                    return;
                }

                cache = _cache;
                cb();
            });
        }, function (cb) {
            var new_err;

            // load data from zoneadm list -pc (cache.zoneadm_objectss)
            if (cache.zoneadm_objects
                && cache.zoneadm_objects.hasOwnProperty(uuid)) {

                zoneadm_info = cache.zoneadm_objects[uuid];

                // Ensure zoneadm_info has basic required properties
                assert.equal(zoneadm_info.uuid, uuid);
                [
                    'brand',
                    'state',
                    'zonename',
                    'zonepath'
                ].forEach(function (f) {
                    assert(zoneadm_info[f], 'zoneadm_info is missing "' + f
                        + '" for VM ' + uuid);
                });

                cb();
            } else {
                new_err = new Error('VM ' + uuid + ' not found in zoneadm');
                new_err.code = 'ENOENT';
                cb(new_err);
            }
        }, function (cb) {
            var new_err;

            if (cache.zonexml_objects
                && cache.zonexml_objects.hasOwnProperty(uuid)) {

                vmobj = cache.zonexml_objects[uuid];
                cb();
                return;
            }

            if (!wantAnyFields(options, VMOBJ_XML_FIELDS)) {
                // didn't want any so no problem.
                vmobj = {};
                cb();
                return;
            }

            // if we got here, we wanted xml data, so not having is an error
            new_err = new Error('VM ' + uuid + ' XML data missing from cache');
            cb(new_err);
            return;


        }, function (cb) {
            /*
             * We got some bits from `zoneadm list` in zoneadm_info here, and
             * since we already got that data, adding it to the object here is
             * cheap. We also need some of these properties to be able to get
             * others later, so we add them all now. If they're unwanted they'll
             * be removed from the final object.
             */
            vmobj.brand = zoneadm_info.brand;
            vmobj.uuid = zoneadm_info.uuid;
            vmobj.zone_state = zoneadm_info.state;
            vmobj.zonename = zoneadm_info.zonename;
            vmobj.zonepath = zoneadm_info.zonepath;

            if (wantField(options, 'zoneid') && zoneadm_info.zoneid !== '-') {
                vmobj.zoneid = zoneadm_info.zoneid;
            }

            if (wantField(options, 'last_modified')) {
                if (cache.last_modified
                    && cache.last_modified.hasOwnProperty(vmobj.uuid)) {

                    vmobj.last_modified = cache.last_modified[vmobj.zonename];
                } else {
                    log.warn('"last_modified" requested, but not found in cache'
                        + ' for VM ' + vmobj.uuid);
                }
            }

            if (vmobj.zone_state !== 'running'
                    && wantField(options, 'exit_status')) {

                if (cache.last_exited
                    && cache.last_exited.hasOwnProperty(vmobj.uuid)
                    && cache.last_exited[vmobj.uuid]
                    .hasOwnProperty('exit_status')) {

                    vmobj.exit_status
                        = cache.last_exited[vmobj.zonename].exit_status;
                } else {
                    log.warn('"exit_status" requested, but not found in cache'
                        + ' for VM ' + vmobj.uuid);
                }
            }

            if (vmobj.zone_state !== 'running'
                    && wantField(options, 'exit_timestamp')) {

                if (cache.last_exited
                    && cache.last_exited.hasOwnProperty(vmobj.uuid)
                    && cache.last_exited[vmobj.uuid]
                    .hasOwnProperty('exit_timestamp')) {

                    vmobj.exit_timestamp
                        = cache.last_exited[vmobj.zonename].exit_timestamp;
                } else {
                    log.warn('"exit_timestamp" requested, but not found in '
                        + 'cache for VM ' + vmobj.uuid);
                }
            }

            /*
             * If we want resolvers, (eg. OS-2194) we always add the array here
             * so you can tell that the resolvers are explicitly not set.
             */
            if (wantField(options, 'resolvers')
                && !vmobj.hasOwnProperty('resolvers')) {

                vmobj.resolvers = [];
            }

            // Always include firewall_enabled, false if not set.
            if (wantField(options, 'firewall_enabled')
                && !vmobj.hasOwnProperty('firewall_enabled')) {

                vmobj.firewall_enabled = false;
            }

            // sysinfo has server_uuid and potentially some DC info
            if (cache.sysinfo) {
                if (wantField(options, 'server_uuid')
                    && cache.sysinfo.hasOwnProperty('UUID')) {

                    vmobj.server_uuid = cache.sysinfo.UUID;
                }
                if (wantField(options, 'datacenter_name')
                    && cache.sysinfo.hasOwnProperty('Datacenter Name')) {

                    vmobj.datacenter_name = cache.sysinfo['Datacenter Name'];
                }
                if (wantField(options, 'platform_buildstamp')
                    && cache.sysinfo.hasOwnProperty('Live Image')) {

                    vmobj.platform_buildstamp = cache.sysinfo['Live Image'];
                }
                if (wantField(options, 'headnode_id')
                    && cache.sysinfo.hasOwnProperty('Headnode ID')) {

                    vmobj.headnode_id = cache.sysinfo['Headnode ID'];
                }
            }

            /*
             * state could already be set here if it was overriden by a
             * transition that's in progress. So we only change if that's not
             * the case.
             *
             * We always add 'state' at this point regardless of 'fields'
             * because some other checks later depend on it (eg. received means
             * we need 'missing' member, etc). The 'state' itself will get
             * removed later if not requested.
             */
            if (!vmobj.hasOwnProperty('state')) {
                if (zoneadm_info.state === 'installed') {
                    vmobj.state = 'stopped';
                } else {
                    vmobj.state = zoneadm_info.state;
                }
            }

            /*
             * If the zone has the 'failed' property it doesn't matter what
             * other state it might be in, we list its state as 'failed'.
             */
            if (vmobj.failed) {
                vmobj.state = 'failed';
            }

            cb();
        }, function (cb) {
            VMOBJ_ZONEINFO_FIELDS.forEach(function (field) {
                if (wantField(options, field)
                    && cache.zoneinfo_objects[vmobj.uuid]
                    && cache.zoneinfo_objects[vmobj.uuid]
                        .hasOwnProperty(field)) {

                    vmobj[field] = cache.zoneinfo_objects[vmobj.uuid][field];
                }
            });

            cb();
        }, function (cb) {
            /*
             * Caller's field list doesn't include any fields from JSON files,
             * so don't bother loading them (optimization).
             */
            if (!wantAnyFields(options, VMOBJ_JSON_FIELDS)) {
                cb();
                return;
            }

            // whatever we got back, add to the VM object
            VMOBJ_JSON_FIELDS.forEach(function (m) {
                if (wantField(options, m)
                    && cache.json_objects.hasOwnProperty(vmobj.uuid)
                    && cache.json_objects[vmobj.uuid].hasOwnProperty(m)) {

                    vmobj[m] = cache.json_objects[vmobj.uuid][m];
                }
            });

            cb();
        }, function (cb) {
            if (vmobj.state !== 'receiving') {
                log.trace('not "receiving", no need to lookup receiving.json');
                cb();
                return;
            }

            fs.readFile('/etc/zones/' + uuid + '-receiving.json',
                function (err, data) {
                    var receiving_props;

                    if (err) {
                        cb(err);
                        return;
                    }

                    try {
                        receiving_props = JSON.parse(data.toString());
                    } catch (e) {
                        cb(e);
                        return;
                    }

                    // add some props to the object that might be missing
                    if (!vmobj.hasOwnProperty('zfs_filesystem')
                        && receiving_props.hasOwnProperty('zfs_filesystem')) {

                        vmobj.zfs_filesystem = receiving_props.zfs_filesystem;
                    }

                    cb();
                }
            );
        }, function (cb) {
            /*
             * If we have dataset_objects, we want to ensure we add in any
             * fields we need from them.
             */
            if (cache.dataset_objects) {
                addDatasetProperties(vmobj, cache.dataset_objects, options, cb);
                return;
            }

            // no zfs props requested, nothing to do.
            cb();
        }, function (cb) {
            /*
             * Remove non-requested 'fields' that might have been added as
             * dependencies or because grabbing together was easier.
             */
            if (options.hasOwnProperty('fields')) {
                Object.keys(vmobj).forEach(function (key) {
                    if (!wantField(options, key)) {
                        delete vmobj[key];
                    }
                });
            }
            cb();
        }
    ], function (err) {
        if (err) {
            callback(err);
            return;
        }
        callback(null, vmobj);
    });
}

/*
 * getVmobjs is used to lookup the *list* of VMs that match the specified
 * filters. The filter parameter is a function.
 *
 * Starting with an array of all VMs on this node, the VM objects are passed
 * one at a time through the filter function. If the function returns a true
 * value (calls filter_cb(true)), the VM will be included in the result. If it
 * returns a false-y value, it will not.
 *
 * So for example if we start with a list of VMs:
 *
 *   [ A, B, C, D ]
 *
 * filter() will be called with:
 *
 *   filter(vmobj, filter_cb)
 *
 * for *all* VMs. And filter() should call filter_cb(true) if it wants the VM
 * to be in the output and filter_cb(false) if it does not.
 *
 * callback will be called with an error when there is an internal error or an
 * error with your options / match_fields, but not when no VMs match. In that
 * case callback will still be called, but with an empty array as the second
 * argument.
 *
 */
function getVmobjs(filter, options, callback)
{
    var cache;
    var vmobjs = [];

    assert(typeof (filter) === 'function', 'filter must be a function');

    async.series([
        function (cb) {
            if (options.hasOwnProperty('cache')) {
                cache = options.cache;
                cb();
                return;
            }

            /*
             * If cache was not prepopulated, load now for all VMs. "options"
             * will potentially limit which fields are in output objects.
             */
            getZoneData(null, options, function (err, _cache) {
                if (err) {
                    cb(err);
                    return;
                }

                cache = _cache;
                cb();
            });
        }, function (cb) {
            var vms = Object.keys(cache.zoneadm_objects);
            async.each(vms,
                function (uuid, vm_cb) {
                    var get_options = options;

                    /*
                     * we've made sure we have a cache of everything, use the
                     * same one for each getVmobj().
                     */
                    get_options.cache = cache;
                    getVmobj(uuid, get_options, function (err, obj) {
                        if (err) {
                            vm_cb(err);
                            return;
                        }

                        vmobjs.push(obj);
                        vm_cb();
                        return;
                    });
                }, function (err) {
                    if (err) {
                        cb(err);
                        return;
                    }
                    cb();
                }
            );
        }
    ], function (err) {
        if (err) {
            callback(err);
            return;
        }

        async.filterSeries(vmobjs, filter, function (results) {
            callback(null, results);
        });
    });
}

/*
 * getZoneData() loads data for zone(s).
 *
 * options can include:
 *
 *  log: bunyan logger (required)
 *  cache: existing cache object (see below)
 *  fields: only load these fields into the cache
 *
 * cache should look similar to the following for both input and the results.
 *
 *  dataset_objects:
 *      {
 *        datasets: {
 *          'zones/01b2c898-945f-11e1-a523-af1afbe22822': {...},
 *          'zones/01b2c898-945f-11e1-a523-af1afbe22822@final': {...},
 *          ...
 *        },
 *        mountpoints: {
 *          '/zones/01b2c898-945f-11e1-a523-af1afbe22822':
 *            'zones/01b2c898-945f-11e1-a523-af1afbe22822',
 *          ...
 *        },
 *        snapshots: {
 *          'zones/01b2c898-945f-11e1-a523-af1afbe22822': {...},
 *          ...
 *        }
 *      }
 *
 *  json_objects:
 *      {
 *        <uuid>: {
 *          customer_metadata: ...,
 *          internal_metadata: ...,
 *          tags: ...,
 *          routes: ...
 *        },
 *        <uuid>: ...
 *      }
 *
 *  last_modified:
 *      {
 *        <uuid>: '2014-02-15T00:42:58.000Z',
 *        <uuid>: ...
 *      }
 *
 *  pids:
 *      {
 *        <uuid>: pid,
 *        <uuid>: pid,
 *        ...
 *      }
 *
 *  sysinfo:
 *      {
 *        'UUID': ...,
 *        'Hostname': ...,
 *        ...
 *      }
 *
 *  zoneadm_objects:
 *      {
 *        <uuid>: {
 *          uuid: ...,
 *          zonename: ...,
 *          state: ...,
 *          ...
 *        }
 *      }
 *
 *  zonexml_objects:
 *      {
 *        <uuid>: {
 *          zonename: '...',
 *          zonepath: '...',
 *          ...
 *        },
 *        <uuid>: {
 *          ...
 *        },
 *        ...
 *      }
 *
 */
function getZoneData(uuid, options, callback)
{
    var cache = {};

    /*
     * If you pass in a cache, we'll only load those members that are not
     * already present. (each load* function returns if cache exists)
     */
    if (options.hasOwnProperty('cache')) {
        cache = options.cache;
    }

    // we do this in series, because later bits need the list of zones
    async.eachSeries([
        loadZoneadmObjects,
        loadSysinfo,
        loadZoneinfoObjects,
        loadZonexmlObjects,
        loadLastExited,
        loadLastModified,
        loadJsonObjects,
        loadDatasetObjects
    ], function _loadWrapper(fn, cb) {
        /*
         * we expect each parameter to read from options and set their data
         * into cache.<whatever> when they're requested to.
         */
        fn(uuid, cache, options, cb);
    }, function (err) {
        if (err) {
            callback(err);
            return;
        }

        callback(null, cache);
    });
}

/*
 * the load* functions below take the same arguments and should:
 *
 *  - always call callback with either no options or an error object
 *  - assume options.log is already set to a bunyan logger
 *  - call callback() and return if cache.<whatever> already exists
 *  - write a log message (debug) with how log it took to load the data
 *
 */

function loadDatasetObjects(uuid, cache, options, callback)
{
    var log;
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('dataset_objects')) {
        // Already have dataset_objects passed in, trust caller
        log.trace('using existing cache.dataset_objects');
        callback();
        return;
    }

    // load ZFS dataset data (zfs_root_*, zfs_data_*, disks, snapshots)
    if (!wantAnyFields(options, VMOBJ_ZFS_FIELDS)) {
        log.trace('no need to load zfs data, no zfs fields requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    getDatasets(options, function (err, results) {

        log.debug('loading dataset_objects took '
            + ((new Date).getTime() - start_time) + ' ms');

        if (err) {
            callback(err);
            return;
        }
        cache.dataset_objects = results;
        callback();
    });
}

function loadJsonObjects(uuid, cache, options, callback)
{
    var errors = [];
    var log;
    var json_objects = {};
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('json_objects')) {
        // Already have json_objects passed in, trust caller
        log.trace('using existing cache.json_objects');
        callback();
        return;
    }

    /*
     * Caller's field list doesn't include any fields from JSON files,
     * so don't bother loading them (optimization).
     */
    if (!wantAnyFields(options, VMOBJ_JSON_FIELDS)) {
        log.trace('no need to load JSON files, no json fields requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    // (parallel)
    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
        var obj = cache.zoneadm_objects[vm_uuid];

        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
            + '"zonepath": ' + JSON.stringify(obj));

        getVmobjJSON(obj.zonepath, options, function (err, results) {
            if (err) {
                /*
                 * when zone_state is 'incomplete' we could be deleting it
                 * in which case metadata may already be gone, ignore
                 * failure to load mdata when 'incomplete' because of this.
                 */
                if (obj.state === 'incomplete') {
                    log.debug({err: err}, 'zone is in state incomplete '
                        + 'ignoring error loading JSON');
                } else {
                    errors.push(err);
                    log.error(err);
                }
                cb();
                return;
            }

            json_objects[vm_uuid] = {};

            // whatever we got back, add to the VM object
            VMOBJ_JSON_FIELDS.forEach(function (m) {
                if (results.hasOwnProperty(m)) {
                    json_objects[vm_uuid][m] = results[m];
                }
            });

            cb();
        });
    }, function (err) {
        log.debug('loading json_objects took '
            + ((new Date).getTime() - start_time) + ' ms');

        if (errors.length > 0) {
            // XXX just return the first error for now
            callback(errors[0]);
            return;
        }

        cache.json_objects = json_objects;
        callback();
    });
}

function loadLastExited(uuid, cache, options, callback)
{
    var last_exited = {};
    var log;
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('last_exited')) {
        // Already have last_exited passed in, trust caller
        log.trace('using existing cache.last_exited');
        callback();
        return;
    }

    if (!wantField(options, 'exit_status')
        && !wantField(options, 'exit_timestamp')) {

        log.trace('no need to load "lastexited", field(s) not requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    // (parallel)
    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
        var obj = cache.zoneadm_objects[vm_uuid];

        assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
            + '"zonename": ' + JSON.stringify(obj));
        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
            + '"zonepath": ' + JSON.stringify(obj));

        getLastExited(obj.zonename, obj.zonepath, log, function (err, result) {
            if (!err) {
                last_exited[vm_uuid] = result;
            }
            cb();
        });
    }, function (err) {
        log.debug('loading last_exited took '
            + ((new Date).getTime() - start_time) + ' ms');
        cache.last_exited = last_exited;
        callback();
    });
}

function loadLastModified(uuid, cache, options, callback)
{
    var last_modified = {};
    var log;
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('last_modified')) {
        // Already have last_modified passed in, trust caller
        log.trace('using existing cache.last_modified');
        callback();
        return;
    }

    if (!wantField(options, 'last_modified')) {
        log.trace('no need to load "last_modified", field not requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    // (parallel)
    async.each(Object.keys(cache.zoneadm_objects), function (vm_uuid, cb) {
        var obj = cache.zoneadm_objects[vm_uuid];

        assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
            + '"zonename": ' + JSON.stringify(obj));
        assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
            + '"zonepath": ' + JSON.stringify(obj));

        getLastModified(obj.zonename, obj.zonepath, log, function (err, time) {
            if (!err) {
                last_modified[vm_uuid] = time;
            }
            cb();
        });
    }, function (err) {
        log.debug('loading last_modified took '
            + ((new Date).getTime() - start_time) + ' ms');
        cache.last_modified = last_modified;
        callback();
    });
}

function loadSysinfo(uuid, cache, options, callback)
{
    var log;
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('sysinfo')) {
        log.trace('using existing cache.sysinfo');
        callback();
        return;
    }

    if (!wantAnyFields(options, VMOBJ_SYSINFO_FIELDS)) {
        log.trace('no need to load "sysinfo", no sysinfo fields requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    getSysinfo(log, function (err, sysinfo) {

        log.debug('loading sysinfo took '
            + ((new Date).getTime() - start_time) + ' ms');

        if (err) {
            log.error(err);
            callback(err);
            return;
        }
        cache.sysinfo = sysinfo;
        callback();
    });
}

function loadZoneinfoObjects(uuid, cache, options, callback)
{
    var log;
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('zoneinfo_objects')) {
        // Already have zoneinfo_objects passed in, trust caller
        log.trace('using existing cache.zoneinfo_objects');
        callback();
        return;
    }

    if (!wantAnyFields(options, VMOBJ_ZONEINFO_FIELDS)) {
        log.trace('no need to load "zoneinfo", no zoneinfo fields requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    /*
     * NOTE: we pass in the uuid parameter we were provided which means the
     * resulting cache will only contain information about this VM when
     * uuid !== null.
     */
    getZoneinfo(uuid, options, function (err, results) {
        log.debug('loading zoneinfo_objects took '
            + ((new Date).getTime() - start_time) + ' ms');

        if (err) {
            callback(err);
            return;
        }

        cache.zoneinfo_objects = results;
        callback();
    });
}

function loadZoneadmObjects(uuid, cache, options, callback)
{
    var log;
    var start_time;

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('zoneadm_objects')) {
        // Already have zoneadm_objects passed in, trust caller
        log.trace('using existing cache.zoneadm_objects');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    /*
     * NOTE: we pass in the uuid parameter we were provided which means the
     * resulting cache will only contain information about this VM when
     * uuid !== null.
     */
    getZoneRecords(uuid, options, function (err, results) {
        log.debug('loading zoneadm_objects took '
            + ((new Date).getTime() - start_time) + ' ms');

        if (err) {
            callback(err);
            return;
        }

        cache.zoneadm_objects = results;
        callback();
    });
}

function loadZonexmlObjects(uuid, cache, options, callback)
{
    var errors = [];
    var log;
    var start_time;
    var vmobjs = {};

    log = options.log; // caller has asserted

    if (cache.hasOwnProperty('zonexml_objects')) {
        log.trace('using existing cache.zonexml_objects');
        callback();
        return;
    }

    if (!wantAnyFields(options, VMOBJ_XML_FIELDS)) {
        log.trace('no need to load xml files, no zonexml fields requested');
        callback();
        return;
    }

    start_time = (new Date).getTime();

    // load the XML and translate to JSON in parallel for all VMs in
    // cache.zoneadm_objects
    async.each(Object.keys(cache.zoneadm_objects),
        function (vm_uuid, cb) {
            var obj = cache.zoneadm_objects[vm_uuid];

            assert(obj.hasOwnProperty('brand'), 'zoneadm_object missing '
                + '"brand": ' + JSON.stringify(obj));
            assert(obj.hasOwnProperty('zonepath'), 'zoneadm_object missing '
                + '"zonepath": ' + JSON.stringify(obj));
            assert(obj.hasOwnProperty('zonename'), 'zoneadm_object missing '
                + '"zonename": ' + JSON.stringify(obj));

            // load data from /etc/zones/<zonename>.xml
            getVmobjXMLFile(path.join('/etc/zones', obj.zonename + '.xml'),
                options,
                function (err, xmlobj) {
                    if (!err) {
                        vmobjs[vm_uuid] = xmlobj;
                    } else {
                        log.error(err, 'unable to load '
                            + path.join('/etc/zones', obj.zonename + '.xml'));
                        errors.push(err);
                    }

                    cb();
                }
            );
        }, function (err) {
            log.debug('loading zonexml_objects took '
                + ((new Date).getTime() - start_time) + ' ms');

            if (errors.length > 0) {
                // XXX just return the first error for now
                callback(errors[0]);
                return;
            }

            cache.zonexml_objects = vmobjs;
            callback();
        }
    );
}

module.exports = {
    getVmobj: getVmobj,
    getVmobjs: getVmobjs,
    getZoneData: getZoneData
};
