/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2020 Joyent, Inc.
 *
 * Zonecfg wrapper with a per-zone lock file
 */

var cp = require('child_process');
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var qlocker = require('/usr/node/node_modules/qlocker');
var vasync = require('/usr/vm/node_modules/vasync');

var LOCK_PATH = '/var/run/.vm.%s.zonecfg.lockfile';

module.exports = zonecfg;

/*
 * Call zonecfg(8) with a given set of arguments and optional stdin data.
 * A lock file will be acquired (based on the id given as the first argument,
 * typically a zoneuuid) to ensure that only one instance of zonecfg will be
 * run at a time per zone.
 *
 * Example:
 *
 * var uuid = 'ac1946a2-fa79-47c7-9bc3-729fcc5a19d2';
 * var cmd = ['set autoboot=false'];
 * var opts = {
 *   log: log
 * };
 *
 * zonecfg(uuid, cmd, opts, function (err, fds) {
 *     if (err) {
 *         // command exited non-zero or failed to spawn for some reason
 *         throw err;
 *     }
 *
 *     // fds.stdout and fds.stderr set
 * });
 *
 * - uuid: a zone's UUID (preferable) or zonename
 * - args: arguments to pass to zonecfg(8) as an array of strings
 * - opts: options object
 *   - opts.log         [required] bunyan logger
 *   - opts.stdin       [optional] a string to pass to the child as stdin
 *   - opts.useZonename [optional] a boolean that tells if the uuid argument is
 *                                 the zones uuid or zonename
 * - callback: callback function with the signature function (err, fds) {}
 *
 * By default, the arguments ['-u', uuid] will be prepended to the arguments
 * passed with the second argument.  If opts.useZonename is true, then ['-z',
 * uuid] will be specified instead - this is particularly useful when creating
 * a zone, since the zone will not exist and thus not have a UUID to be
 * referenced.
 *
 */
function zonecfg(uuid, args, opts, callback) {
    assert.uuid(uuid, 'uuid');
    assert.arrayOfString(args, 'args');
    assert.object(opts, 'opts');
    assert.object(opts.log, 'opts.log');
    assert.optionalString(opts.stdin, 'opts.stdin');
    assert.optionalBool(opts.useZonename, 'opts.useZonename');
    assert.func(callback, 'callback');

    args.unshift(uuid);
    args.unshift(opts.useZonename ? '-z' : '-u');

    var cmd = 'zonecfg';
    var file = util.format(LOCK_PATH, uuid);
    var child;
    var unlock;
    var execOpts = {
        encoding: 'utf8'
    };
    var ret = {};
    var log = opts.log.child({cmd: cmd, args: args, file: file});

    vasync.pipeline({funcs: [
        function (_, cb) {
            // acquire lock
            log.debug('acquiring lock %s', file);

            qlocker.lock(file, function (err, _unlock) {
                if (err) {
                    log.error({err: err}, 'failed to acquire lock %s', file);
                    cb(err);
                    return;
                }

                log.debug('acquired lock %s', file);

                unlock = _unlock;
                cb();
            });
        }, function (_, cb) {
            log.debug('calling %s', cmd);

            child = cp.execFile(cmd, args, execOpts,
                function (err, stdout, stderr) {

                ret.stderr = stderr;
                ret.stdout = stdout;

                if (err) {
                    log.error({err: err}, '%s call failed', cmd);
                    cb(err);
                    return;
                }

                log.debug({ret: ret}, '%s ran successfully', cmd);
                cb();
            });

            if (opts.stdin !== undefined) {
                log.debug({stdin: opts.stdin}, 'writing to stdin');
                child.stdin.write(opts.stdin);
                child.stdin.end();
            }
        }
    ]}, function (err) {
        if (err) {
            log.error({err: err}, 'zonecfg error for %s: %s',
                uuid, err.message);
        }

        if (!unlock) {
            callback(err, ret);
            return;
        }

        unlock(function (unlock_err) {
            if (unlock_err) {
                log.error({err: unlock_err}, 'failed to unlock %s', file);
                callback(unlock_err);
                return;
            }

            callback(err, ret);
        });
    });
}
