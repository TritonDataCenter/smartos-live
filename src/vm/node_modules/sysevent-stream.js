/*
 * Copyright 2015, Joyent, Inc.
 *
 * SyseventStream subscriptions Stream
 */

var spawn = require('child_process').spawn;
var stream = require('stream');
var util = require('util');

var LineStream = require('/usr/node/node_modules/linestream.js');

function noop() {}

module.exports = SyseventStream;

/*
 * Create a new sysevent stream by forking sysevent(1M).
 *
 * Arguments - (all properties are optional)
 *
 * opts.channel (String) sysevent channel to bind to
 *   - defaults to no channel if undefined or null
 * opts.class (String) sysevent class
 *   - defaults to all if undefined or null
 * opts.subclasses (Array) sysevent subclasses
 *   - defaults to all if undefined or null
 * opts.logger - bunyan logger object to use
 *   - defaults to noop's
 *
 * Events
 *
 * The object returned is a stream and will emit any "error" events
 * from the underlying child process, as well as "event" events with
 * a single argument: an object representing the sysevent.
 *
 * Example Construction
 *
 * // watch all sysevents
 * new SyseventStream();
 *
 * // watch for events in class "foo_class"
 * new SyseventStream({class: 'foo_class'});
 *
 * // watch for events in class "foo_class" and subclass "foo_subclass" or
 * // "bar_subclass"
 * new SyseventStream({
 *     class: 'foo_class',
 *     subclasses: ['foo_subclass', 'bar_subclass']
 *  });
 *
 * // watch for events in class "foo_class" and channel "foo_channel"
 * new SyseventStream({channel: 'foo_channel', class: 'foo_class'});
 *
 * // watch all sysevents and log to a bunyan logger instance
 * new SyseventStream({logger: bunyan_logger});
 *
 * Example Usage
 *
 *     var se = new SyseventStream({
 *         class: 'EC_ZFS',
 *         subclasses: ['ESC_ZFS_history_event']
 *     });
 *     se.on('readable', function () {
 *         var ev;
 *         while ((ev = se.read()) !== null)
 *             console.log(JSON.sringify(ev, null, 2));
 *     });
 *
 * yields
 *
 *     {
 *       "date": "2015-07-21T00:18:18.196Z",
 *       "vendor": "SUNW",
 *       "publisher": "zfs",
 *       "class": "EC_zfs",
 *       "subclass": "ESC_ZFS_history_event",
 *       "pid": 0,
 *       "data": {
 *         "pool_name": "zones",
 *         "pool_guid": 4668373440529934000,
 *         "history_record": {
 *           "history command": "zfs create zones/foobar",
 *           "history who": 0,
 *           "history time": 1437437898,
 *           "history hostname": "gz"
 *         }
 *       }
 *     }
 *
 */
function SyseventStream(opts) {
    var self = this;

    self.ses_stopped = false;

    // become a transform stream
    stream.Transform.call(self, {objectMode: true});

    // process opts
    opts = opts || {};
    self.ses_class = opts.class;
    self.ses_subclasses = opts.subclasses;
    self.ses_channel = opts.channel;

    // create child logger
    if (opts.logger) {
        var obj = {
            class: self.ses_class,
            subclasses: self.ses_subclasses
        };
        if (self.ses_channel)
            obj.channel = self.ses_channel;
        self.ses_logger = opts.logger.child(obj);
    } else {
        self.ses_logger = {
            trace: noop,
            debug: noop,
            log: noop,
            info: noop,
            warn: noop,
            error: noop
        };
    }

    // construct arguments to give to sysevent(1M)
    var args = ['-j'];
    if (self.ses_channel)
        args.push('-c', self.ses_channel);
    if (self.ses_class) {
        args.push(self.ses_class);
        if (self.ses_subclasses)
            args = args.concat(self.ses_subclasses);
    }

    // fork sysevent(1M)
    self.ses_logger.info({args: args}, 'calling /usr/sbin/sysevent %s',
        args.join(' '));

    self.ses_child = spawn('/usr/sbin/sysevent', args);
    self.ses_child.stdout.setEncoding('utf8');
    self.ses_child.stderr.setEncoding('utf8');

    // any child error will be logged and re-emitted
    self.ses_child.on('error', function (e) {
        self.ses_logger.error({err: e}, 'child process error');
        self.emit('error', e);
    });

    // a child dying is either an info or error message depending
    // on if it was intentional (ie. .stop() was called)
    self.ses_child.on('close', function (code, signal) {
        if (self.ses_stopped) {
            self.ses_logger.info({code: code, signal: signal},
                'sysevent stopped');
            return;
        }
        var e = new Error('child exited');
        self.ses_logger.error({err: e, code:code, signal: signal},
            'child process closed');
        self.emit('error', e);
    });

    // stdin is not needed
    self.ses_child.stdin.end();

    // parse stdout line by line by piping to ourselves
    var stdoutls = new LineStream();
    self.ses_child.stdout.pipe(stdoutls).pipe(self);

    // parse stderr line by line - any stderr produced is a fatal error
    var stderrls = new LineStream();
    self.ses_child.stderr.pipe(stderrls).on('readable', function () {
        var lines = [];
        var line;
        while ((line = stderrls.read()) !== null)
            lines.push(line);

        self.ses_logger.error({stderr: lines.join('\n')}, 'stderr produced');
        self._abort();
    });
}
util.inherits(SyseventStream, stream.Transform);

/*
 * the transform method to process sysevent(1M) stdout line-by-line
 */
SyseventStream.prototype._transform = function _transform(chunk, encoding, cb) {
    var line = chunk.toString('utf8');
    var ev;
    try {
        ev = JSON.parse(line);
    } catch (e) {
        // any JSON parse failure is a fatal error
        this.ses_logger.error({err: e, line: line},
            'failed to parse output line');
        this._abort();
        return;
    }

    ev.date = new Date(ev.date);
    this.push(ev);
    cb();
};

/*
 * cleanly stop the SyseventStream by killing the child process
 * with a SIGTERM
 */
SyseventStream.prototype.stop = function stop() {
    this.stopped = true;
    this.ses_child.kill();
};

/*
 * stop the SyseventStream and force sysevent(1M) to dump core -
 * this should only be called from within this module
 */
SyseventStream.prototype._abort = function _abort() {
    this.stopped = true;
    this.ses_logger.error({child: this.ses_child.pid},
        '_abort() called - sending SIGABRT');
    this.ses_child.kill('SIGABRT');
    var e = new Error('sysevent(1M) aborted');
    this.emit('error', e);
};

/*
 * if called directly, just hook up a sysevent stream and emit
 * JSON on stdout
 */
if (require.main === module) {
    var logger = require('./bunyan').createLogger({name: 'sysevent'});
    var se = new SyseventStream({logger: logger});
    se.on('readable', function () {
        var ev;
        while ((ev = se.read()) !== null) {
            console.log('- event received -');
            console.log(JSON.stringify(ev, null, 2));
        }
    });
}
