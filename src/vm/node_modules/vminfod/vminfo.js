/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2015, Joyent, Inc.
 *
 */

/*
 * The primary function of this module is to mantain an up-to-date copy of:
 *
 *   1) the complete vmobj list
 *   2) a vmload cache object.
 *
 * Both objects are consumable from the webservice:
 *
 *   - The complete vm list can be consumed at /vms
 *   - A single vm can be consumed at /vms/UUID
 *   - The cache can be consumed at /data
 *
 * To use you should do something like:
 *
 *  vminfo = new VMInfo({log: log});
 *  vminfo.start([callback]);
 *  vminfo.stop([callback]);
 *  vminfo.on(<event type>, callback(data));
 *
 * Where the event types can be:
 *
 *  ready - emitted when vminfo has initialized after start()
 *  end - emitted when vminfo has shutdown after stop()
 *  create - emitted when a new vm is created
 *  modify - emitted when an existing vm is modified
 *  delete - emitted when an existing vm is deleted
 *
 * on 'ready' the callback will be called, passing the list of vmobjs as the
 * first and only argument.
 *
 * on 'end' the callback will be called, without any arguments
 *
 * on 'create' the callback will be called, passing the newly created vmobj as
 * the first and only argument.
 *
 * on 'modify' the callback will be called, passing the updated vmobj as the
 * first argument, and a list of changes as the second argument.
 *
 * on 'delete' the callback will be called, passing the zonename of the vmobj
 * as the first and only argument.
 *
 * Events can also be consumed through the webservice at GET /events. The client
 * connection will be held open until the client explicitly closes the socket.
 * Events will be streamed to the client in http chunks. Each event will be
 * a JSON object. When unwrapped, the 'type' attribute will indicate the event
 * type. All relevant data to the event will be included in the JSON object.
 *
 * How this works:
 *
 *   The tl;dr overview is that this module will listen for events within 3
 *   broad categories: zone state, zone config files, and zfs datasets.
 *   When an event is fired, we will delete portions of the cache object that
 *   are relevant to the event, then ask vmload to fill in the holes with
 *   getZoneData, which we can then update the vmobjs that were affected
 *   by the change, and lastly inform any subscribed consumers of the specific
 *   changes to the vmobj data.
 *
 *   This module is not necessarily concerned with the details of a vmobj.
 *   Meaning, the structure of the vmobj, where the data is derived, and how
 *   the data is transformed are not the concern of this module. This module
 *   will delegate that responsibility to the vmload modules. This module is
 *   concerned with knowing when pieces of the cache object are likely
 *   out-of-date, how to re-populate those pieces, and which vmobjs will be
 *   affected by the change.
 *
 *   The vmload module generates the final vmobj data from the following areas:
 *     - (1) the zone_t struct extracted from mdb
 *     - (1) the zoneadm utility
 *     - (2) the /etc/zones/UUID.xml file
 *     - (2) json files located in /zones/config/metadata*.json
 *     - (3) datasets from zfs list
 *
 *   The data derived from category 1 (above) will need to be invalidated and
 *   re-generated upon the reception of a zone event. Within the cache object,
 *   we will delete ["last_modified"][<uuid>], ["pids"][<uuid>], and
 *   ["zoneadm_objects"][<uuid>]. Finally, we will call vmload.getVmobj(<uuid>)
 *   to re-populate this data, and replace the vmobj with the corresponding
 *   uuid.
 *
 *   The data derived from category 2 (above) will need to be invalidated and
 *   re-generated upon the reception of a filesystem event watching the specific
 *   file in question. If the file is /etc/zones/uuid.xml, we will delete
 *   ["zonexml_objects"][<uuid>]. If the file is
 *   /zones/config/metadataTYPE.json, we will delete the corresponding key
 *   within ["json_objects"]["uuid"][...]. Finally, we will call
 *   vmload.getVmobj(<uuid>) to re-populate this data, and replace the vmobj
 *   with the corresponding uuid.
 *
 *   The data derived from category 3 (above) requires more work. At first, we
 *   will start by listening for a zfs event. The event will notify us that a
 *   dataset was created, renamed, or deleted. To minimize the zfs list, we will
 *   remove all relevant pieces from within the "dataset_objects" structure,
 *   then we will ask vmload-datasets directly to re-create the
 *   "dataset_objects" by informing the vmload-datasets getDatasets function to
 *   only generate the objects for the specific dataset that was modified. Some
 *   of these steps are conditional to the dataset action. For instance, a
 *   create will not require us to remove properties, and likewise, a delete
 *   will not require us to rebuild the datasets structure after the pieces are
 *   removed. Finally, we will derive the uuid from the dataset name, and will
 *   call vmload.getVmobj(<uuid>) to re-populate this data, and replace the
 *   vmobj with the corresponding uuid.
 *
 *   At a routine interval, we will also force-refresh the cache and regenerate
 *   the vmobj sets to ensure data integrity. When the refresh interval is
 *   fired, we will first pause the event queue, then request a new cache
 *   object. Once we have received a new cache object, we can replace the
 *   current cache object with the new if the two cache objects are different.
 *   Only if the two objects are different, we will iterate through all vmobjs
 *   and generate a new vmobj from the new cache and report any deltas along the
 *   way. Finally, after all vmobjs have been updated, we will resume the queue.
 *   It is possible that resuming the events in the paused queue will cause some
 *   events to replay that will have no effect in the final datasets.
 *
 *   A new vmobj is created when a zone event is received for a uuid that we're
 *   not currently watching, which will then register observers for relevant
 *   config files.
 *
 *   A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the
 *   DELETE event. At this point, we will also remove all watchers that were
 *   setup for that vmobj.
 *
 */

var assert = require('assert');
var async = require('/usr/node/node_modules/async');
var EventEmitter = require('events').EventEmitter;
var FsWatcher = require('./fswatcher').FsWatcher;
var vmload = require('../vmload');
var getZoneRecords = require('../vmload/vmload-zoneadm')
    .getZoneRecords;
var getDatasets = require('../vmload/vmload-datasets')
    .getDatasets;
var http = require('http');
var path = require('path');
var url = require('url');
var util = require('util');
var ZoneWatcher = require('./zonewatcher').ZoneWatcher;
var ZpoolWatcher = require('./zpoolwatcher').ZpoolWatcher;
var Queue = require('queue');
var objDiff = require('./diff').objDiff;

var CONFIG_FILES = [
    'metadata.json',
    'routes.json',
    'tags.json'
];

var VMInfo = module.exports = function (options) {
    var self = this;

    // global state/status
    self.state = 'stopped';
    self.status = 'initialized';

    // structures to hold the raw data
    self.vm_data = {};
    self.vm_data_tmp = undefined;
    self.zone_vm_data = {};
    self.zone_vm_data_tmp = {};
    self.vmobjs = {};

    // structures to hold the pre-serialized data
    self.vm_data_json = {};
    self.vmobjs_json = {};

    self.pending_zpools = {};

    // configurable options
    self.log = options.log;

    assert(self.log, 'must provide a logger');

    // set default port
    if (options.hasOwnProperty('port')) {
        self.port = options.port;
    } else {
        self.port = 9090;
    }

    // set default refresh interval
    if (options.hasOwnProperty('refresh_interval')) {
        self.refresh_interval = options.refresh_interval;
    } else {
        self.refresh_interval = 5 * 60 * 1000;
    }

    function vmDatasets(zonename) {
        if (zonename) {
            if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
                return ([self.zone_vm_data[zonename],
                    self.zone_vm_data_tmp[zonename]]);
            } else {
                return ([self.zone_vm_data[zonename]]);
            }
        } else {
            if (self.vm_data_tmp !== undefined) {
                return ([self.vm_data, self.vm_data_tmp]);
            } else {
                return ([self.vm_data]);
            }
        }
    }

    function resetVmDatasets(zonename) {
        if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
            delete (self.zone_vm_data_tmp)[zonename];
        }

        if (self.zone_vm_data.hasOwnProperty(zonename)) {
            delete (self.zone_vm_data)[zonename];
        }
    }

    function cloneVmDatasets(zonename) {

        function cloneVmDataset(from, to) {
            Object.keys(from).forEach(function (key) {
                switch (key) {
                case 'dataset_objects':
                case 'sysinfo':
                    to[key] = from[key];
                    break;
                default:
                    if (!to.hasOwnProperty(key)) {
                        to[key] = {};
                    }
                    if (from[key].hasOwnProperty(zonename)) {
                        to[key][zonename] = from[key][zonename];
                    }
                    break;
                }
            });
        }

        if (self.vm_data_tmp !== undefined) {
            self.zone_vm_data_tmp[zonename] = {};
            cloneVmDataset(self.vm_data_tmp, self.zone_vm_data_tmp[zonename]);
        }

        self.zone_vm_data[zonename] = {};
        cloneVmDataset(self.vm_data, self.zone_vm_data[zonename]);
    }

    function mergeZoneVmDatasets(zonename) {

        /*
         * The rationale here is to iterate through all of the keys in the from
         * object and check for a zonename key. If it exists, copy it over. Then
         * we remove any objects containing the zonename key in the to object
         * that aren't in the from object, to ensure we don't leave any cruft.
         */
        function mergeVmDataset(from, to) {
            Object.keys(from).forEach(function (key) {
                if (from[key].hasOwnProperty(zonename)) {
                    to[key][zonename] = from[key][zonename];
                } else {
                    if (to[key].hasOwnProperty(zonename)) {
                        delete (to[key])[zonename];
                    }
                }
            });
        }

        /*
         * Any time a point of data has been merged, we also need to clear
         * the cached JSON for this data. The JSON will later be generated
         * and cached as needed by incoming requests.
         */
        function clearCache(from) {
            Object.keys(from).forEach(function (key) {
                if (from[key].hasOwnProperty(zonename)
                    && self.vm_data_json.hasOwnProperty(key)
                    && self.vm_data_json[key].hasOwnProperty(zonename)) {

                    delete (self.vm_data_json[key])[zonename];
                }
            });
        }

        if (self.vm_data_tmp !== undefined
            && self.zone_vm_data_tmp.hasOwnProperty(zonename)) {

            mergeVmDataset(self.zone_vm_data_tmp[zonename], self.vm_data_tmp);
            clearCache(self.zone_vm_data_tmp[zonename]);
        }

        if (self.zone_vm_data.hasOwnProperty(zonename)) {
            mergeVmDataset(self.zone_vm_data[zonename], self.vm_data);
            clearCache(self.zone_vm_data[zonename]);
        }

        resetVmDatasets(zonename);
    }

    /*
     * handleZoneEvent() is a callback for a ZoneWatcher
     *
     * Process:
     *
     *   First we extract the zonename property from the event, then see if we
     *   have any vmobjs registered with that zonename. If not, then this must
     *   be a vm create, which we will:
     *     1) fetch the vmobj from vmload.getVmobj
     *     2) register observers
     *     3) inform subscribers of the new vmobj
     *   If this is a vm that we already know about, we will:
     *     1) invalidate the relevant pieces of the vm_data
     *     2) refresh the vmobj by calling refreshVmobj
     */
    function handleZoneEvent(obj) {
        var zonename = obj.zonename;
        var vm_datasets;
        var meta;

        // we're only interested in change events
        if (obj.type !== 'change') {
            return;
        }

        meta = 'zonename: ' + obj.zonename + ' newstate: ' + obj.newstate;

        self.event_queue.enqueue({
            description: 'handle zone event - ' + meta,
            func: function (extras, callback) {
                extras.log.debug('handling zone event for %s', zonename);

                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    // a new vm!
                    createVmobj(zonename, callback);
                } else {
                    cloneVmDatasets(zonename);
                    vm_datasets = vmDatasets(zonename);

                    // remove pieces of the cache that might have been affected
                    var contexts = [
                        'zoneadm_objects',
                        'zonexml_objects',
                        'zoneinfo_objects'
                    ];

                    vm_datasets.forEach(function (data) {
                        contexts.forEach(function (context) {
                            if (data.hasOwnProperty(context)
                                && data[context].hasOwnProperty(zonename)) {

                                delete (data[context])[zonename];
                            }
                        });
                    });

                    refreshVmobj(zonename, vm_datasets, callback);
                }
            }
        });
    }

    function handleFsEvent(obj) {
        var zonexml_re = /\/etc\/zones\/(.+)\.xml/;
        var metadata_re = /\/zones\/(.+)\/config\/.+\.json/;
        var lastexit_re = /\/zones\/(.+)\/lastexited/;
        var matches;
        var zonename;
        var vm_datasets;
        var contexts;
        var meta;

        if (obj.type === 'ready' || obj.type === 'event') {
            return;
        }

        meta = 'pathname: ' + obj.pathname + ' changes: ' + obj.changes;
        self.log.debug({obj: obj}, 'handleFsEvent: %s', meta);

        if (zonexml_re.test(obj.pathname)) {
            matches = zonexml_re.exec(obj.pathname);
            zonename = matches[1];

            self.event_queue.enqueue({
                description: 'handle zonexml fs change - ' + meta,
                func: function (extras, callback) {
                    // short-circuit if this vmobj doesn't exist
                    if (!self.vmobjs.hasOwnProperty(zonename)) {
                        extras.log.debug('vmobj doesn\'t exist for %s',
                            zonename);
                        callback();
                        return;
                    }

                    if (obj.type === 'delete') {
                        extras.log.debug('%s deleted', obj.pathname);
                        // the show is over! teardown!
                        deleteVmobj(zonename, callback);
                    } else if (obj.type === 'change') {
                        extras.log.debug('%s modified', obj.pathname);
                        cloneVmDatasets(zonename);
                        vm_datasets = vmDatasets(zonename);

                        // clear the missing pieces and refresh
                        contexts = [
                            'zonexml_objects',
                            'last_modified'
                        ];

                        vm_datasets.forEach(function (data) {
                            contexts.forEach(function (context) {
                                if (data.hasOwnProperty(context)
                                    && data[context].hasOwnProperty(zonename)) {

                                    delete (data[context])[zonename];
                                }
                            });
                        });

                        refreshVmobj(zonename, vm_datasets, callback);
                    } else {
                        extras.log.warn({obj: obj},
                            'unhandled fs change type "%s"',
                            obj.type);
                        callback();
                    }
                }
            });

        } else if (metadata_re.test(obj.pathname)) {
            matches = metadata_re.exec(obj.pathname);
            zonename = matches[1];

            self.event_queue.enqueue({
                description: 'handle metadata fs update - ' + meta,
                func: function (extras, callback) {
                    extras.log.debug(obj.pathname + ' modified');
                    // short-circuit if this vmobj doesn't exist
                    if (!self.vmobjs.hasOwnProperty(zonename)) {
                        extras.log.debug('vmobj doesn\'t exist for %s',
                            zonename);
                        callback();
                        return;
                    }

                    cloneVmDatasets(zonename);
                    vm_datasets = vmDatasets(zonename);

                    // clear the missing pieces and refresh
                    contexts = [
                        'json_objects',
                        'last_modified'
                    ];

                    vm_datasets.forEach(function (data) {
                        contexts.forEach(function (context) {
                            if (data.hasOwnProperty(context)
                                && data[context].hasOwnProperty(zonename)) {

                                delete (data[context])[zonename];
                            }
                        });
                    });

                    refreshVmobj(zonename, vm_datasets, callback);
                }
            });
        } else if (lastexit_re.test(obj.pathname)) {
            matches = lastexit_re.exec(obj.pathname);
            zonename = matches[1];

            self.event_queue.enqueue({
                description: 'handle lastexit fs change - ' + meta,
                func: function (extras, callback) {
                    extras.log.debug(obj.pathname + ' modified');
                    // short-circuit if this vmobj doesn't exist
                    if (!self.vmobjs.hasOwnProperty(zonename)) {
                        self.log.debug('vmobj doesn\'t exist for ' + zonename);
                        callback();
                        return;
                    }

                    cloneVmDatasets(zonename);
                    vm_datasets = vmDatasets(zonename);

                    // clear the missing pieces and refresh
                    contexts = [
                        'last_exited',
                        'last_modified'
                    ];

                    vm_datasets.forEach(function (data) {
                        contexts.forEach(function (context) {
                            if (data.hasOwnProperty(context)
                                && data[context].hasOwnProperty(zonename)) {

                                delete (data[context])[zonename];
                            }
                        });
                    });
                    refreshVmobj(zonename, vm_datasets, callback);
                }
            });

        } else if (obj.pathname === '/tmp/.sysinfo.json') {
            self.event_queue.enqueue({
                description: 'handle sysinfo fs change - ' + meta,
                func: function (extras, callback) {
                    async.each(vmDatasets(), function (data, cb) {
                        if (data.hasOwnProperty('sysinfo')) {
                            delete data.sysinfo;
                        }
                        var opts = {
                            log: extras.log,
                            cache: data,
                            keepalive: true
                        };
                        vmload.getZoneData(null, opts, function (err, cache) {
                            if (err) {
                                extras.log.error('unable to refresh sysinfo, '
                                    + 'failed to getZoneData');
                            }

                            cb();
                        });
                    }, callback);
                }
            });
        } else {
            self.log.warn('unhandled event for file: %s', obj.pathname);
        }
    }

    /*
     * handleZpoolEvent() is a callback for a zpool watcher
     *
     * Process:
     *
     *   When action is clone or create:
     *     - fetch zpool data
     *     - merge into vm_cache
     *     - refresh vmobj
     *
     *   When action is set:
     *     - unset vm_data pieces
     *     - fetch zpool data
     *     - merge into vm_cache
     *     - refresh vmobj
     *
     *   When action is destroy:
     *     - unset vm_data
     *     - refresh vmobj
     *
     */
    function handleZpoolEvent(obj) {
        var sections = ['datasets', 'mountpoints', 'snapshots'];
        var name = obj.dsname;
        var uuid;
        var uuid_re;
        var meta;

        meta = 'dsname: ' + obj.dsname + ' action: ' + obj.action;

        // XXX: if the zonename isn't a uuid, this won't work. Is that ok?
        uuid_re = new RegExp('zones\/.*('
            + '[a-f0-9]{8}-'
            + '[a-f0-9]{4}-'
            + '[a-f0-9]{4}-'
            + '[a-f0-9]{4}-'
            + '[a-f0-9]{12})'
        );

        if (uuid_re.test(name)) {
            uuid = uuid_re.exec(name)[1];
        } else {
            uuid = 'global';
        }

        // ensure we aren't waiting for a zpool refresh on the same
        // zpool multiple times
        if (self.pending_zpools.hasOwnProperty(name)) {
            return;
        } else {
            self.pending_zpools[name] = true;
        }

        function expire() {

            function expireObjects(ds_objects) {
                sections.forEach(function (section) {
                    if (ds_objects.hasOwnProperty(section)) {
                        if (section === 'mountpoints') {
                            for (var key in ds_objects[section]) {
                                if (ds_objects[section][key] === name) {
                                    delete (ds_objects[section])[key];
                                }
                            }
                        } else {
                            if (ds_objects[section].hasOwnProperty(name)) {
                                delete (ds_objects[section])[name];
                            }
                        }
                    }
                });
            }

            vmDatasets().forEach(function (data) {
                expireObjects(data.dataset_objects);
            });

            if (self.vm_data_json.hasOwnProperty('dataset_objects')) {
                expireObjects(self.vm_data_json['dataset_objects']);
            }
        }

        function fetch(cb) {
            var opts = {log: self.log, dataset: name};
            getDatasets({}, opts, function (err, results) {
                if (err) {
                    self.log.warn('failed to fetch datasets');
                }
                cb(err, results);
            });
        }

        function copy(cache) {
            vmDatasets().forEach(function (data) {
                sections.forEach(function (section) {
                    for (var key in cache[section]) {
                        if (!data.hasOwnProperty('dataset_objects')) {
                            data.dataset_objects = {};
                        }
                        if (!data.dataset_objects.hasOwnProperty(section)) {
                            data.dataset_objects[section] = {};
                        }
                        data.dataset_objects[section][key]
                            = cache[section][key];
                    }
                });
            });
        }

        // we put all zfs events in the queue so that we can
        // pause the operations during a hard-refresh and replay
        // them on the both datasets.
        self.event_queue.enqueue({
            description: 'handle zfs event - ' + meta,
            func: function (extras, cb) {
                extras.log.debug('handling zfs event for ' + name);

                switch (obj.action) {
                case 'clone':
                case 'create':
                    fetch(function (err, cache) {
                        if (err) {
                            cb();
                            return;
                        } else {
                            copy(cache);
                        }
                    });
                    break;
                case 'set':
                    fetch(function (err, cache) {
                        if (err) {
                            cb();
                            return;
                        } else {
                            expire();
                            copy(cache);
                        }
                    });
                    break;
                case 'destroy':
                    expire();
                    break;
                default:
                    extras.log.fatal('unknown action: %s', obj.action);
                    break;
                }

                // remove the pending lock for this zpool
                delete (self.pending_zpools)[name];

                if (uuid !== 'global') {
                    // if we happen to grab an image uuid here,
                    // the refreshVmobj will return immediately
                    extras.log.debug('refreshing vmobj %s after zfs event',
                        uuid);
                    refreshVmobj(uuid, cb);
                } else {
                    cb();
                }
            }
        });
    }

    function createVmobj(zonename, callback) {
        async.each(vmDatasets(), function (vm_data, cb) {
            var opts = {
                log: self.log,
                keepalive: true,
                loadManually: true
            };
            vmload.getVmobj(zonename, opts, function (error, vmobj) {
                if (error) {
                    self.log.error('failed to load vmobj for ' + zonename
                        + ': ' + error.message);
                    cb();
                } else {
                    if (!self.vmobjs.hasOwnProperty(zonename)) {
                        self.vmobjs[zonename] = vmobj;
                        self.startVmWatchers(zonename, function (err) {
                            self.log.info('started watching ' + zonename);
                            self.emit('create', vmobj);
                            cb();
                        });
                    } else {
                        self.log.warn('vmobj already created for ' + zonename);
                        cb();
                    }
                }
            });
        }, callback);
    }

    function deleteVmobj(zonename, callback) {
        async.series([
            // unregister events
            function (cb) {
                self.stopVmWatchers(zonename, cb);
            },
            // delete vmobj
            function (cb) {
                delete (self.vmobjs)[zonename];
                cb();
            },
            // clean vm_data
            function (cb) {
                vmDatasets().forEach(function (data) {
                    for (var key in data) {
                        if (data[key].hasOwnProperty(zonename)) {
                            delete (data[key])[zonename];
                        }
                    }
                });
                cb();
            }
        ], function () {
            self.log.info('stopped watching ' + zonename);
            self.emit('delete', zonename);
            callback();
        });
    }

    /*
     * refreshVmobj() refreshes the cached vmobj and reports any changes
     *
     * Process:
     *     1) refresh the vm_data cache by calling vmload.getZoneData
     *     2) request a new vmobj by calling vmload.getVmobj
     *     3) analyze vmobj delta
     *     4) if different:
     *       4a) replace the vmobj with the new vmobj
     *       4b) log the delta
     *       4c) inform any subscribers of the delta
     */
    function refreshVmobj(zonename, vm_datasets, callback) {
        if (typeof (vm_datasets) === 'function') {
            callback = vm_datasets;
            cloneVmDatasets(zonename);
            vm_datasets = vmDatasets(zonename);
        }

        // short-circuit if this vmobj doesn't exist
        if (!self.vmobjs.hasOwnProperty(zonename)) {
            self.log.debug('cannot refresh vmobj, doesn\'t exist');
            resetVmDatasets(zonename);
            callback();
            return;
        }

        async.waterfall([
            // refresh vm_data cache
            function (cb) {
                self.log.debug('refreshing zoneData for ' + zonename);
                async.each(vm_datasets, function (vm_data, cb1) {
                    var opts = {log: self.log, cache: vm_data, keepalive: true};
                    vmload.getZoneData(zonename, opts, function (err, cache) {
                        // we don't care about cache here because we provided a
                        // cache object that was transformed by reference. So,
                        // cache in this case is just a reference to vm_data,
                        // which we already store globally. The idea here is
                        // that we just fill in the holes that we previously
                        // created.

                        if (err) {
                            self.log.error('unable to refresh vmobj for '
                                + zonename + ', failed to getZoneData');
                        }

                        cb1(err);
                    });
                }, cb);
            },
            // merge zone_vm_objs
            function (cb) {
                mergeZoneVmDatasets(zonename);
                cb();
            },
            // request a new vmobj
            function (cb) {
                self.log.debug('requesting new vmobj for ' + zonename);
                var opts = {
                    log: self.log,
                    keepalive: true,
                    loadManually: true
                };
                vmload.getVmobj(zonename, opts, function (err, vmobj) {
                    if (err) {
                        self.log.error({err: err},
                            'unable to refresh vmobj for %s, failed getVmobj',
                            zonename);

                        if (err.code === 'ENOENT'
                            && err.message.match(/No such zone configured$/)) {
                            self.log.debug({uuid: zonename},
                                'marking %s as deleted', zonename);
                            deleteVmobj(zonename, function (err2) {
                                if (err2) {
                                    self.log.error({uuid: zonename, err: err2},
                                        'error marking %s as deleted',
                                        zonename);
                                } else {
                                    self.log.debug({uuid: zonename},
                                        'successfully marked %s as deleted',
                                        zonename);
                                }
                                cb(err2 || err);
                            });
                            return;
                        }

                        cb(err);
                        return;
                    }

                    // pass the new vmobj down the stream
                    cb(null, vmobj);
                });
            },
            // analyze delta, update live copy
            function (vmobj, cb) {
                var changes = objDiff(self.vmobjs[zonename], vmobj);
                self.vmobjs[zonename] = vmobj;
                cb(null, vmobj, changes);
            },
            // publish changes
            function (vmobj, changes, cb) {
                if (changes.length > 0) {
                    delete (self.vmobjs_json[zonename]);
                    self.emit('modify', vmobj, changes);
                }
                cb();
            }
        ], callback);
    }

    /*
     * startWatchers() starts global watchers
     *
     * Arguments:
     *   'callback' - will be called with (err)
     *
     * This function will:
     *   1) Create a FsWatcher object
     *   2) Watch for changes to /tmp/.sysinfo.json
     *   3) Create a ZoneWatcher
     *   4) Create a ZpoolWatcher
     */
    self.startWatchers = function (callback) {
        async.series([
            function (cb) {
                self.fsw = new FsWatcher({log: self.log});

                self.fsw.on('all', function (obj) {
                    handleFsEvent(obj);
                });
                self.fsw.once('ready', function (obj) {
                    self.log.debug('filesystem watcher ready');
                    cb();
                });

                self.fsw.start();
            }, function (cb) {
                self.fsw.watch('/tmp/.sysinfo.json', cb);
            }, function (cb) {
                self.zonew = new ZoneWatcher({log: self.log});

                self.zonew.on('all', function (obj) {
                    handleZoneEvent(obj);
                });

                // ZoneWatcher starts when it is created
                process.nextTick(cb);
            }, function (cb) {
                self.zpoolw = new ZpoolWatcher({log: self.log});

                self.zpoolw.on('all', function (obj) {
                    handleZpoolEvent(obj);
                });

                // ZoneWatcher starts when it is created
                process.nextTick(cb);
            }
        ], function () {
            self.log.info('global watchers ready');
            callback();
        });
    };

    /*
     * startVmWatchers() starts the watchers for a VM
     *
     * Arguments:
     *   'zonename' - a specific vm zonename to start watchers on
     *   'callback' - will be called with (err)
     *
     *   'zonename' argument is optional, and when omitted will start watchers
     *   for all vms.
     */
    self.startVmWatchers = function (zonename, callback) {
        if (arguments.length === 1) {
            callback = zonename;
            zonename = undefined;
        }

        if (zonename === undefined) {
            async.waterfall([
                // load zone records
                function (cb) {
                    getZoneRecords(null, {log: self.log},
                        function (err, records) {

                        if (err) {
                            self.log.debug('failed to load zone records: '
                                + err.message);
                        }
                        cb(err, records);
                    });
                },
                // start watchers
                function (records, cb) {
                    for (var uuid in records) {
                        addVMFsWatches(records[uuid].zonename);
                    }
                    cb();
                }
            ], function (err) {
                if (err) {
                    self.log.error('failed to start vm watchers');
                }
                callback(err);
            });
        } else {
            addVMFsWatches(zonename);
            callback();
        }
    };

    /*
     * stopVmWatchers() stops the watchers for a VM
     *
     * Arguments:
     *   'zonename' - a specific vm zonename to stop watchers on
     *   'callback' - will be called with (err)
     *
     *   'zonename' argument is optional, and when omitted will stop watchers
     *   for all vms.
     */
    self.stopVmWatchers = function (zonename, callback) {
        var name;

        if (arguments.length === 1) {
            callback = zonename;
            zonename = undefined;
        }

        if (zonename === undefined) {
            for (name in self.vmobjs) {
                removeVMFsWatches(zonename);
            }
        } else {
            removeVMFsWatches(zonename);
        }

        callback();
    };

    /*
     * addVMFsWatches() creates filesystem watchers for a given vm
     *
     * Arguments:
     *   'zonename' - a zonename for a vm to use in the watcher path
     *
     * This function will:
     *   1) Create a watcher for /etc/zones/<zonename>.xml
     *   2) Create watchers for config files in:
     *     /zones/<zonename>/config/CONFIG.json
     *
     */
    function addVMFsWatches(zonename) {
        self.log.trace('adding vm fs watchers for ' + zonename);

        function watch(pathname) {
            self.fsw.watch(pathname, function (err) {
                if (err) {
                    self.log.error(err, 'failed to setup watch');
                    throw err;
                } else {
                    self.log.debug('now watching ' + pathname);
                }
            });
        }

        watch('/etc/zones/' + zonename + '.xml');

        CONFIG_FILES.forEach(function (f) {
            watch('/zones/' + zonename + '/config/' + f);
        });

        watch('/zones/' + zonename + '/lastexited');
    }

    /*
     * removeVMFsWatches() removes filesystem watchers for a given vm
     *
     * Arguments:
     *   'zonename' - a zonename for a vm to use in the watcher path
     *
     * This function will:
     *   1) Remove the watcher for /etc/zones/<zonename>.xml
     *   2) Remove watchers for config files in:
     *     /zones/<zonename>/config/CONFIG.json
     *
     */
    function removeVMFsWatches(zonename) {
        self.log.trace('removing vm fs watchers for ' + zonename);

        function unwatch(pathname) {
            self.fsw.unwatch(pathname, function (err) {
                if (err) {
                    self.log.error(err, 'failed to remove watch');
                    throw err;
                } else {
                    self.log.debug('no longer watching ' + pathname);
                }
            });
        }

        unwatch('/etc/zones/' + zonename + '.xml');

        CONFIG_FILES.forEach(function (f) {
            unwatch('/zones/' + zonename + '/config/' + f);
        });

        unwatch('/zones/' + zonename + '/lastexited');
    }

    /*
     * setVmData() sets the initial vm_data
     *
     * Arguments:
     *   'callback' - will be called with (err)
     *
     * This function will request a cache object from loadVmData and set vm_data
     *
     */
    self.setVmData = function (callback) {
        loadVmData(function (err, cache) {
            if (err) {
                self.log.error('failed to set initial vm_data');
            } else {
                self.log.debug('setting initial vm_data: ' + cache);
                self.vm_data = cache;
            }
            callback(err);
        });
    };

    /*
     * loadVmData() loads a cache object from vmload.getZoneData
     *
     * Arguments:
     *   'callback' - will be called with (err, cache)
     *
     * This function will load a cache object from vmload.getZoneData
     * passing a nocache: true flag to ensure the cache object is generated
     * from raw data.
     *
     */
    function loadVmData(callback) {
        var opts = {log: self.log, nocache: true, keepalive: true};
        vmload.getZoneData(null, opts, function (err, cache) {
            if (err) {
                self.log.debug('failed vmload.getZoneData: ' + err.message);
            }
            callback(err, cache);
        });
    }

    /*
     * setVmobjs() sets the initial vmobjs data
     *
     * Arguments:
     *   'callback' - will be called with (err)
     *
     * This function will request vmobjs from vmload.getVmobjs, using the cache
     * object set in vm_cache. The result will then be converted from an array
     * into a hash where the key is the vm uuid and the value is the vmobj.
     *
     */
    self.setVmobjs = function (callback) {
        var opts = {
            cache: self.vm_data,
            log: self.log,
            keepalive: true,
            loadManually: true
        };
        vmload.getVmobjs(function (_, cb) {
            cb(true);
        }, opts, function (err, results) {
            if (err) {
                self.log.debug('failed vmload.getVmobjs: ' + err.message);
                self.log.error('failed to set vmobjs');
            } else {
                self.vmobjs = {};

                results.forEach(function (vmobj) {
                    self.vmobjs[vmobj.zonename] = vmobj;
                });
            }
            callback(err);
        });
    };

    /*
     * This function exists as a way to deflect overbearing amounts of
     * JSON.serialize on a large data set. Since vmload will request the cached
     * data directly from this module, it has been observed that over 90% of
     * the cpu time can be spent serializing JSON. To correct this, this
     * function will construct a JSON structure from many pre-serialized data
     * structures.
     *
     * The focus here is speed and minimal transport size, so we will not worry
     * about pretty-printing.
     */
    function serializeData(zonename) {
        var sections;
        var json = '{';

        // iterate over each item in data and create a pseudo node
        sections = Object.keys(self.vm_data);
        sections.forEach(function (section, index) {
            json += '"' + section + '":';

            if (section === 'sysinfo') {
                json += serializeDataSysinfo();
            } else if (section === 'dataset_objects') {
                json += serializeDataDatasets(zonename);
            } else {
                json += serializeDataSection(section, zonename);
            }

            if (index < sections.length -1) {
                json += ',';
            }
        });

        json += '}';

        return (json);
    }

    /*
     * The following serializeData* functions will generate a serialized copy of
     * the respective data if a cache doesn't already exist, and cache the
     * results for the next run.
     */

    function serializeDataSysinfo() {
        if (!self.vm_data_json.hasOwnProperty('sysinfo')) {
            self.vm_data_json['sysinfo'] =
                JSON.stringify(self.vm_data['sysinfo']);
        }
        return (self.vm_data_json['sysinfo']);
    }

    function serializeDataDatasets(zonename) {
        var json = '{';
        var sections;
        var keys;

        if (!self.vm_data_json.hasOwnProperty('dataset_objects')) {
            self.vm_data_json['dataset_objects'] = {};
        }

        sections = Object.keys(self.vm_data['dataset_objects']);
        sections.forEach(function (section, index) {
            if (!self.vm_data_json['dataset_objects'].hasOwnProperty(section)) {
                self.vm_data_json['dataset_objects'][section] = {};
            }

            json += '"' + section + '":{';

            keys = Object.keys(self.vm_data['dataset_objects'][section]);
            keys.forEach(function (key, index1) {
                if (!self.vm_data_json['dataset_objects'][section]
                    .hasOwnProperty(key)) {

                    self.vm_data_json['dataset_objects'][section][key] =
                        JSON.stringify(
                            self.vm_data['dataset_objects'][section][key]);
                }

                json += '"' + key + '":';
                json += self.vm_data_json['dataset_objects'][section][key];

                if (index1 < keys.length - 1) {
                    json += ',';
                }
            });

            json += '}';

            if (index < sections.length - 1) {
                json += ',';
            }
        });

        json += '}';

        return (json);
    }

    function serializeDataSection(section, zonename) {
        var json = '';
        var zones;

        function serializeZone(zone) {
            if (!self.vm_data_json[section].hasOwnProperty(zone)) {
                if (!self.vm_data_json.hasOwnProperty(section)) {
                    self.vm_data_json[section] = {};
                }

                self.vm_data_json[section][zone] =
                    JSON.stringify(self.vm_data[section][zone]);
            }

            return (self.vm_data_json[section][zone]);
        }

        if (!self.vm_data_json.hasOwnProperty(section)) {
            self.vm_data_json[section] = {};
        }

        json += '{';

        if (zonename) {
            json += '"' + zonename + '":';
            json += serializeZone(zonename);
        } else {
            // iterate over each uuid
            zones = Object.keys(self.vm_data[section]);
            zones.forEach(function (zone, index) {
                json += '"' + zone + '":';
                json += serializeZone(zone);

                if (index < zones.length - 1) {
                    json += ',';
                }
            });
        }
        json += '}';

        return (json);
    }

    function serializeVms() {
        var zones;
        var json = '[';

        zones = Object.keys(self.vmobjs);
        zones.forEach(function (zone, index) {
            json += serializeVm(zone);

            if (index < zones.length - 1) {
                json += ',';
            }
        });

        json += ']';

        return (json);
    }

    function serializeVm(zonename) {
        if (!self.vmobjs_json.hasOwnProperty(zonename)) {
            self.vmobjs_json[zonename] = JSON.stringify(self.vmobjs[zonename]);
        }

        return (self.vmobjs_json[zonename]);
    }

    function handleGet(c, args, response) {
        var res;
        switch (c[0]) {
        case 'ping':
            res = {
                ping: 'pong'
            };
            response.writeHead(200, { 'Content-Type': 'application/json'});
            response.end(JSON.stringify(res, null, 2) + '\n', 'utf-8');
            break;
        case 'status':
            res = {
                pid: process.pid,
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                state: self.state,
                status: self.status,
                queue: self.event_queue.dump(),
                fswatcher: self.fsw.dump()
            };
            response.writeHead(200, { 'Content-Type': 'application/json'});
            response.end(JSON.stringify(res, null, 2) + '\n', 'utf-8');
            break;
        case 'data':
            // return the vm_data object
            response.writeHead(200, { 'Content-Type': 'application/json'});
            response.end(serializeData(), 'utf-8');
            break;
        case 'vms':
            if (c.length === 2) {
                // requesting a vmobj with zonename
                var zonename = c[1];

                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    response.writeHead(404,
                        { 'Content-Type': 'application/json'});
                    response.write('Unable to load VM ' + zonename);
                    response.end();
                } else {
                    response.writeHead(200,
                        { 'Content-Type': 'application/json'});
                    response.end(serializeVm(zonename), 'utf-8');
                }
            } else {
                // requesting the vmobj list
                response.writeHead(200, { 'Content-Type': 'application/json'});
                response.end(serializeVms(), 'utf-8');
            }
            break;
        case 'events':
            response.writeHead(200, { 'Content-Type': 'application/json'});

            var on_create = function (json) {
                response.write(json + '\n');
            };
            var on_modify = function (json) {
                response.write(json + '\n');
            };
            var on_delete = function (json) {
                response.write(json + '\n');
            };
            var on_close = function () {
                response.end();
                cleanup();
            };

            function cleanup() {
                self.removeListener('create-json', on_create);
                self.removeListener('modify-json', on_modify);
                self.removeListener('delete-json', on_delete);
                self.removeListener('close', on_close);
            }

            self.on('create-json', on_create);
            self.on('modify-json', on_modify);
            self.on('delete-json', on_delete);
            self.on('close', on_close);

            response.on('close', cleanup);

            // let the client know it is subscribed
            response.write(JSON.stringify({
                type: 'ack',
                ts: new Date()
            }) + '\n');
            // let this client stay open forever
            response.connection.setTimeout(0);
            break;
        default:
            response.writeHead(404, { 'Content-Type': 'application/json'});
            response.write('Unsupported URL Path');
            response.end();
            break;
        }
    }

    self.startHTTPHandler = function (callback) {
        var ip;
        var ips = ['127.0.0.1'];

        var handler = function (request, response) {
            var args;
            var c;
            var url_parts;

            url_parts = url.parse(request.url, true);
            c = path.normalize(url_parts.pathname).split('/');
            c.shift();

            args = url_parts.query || {};
            self.log.info({req: request}, 'HTTP request');

            if (request.method !== 'GET') {
                // Bad request
                response.writeHead(400,
                    {'Content-Type': 'application/json'});
                response.end();
            } else {
                handleGet(c, args, response);
            }
        };

        for (ip in ips) {
            ip = ips[ip];
            self.log.debug('LISTENING ON ' + ip + ':' + self.port);
            http.createServer(handler).listen(self.port, ip);
        }

        callback();
    };

    /*
     * reset() hard reset the data to ensure integrity
     *
     * This function will:
     *   1- pause the event queue
     *   2- fetch new vm_data
     *   3- fast-forward the event queue
     *   4- compare datasets
     *   5- replace vm_data with vm_data_tmp if the sets are different
     *   6- refresh vmobjs if the sets are different
     *   7- resume the event queue
     */
    function reset(callback) {
        async.series([
            // pause the queue
            function (cb) {
                self.setState('paused');
                self.setStatus('pausing the event queue');
                self.event_queue.pause({timeout: 60 * 1000}, function (err) {
                    if (err) {
                        self.log.warn('failed to pause the queue: %s',
                            err.message);
                    }

                    cb(err);
                });
            },
            // fetch new data
            function (cb) {
                self.setStatus('fetching vm cache data');
                loadVmData(function (err, results) {
                    if (err) {
                        self.log.error('failed to fetch new vm_data');
                    } else {
                        self.vm_data_tmp = results;
                    }
                    cb(err);
                });
            },
            // fast-forward the queue
            function (cb) {
                var now = new Date();
                self.setStatus('fast-forwarding the queue to %s', now);
                self.event_queue.fastForward(now, {timeout: 10000},
                    function (err) {

                    if (err) {
                        self.log.warn('failed to fast-forward queue: '
                            + err.message);
                    }

                    cb(err);
                });
            },
            // compare/update vmobjs
            function (cb) {
                self.setStatus('comparing vmobj sets');
                var changes = objDiff(self.vm_data, self.vm_data_tmp);
                var old_vm_data;

                if (changes.length === 0) {
                    self.log.info('vmobj sets are in sync');
                    cb();
                    return;
                }

                self.log.warn('vm_data and vm_data_tmp are not the same: '
                    + JSON.stringify(changes));

                self.setStatus('syncronizing data');

                // keep a temporary reference to compare against
                old_vm_data = self.vm_data;

                // replace the data with new
                self.vm_data = self.vm_data_tmp;

                async.series([
                    // create vmobjs we don't know about
                    function (cb1) {
                        var new_objs = self.vm_data.zoneadm_objects;
                        var keys = Object.keys(new_objs);
                        async.each(keys, function (zonename, cb2) {
                            var old_objs = old_vm_data.zoneadm_objects;
                            if (!old_objs.hasOwnProperty(zonename)) {
                                createVmobj(zonename, cb2);
                            } else {
                                cb2();
                            }
                        }, cb1);
                    },
                    // delete vmobjs we shouldn't know about
                    function (cb1) {
                        var old_objs = old_vm_data.zoneadm_objects;
                        var keys = Object.keys(old_objs);
                        async.each(keys, function (zonename, cb2) {
                            var new_objs = self.vm_data.zoneadm_objects;
                            if (!new_objs.hasOwnProperty(zonename)) {
                                deleteVmobj(zonename, cb2);
                            } else {
                                cb2();
                            }
                        }, cb1);
                    },
                    // refresh the rest
                    function (cb1) {
                        async.each(Object.keys(self.vmobjs), refreshVmobj, cb1);
                    }
                ], cb);
            }
        ], function (err) {
            // regardless of an error, always resume the queue to
            // ensure we don't deadlock SmartOS
            self.setState('running');
            self.setStatus('working');
            self.log.info('resuming the event queue');
            self.vm_data_tmp = undefined;
            self.event_queue.resume();
            callback(err);
        });
    }

    self.startTimers = function (callback) {
        setTimeout(function () {
            self.log.info('preparing to refresh data');
            reset(function (err) {
                if (err) {
                    self.log.error('failed to refresh data');
                }
                self.startTimers();
            });
        }, self.refresh_interval);

        if (callback) {
            callback();
        }
    };

    /*
     * We need to create intermediate event listeners between self and
     * clients subscribed to events so that we only have to JSON.stringify
     * once per event instead of once per client per event.
     */

    self.on('create', function (vmobj) {
        var data;
        var json;

        data = {
            type: 'create',
            ts: new Date(),
            zonename: vmobj.zonename,
            vm: vmobj
        };

        self.log.info({ev: data}, 'emitting "create" event');

        json = JSON.stringify(data);

        self.emit('create-json', json);
    });

    self.on('modify', function (vmobj, changes) {
        var data;
        var json;

        data = {
            type: 'modify',
            ts: new Date(),
            zonename: vmobj.zonename,
            vm: vmobj,
            changes: changes
        };

        self.log.info({ev: data}, 'emitting "modify" event');

        json = JSON.stringify(data);

        self.emit('modify-json', json);
    });

    self.on('delete', function (name) {
        var data;
        var json;

        data = {
            type: 'delete',
            ts: new Date(),
            zonename: name
        };

        self.log.info({ev: data}, 'emitting "delete" event');

        json = JSON.stringify(data);

        self.emit('delete-json', json);
    });
};

util.inherits(VMInfo, EventEmitter);

VMInfo.prototype.setState = function (/* args */) {
    var self = this;

    var state = util.format.apply(this, arguments);

    self.log.debug({
        oldstate: self.state,
        newstate: state
    }, 'state changed from "%s" to "%s"', self.state, state);

    self.state = state;
};

VMInfo.prototype.setStatus = function (/* args */) {
    var self = this;

    var status = util.format.apply(this, arguments);

    self.log.debug({
        oldstatus: self.status,
        newstatus: status
    }, 'status changed from "%s" to "%s"', self.status, status);

    self.status = status;
};

VMInfo.prototype.start = function (callback) {
    var self = this;

    self.log.info('vminfo starting');

    async.series([
        // update state
        function (cb) {
            self.setState('booting');
            cb();
        },
        // init queue
        function (cb) {
            self.setStatus('initializing event queue');
            var opts = {
                workers: 1,
                paused: true,
                log: self.log
            };
            self.event_queue = new Queue(opts);
            cb();
        },
        // start global watchers
        function (cb) {
            self.setStatus('starting global watchers');
            self.startWatchers(cb);
        },
        // start vm watchers
        function (cb) {
            self.setStatus('starting vm watchers');
            self.startVmWatchers(cb);
        },
        // set vm_data
        function (cb) {
            self.setStatus('setting initial cache data');
            self.setVmData(cb);
        },
        // set vmobjs data
        function (cb) {
            self.setStatus('setting initial vmobjs data');
            self.setVmobjs(cb);
        },
        // resume queue
        function (cb) {
            self.setStatus('resuming the event queue');
            self.event_queue.resume();
            cb();
        },
        // start http server
        function (cb) {
            self.setStatus('starting http server');
            self.startHTTPHandler(cb);
        },
        // start refresh timers
        function (cb) {
            self.setStatus('starting refresh timers');
            self.startTimers(cb);
        }
    ], function (err) {
        if (err) {
            self.log.error('failed to complete boot sequence');
            throw err;
        } else {
            self.setState('running');
            self.setStatus('working');
            self.log.info('boot sequence complete');
            self.emit('ready', self.vmobjs);
        }

        if (callback) {
            callback();
        }
    });
};

VMInfo.prototype.stop = function (callback) {
    var self = this;

    self.fsw.shutdown();
    self.zonew.shutdown();
    self.zpoolw.shutdown();

    self.emit('end');

    if (callback) {
        callback();
    }
};
