#!/usr/bin/node
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 *
 *
 * Exported functions:
 *
 * console(uuid, callback)
 * create(properties, callback)
 * delete(uuid, callback)
 * flatten(vmobj, key)
 * info(uuid, types, callback)
 * load([zonename|uuid], callback)
 * lookup(match, callback)
 * reboot(uuid, options={[force=true]}, callback)
 * start(uuid, extra, callback)
 * stop(uuid, options={[force=true]}, callback)
 * sysrq(uuid, req=[nmi|screenshot], options={}, callback)
 * update(uuid, properties, callback)
 *
 * Exported variables:
 *
 * logger - a function which takes (priority, message, <Error Obj>)
 * INFO_TYPES - list of supported types for the info command
 * SYSRQ_TYPES - list of supported requests for sysrq
 */


var async = require('async');
var cp = require('child_process');
var execFile = cp.execFile;
var expat = require('node-expat');
var fs = require('fs');
var http = require('http');
var net = require('net');
var path = require('path');
var sl = require('syslog');
var spawn = cp.spawn;
var sprintf = require('sprintf').sprintf;
var system = require('system');
var util = require('util');

// The numbers match the syslog levels + TRACE which I added.
var LOG_LEVELS = {
    'EMERG': 0,  // Emergency: system is unusable
    'ALERT': 1,  // Alert: action must be taken immediately
    'CRIT': 2,   // Critical: critical conditions
    'ERROR': 3,  // Error: error conditions
    'WARN': 4,   // Warning: warning conditions
    'NOTICE': 5, // Notice: normal but significant condition
    'INFO': 6,   // Informational: informational messages
    'DEBUG': 7,  // Debug: debug-level messages
    'TRACE': 8   // Trace: log everything we know how
};

var LOG_TO_SYSLOG = {
    'EMERG': sl.LOG_EMERG,
    'ALERT': sl.LOG_ALERT,
    'CRIT': sl.LOG_CRIT,
    'ERROR': sl.LOG_ERR,
    'WARN': sl.LOG_WARNING,
    'NOTICE': sl.LOG_NOTICE,
    'INFO': sl.LOG_INFO,
    'DEBUG': sl.LOG_DEBUG,
    'TRACE': sl.LOG_DEBUG
};

var VMADMD_SOCK = '/tmp/vmadmd.http';
var syslog_is_open = false;

/*
 * zone states from libzonecfg/common/zonecfg_impl.h
 *
 * #define ZONE_STATE_STR_CONFIGURED       "configured"
 * #define ZONE_STATE_STR_INCOMPLETE       "incomplete"
 * #define ZONE_STATE_STR_INSTALLED        "installed"
 * #define ZONE_STATE_STR_READY            "ready"
 * #define ZONE_STATE_STR_MOUNTED          "mounted"
 * #define ZONE_STATE_STR_RUNNING          "running"
 * #define ZONE_STATE_STR_SHUTTING_DOWN    "shutting_down"
 * #define ZONE_STATE_STR_DOWN             "down"
 *
 */

exports.logger = null;
exports.loglevel = 'INFO';
exports.FLATTENABLE_ARRAY_HASH_KEYS = [
    'disks',
    'nics'
];
exports.FLATTENABLE_HASH_KEYS = [
    'customer_metadata',
    'internal_metadata',
    'tags'
];

var VM = this;
var syslog_action = null;

// Note: This is not intended to be used directly by callers other than vmadmd
// or other system tools. Other callers should set VM.logger with their own
// function that takes the same args, and that will also get the logs.
exports.log = function (priority, message, err)
{
    var line;
    var lines;
    var now = new Date;

    if (syslog_action) {
        now = now.getSeconds() + '.' + now.getMilliseconds();
        if (!syslog_is_open) {
            sl.openlog(syslog_action, sl.LOG_PID, sl.LOG_LOCAL0);
            syslog_is_open = true;
        }

        lines = message.split('\n');
        if (err) {
            lines.concat(err.stack.split('\n'));
        }
        for (line in lines) {
            line = rtrim(lines[line]);
            if (line.length > 0) {
                sl.syslog(LOG_TO_SYSLOG[priority], now + ' ' + line);
            }
        }
    }

    // caller of this library is allowed to set this.
    if (VM.logger) {
        try {
            VM.logger(priority, message, err);
        } catch (e) {
            // do nothing!
        }
    }
};

// Note: only vmadmd should set this outside this file.
exports.resetLog = function (action)
{
    if (syslog_is_open) {
        sl.closelog();
        syslog_is_open = false;
    }
    syslog_action = action;
};

function ltrim(str, chars)
{
    chars = chars || '\\s';
    str = str || '';
    return str.replace(new RegExp('^[' + chars + ']+', 'g'), '');
}

function rtrim(str, chars)
{
    chars = chars || '\\s';
    str = str || '';
    return str.replace(new RegExp('[' + chars + ']+$', 'g'), '');
}

function trim(str, chars)
{
    return ltrim(rtrim(str, chars), chars);
}

function isUUID(str) {
    var re = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    if (str.length === 36 && str.match(re)) {
        return true;
    } else {
        return false;
    }
}

function fixBoolean(str)
{
    if (str === 'true') {
        return true;
    } else if (str === 'false') {
        return false;
    } else {
        return str;
    }
}

function fixBooleanLoose(str)
{
    if (str === 'true' || str === '1') {
        return true;
    } else if (str === 'false' || str === '0') {
        return false;
    } else {
        return str;
    }
}

// IMPORTANT:
//
//  Some of these properties get translated below into backward compatible
//  names.
//

var UPDATABLE_NIC_PROPS = [
    'primary',
    'nic_tag',
    'blocked_outgoing_ports',
    'mac',
    'gateway',
    'ip',
    'model',
    'netmask',
    'dhcp_server',
    'vlan_id'
];

var DISK_PROPS = [
    'model',
    'boot',
    'match',
    'zpool',
    'media',
    'image-uuid',
    'image-name',
    'image-size',
    'size'
];

var UPDATABLE_DISK_PROPS = [
    'boot',
    'model'
];

// Note: this doesn't include 'state' because of 'stopping' which is a virtual
// state and therefore lookups would be wrong (because they'd search on real
// state).
var QUICK_LOOKUP = [
    'zoneid',
    'zonename',
    'zonepath',
    'uuid',
    'brand',
    'ip_type'
];

exports.DISK_MODELS = [
    'virtio',
    'ide',
    'scsi'
];

exports.VGA_TYPES = [
    'cirrus',
    'std',
    'vmware',
    'qxl',
    'xenfb'
];

exports.INFO_TYPES = [
    'all',
    'version',
    'chardev',
    'block',
    'blockstats',
    'cpus',
    'pci',
    'kvm',
    'vnc'
];

exports.SYSRQ_TYPES = [
    'nmi',
    'screenshot'
];

exports.KVM_MEM_OVERHEAD = 1024;
exports.KVM_MIN_MEM_OVERHEAD = 256;

var XML_PROPERTIES = {
    'zone': {
        'name': 'zonename',
        'zonepath': 'zonepath',
        'autoboot': 'autoboot',
        'brand': 'brand',
        'limitpriv': 'limit_priv',
        'fs-allowed': 'fs_allowed'
    },
    'zone.attr': {
        'boot': 'boot',
        'create-timestamp': 'create_timestamp',
        'dataset-uuid': 'dataset_uuid',
        'do-not-inventory': 'do_not_inventory',
        'billing-id': 'billing_id',
        'owner-uuid': 'owner_uuid',
        'package-name': 'package_name',
        'package-version': 'package_version',
        'cpu-type': 'cpu_type',
        'tmpfs': 'tmpfs',
        'dns-domain': 'dns_domain',
        'hostname': 'hostname',
        'alias': 'alias',
        'vm-autoboot': 'vm_autoboot',
        'ram': 'ram',
        'transition': 'transition',
        'never-booted': 'never_booted',
        'vga': 'vga',
        'vnc-password': 'vnc_password',
        'vnc-port': 'vnc_port',
        'qemu-opts': 'qemu_opts',
        'qemu-extra-opts': 'qemu_extra_opts',
        'resolvers': 'resolvers',
        'vcpus': 'vcpus'
    },
    'zone.rctl.zone.cpu-shares.rctl-value': {
        'limit': 'cpu_shares'
    },
    'zone.rctl.zone.cpu-cap.rctl-value': {
        'limit': 'cpu_cap'
    },
    'zone.rctl.zone.zfs-io-priority.rctl-value': {
        'limit': 'zfs_io_priority'
    },
    'zone.rctl.zone.max-lwps.rctl-value': {
        'limit': 'max_lwps'
    },
    'zone.rctl.zone.max-physical-memory.rctl-value': {
        'limit': 'max_physical_memory'
    },
    'zone.rctl.zone.max-locked-memory.rctl-value': {
        'limit': 'max_locked_memory'
    },
    'zone.rctl.zone.max-swap.rctl-value': {
        'limit': 'max_swap'
    },
    'nic': {
        'ip': 'ip',
        'mac-addr': 'mac',
        'physical': 'interface',
        'vlan-id': 'vlan_id',
        'global-nic': 'nic_tag',
        'dhcp_server': 'dhcp_server',
        'netmask': 'netmask',
        'model': 'model',
        'gateway': 'gateway',
        'primary': 'primary',
        'blocked-outgoing-ports': 'blocked_outgoing_ports'
    },
    'filesystem': {
        'special': 'source',
        'directory': 'target',
        'type': 'type',
        'raw': 'raw'
    },
    'disk': {
        'match': 'path',
        'model': 'model',
        'boot': 'boot',
        'image-size': 'image_size',
        'image-uuid': 'image_uuid',
        'image-name': 'image_name',
        'size': 'size'
    }
};

var XML_PROPERTY_TRANSFORMS = {
    'alias': unbase64,
    'vnc_password': unbase64,
    'vnc_port': numberify,
    'qemu_opts': unbase64,
    'qemu_extra_opts': unbase64,
    'autoboot': fixBoolean,
    'do_not_inventory': fixBoolean,
    'never_booted': fixBoolean,
    'zoneid': numberify,
    'cpu_shares': numberify,
    'cpu_cap': numberify,
    'zfs_io_priority': numberify,
    'max_lwps': numberify,
    'max_physical_memory': unmangleMem,
    'max_locked_memory': unmangleMem,
    'max_swap': unmangleMem,
    'ram': numberify,
    'resolvers': separateCommas,
    'vcpus': numberify,
    'tmpfs': numberify,
    'nics': {
        'vlan_id': numberify,
        'primary': fixBooleanLoose,
        'dhcp_server': fixBoolean
    },
    'disks': {
        'boot': fixBoolean,
        'size': numberify,
        'image_size': numberify
    }
};

function separateCommas(str)
{
    return str.split(',');
}

function unmangleMem(str)
{
    return (Number(str) / (1024 * 1024));
}

function unbase64(str)
{
    return new Buffer(str, 'base64').toString('ascii');
}

function numberify(str)
{
    return Number(str);
}

function startElement(name, attrs, state) {
    var disk = {};
    var key;
    var newobj;
    var nic = {};
    var obj;
    var prop;
    var stack;
    var use;
    var where;

    if (!state.hasOwnProperty('stack')) {
        state.stack = [];
    }
    obj = state.obj;
    stack = state.stack;

    stack.push(name);
    where = stack.join('.');

    if (XML_PROPERTIES.hasOwnProperty(where)) {
        for (key in XML_PROPERTIES[where]) {
            use = XML_PROPERTIES[where][key];
            if (attrs.hasOwnProperty(key)) {
                obj[use] = attrs[key];
            } else if (attrs.hasOwnProperty('name') && attrs.name === key) {
                // attrs use the whacky {name, type, value} stuff.
                obj[use] = attrs['value'];
            }
        }
    } else if (where === 'zone.rctl') {
        stack.push(attrs.name);
    } else if (where === 'zone.network') {
        // new network device
        for (prop in attrs) {
            if (XML_PROPERTIES.nic.hasOwnProperty(prop)) {
                use = XML_PROPERTIES.nic[prop];
                if (prop === 'mac-addr') {
                    // XXX SmartOS inherited the ridiculous MAC formatting from
                    //     Solaris where leading zeros are removed.  Fix that.
                    nic[use] = fixMac(attrs[prop]);
                } else {
                    nic[use] = attrs[prop];
                }
            } else {
                VM.log('DEBUG', 'unknown net prop: ' + prop);
            }
        }
        if (!obj.hasOwnProperty('networks')) {
            obj.networks = {};
        }
        obj.networks[nic.mac] = nic;
        stack.push(nic.mac);
    } else if (where.match(/zone\.network\...:..:..:..:..:..\.net-attr/)) {
        if (XML_PROPERTIES.nic.hasOwnProperty(attrs.name)) {
            use = XML_PROPERTIES.nic[attrs.name];
            obj.networks[stack[2]][use] = attrs.value;
        } else {
            VM.log('DEBUG', 'unknown net prop: ' + attrs.name);
        }
    } else if (where === 'zone.device') {
        // new disk device
        for (prop in attrs) {
            if (XML_PROPERTIES.disk.hasOwnProperty(prop)) {
                use = XML_PROPERTIES.disk[prop];
                disk[use] = attrs[prop];
            } else {
                VM.log('DEBUG', 'unknown disk prop: ' + prop);
            }
        }
        if (!obj.hasOwnProperty('devices')) {
            obj.devices = {};
        }
        obj.devices[disk.path] = disk;
        stack.push(disk.path);
    } else if (where.match(/zone\.device\.\/dev\/.*disk[0-9]+\.net-attr/)) {
        if (XML_PROPERTIES.disk.hasOwnProperty(attrs.name)) {
            use = XML_PROPERTIES.disk[attrs.name];
            obj.devices[stack[2]][use] = attrs.value;
        } else {
            VM.log('DEBUG', 'unknown disk prop: ' + attrs.name);
        }
    } else if (where === 'zone.dataset') {
        if (!obj.hasOwnProperty('datasets')) {
            obj.datasets = [];
        }
        if (attrs.hasOwnProperty('name')) {
            obj.datasets.push(attrs.name);
        }
    } else if (where === 'zone.filesystem') {
        if (!obj.hasOwnProperty('filesystems')) {
            obj.filesystems = [];
        }
        newobj = {};
        for (prop in XML_PROPERTIES.filesystem) {
            if (attrs.hasOwnProperty(prop)) {
                newobj[XML_PROPERTIES.filesystem[prop]] = attrs[prop];
            }
        }
        obj.filesystems.push(newobj);
    } else if (where === 'zone.filesystem.fsoption') {
        newobj = obj.filesystems.slice(-1)[0];  // the last element
        if (!newobj.hasOwnProperty('options')) {
            newobj.options = [];
        }
        newobj.options.push(attrs.name);
    } else {
        VM.log('DEBUG', 'unknown property: ' + where + ': '
            + JSON.stringify(attrs));
    }
}

function endElement(name, state) {
    // trim stack back above this element
    var stack = state.stack;

    while (stack.pop() !== name) {
        // do nothing, we just want to consume.
        continue;
    }
}

function indexSort(obj, field, pattern)
{
    obj.sort(function (a, b) {
        var avalue = 0;
        var bvalue = 0;
        var matches;

        if (a.hasOwnProperty(field)) {
            matches = a[field].match(pattern);
            if (matches) {
                avalue = Number(matches[1]);
            }
        }
        if (b.hasOwnProperty(field)) {
            matches = b[field].match(pattern);
            if (matches) {
                bvalue = Number(matches[1]);
            }
        }

        return avalue - bvalue;
    });
}

function applyTransforms(obj)
{
    var p;
    var pp;
    var subobj;
    var transforms = XML_PROPERTY_TRANSFORMS;

    for (p in transforms) {
        if (obj.hasOwnProperty(p)) {
            if (typeof (transforms[p]) === 'object') {
                // this is a 'complex' property like nic, and has different
                // transforms for the sub-objects
                for (pp in transforms[p]) {
                    for (subobj in obj[p]) {
                        if (obj[p][subobj].hasOwnProperty(pp)) {
                            obj[p][subobj][pp] =
                                transforms[p][pp](obj[p][subobj][pp]);
                        }
                    }
                }
            } else { // function
                obj[p] = transforms[p](obj[p]);
            }
        }
    }
}

function getVmobj(zonename, preload_data, callback)
{
    var filename = '/etc/zones/' + zonename + '.xml';
    var parser = new expat.Parser('UTF-8');

    fs.readFile(filename, function (error, data) {
        var disk;
        var fields;
        var nic;
        var obj = {};
        var state = {};

        if (error) {
            callback(error);
            return;
        }

        state.obj = obj;
        parser.on('startElement', function (name, attrs) {
            return startElement(name, attrs, state);
        });
        parser.on('endElement', function (name) {
            return endElement(name, state);
        });

        if (!parser.parse(data.toString())) {
            throw new Error('There are errors in your xml file: '
                + parser.getError());
        }

        // replace obj.networks with array of nics.
        obj.nics = [];
        for (nic in obj.networks) {
            obj.nics.push(obj.networks[nic]);
        }
        delete obj.networks;

        // replace obj.devices with array of disks.
        obj.disks = [];
        for (disk in obj.devices) {
            obj.disks.push(obj.devices[disk]);
        }
        delete obj.devices;

        if (obj.brand === 'kvm') {
            obj.autoboot = obj.vm_autoboot;
            delete obj.vm_autoboot;
        }

        // apply the XML_PROPERTY_TRANSFORMs
        applyTransforms(obj);

        // add some calculated fields

        if (obj.brand === 'kvm' && obj.hasOwnProperty('disks')) {
            for (disk in obj.disks) {
                disk = obj.disks[disk];

                if (preload_data.hasOwnProperty('dsinfo')
                    && preload_data.dsinfo.hasOwnProperty(disk.path)) {

                    disk.zfs_filesystem =
                        preload_data.dsinfo[disk.path].dataset;
                    disk.zpool = disk.zfs_filesystem.split('/')[0];
                }
            }
        } else {
            // joyent branded zones have no 'disks'
            delete obj.disks;
        }

        if (obj.hasOwnProperty('transition')) {
            fields = rtrim(obj.transition).split(':');
            if (fields.length === 3) {
                delete obj.transition;
                obj.state = fields[0];
                obj.transition_to = fields[1];
                obj.transition_expire = fields[2];
            } else {
                VM.log('DEBUG', 'getVmobj() ignoring bad value for '
                    + 'transition "' + obj.transition + '"');
            }
        }

        // sort the disks + nics by index
        if (obj.hasOwnProperty('disks')) {
            indexSort(obj.disks, 'path', /^.*-disk(\d+)$/);
        }
        if (obj.hasOwnProperty('nics')) {
            indexSort(obj.nics, 'interface', /^net(\d+)$/);
        }
        if (obj.hasOwnProperty('filesystems')) {
            indexSort(obj.filesystems, 'target', /^(.*)$/);
        }

        callback(null, obj);
    });
}

function setQuota(dataset, quota, callback)
{
    var newval;

    if (!dataset) {
        callback(new Error('Invalid dataset: "' + dataset + '"'));
        return;
    }

    if (quota === 0 || quota === '0') {
        newval = 'none';
    } else {
        newval = quota.toString() + 'g';
    }

    zfs(['set', 'quota=' + newval, dataset], function (err, fds) {
        if (err) {
            VM.log('ERROR', 'setQuota() cmd failed: ' + fds.stderr);
            callback(new Error(rtrim(fds.stderr)));
        } else {
            callback();
        }
    });
}

/*
 * This can either get a list of all datasets and their quotas + mountpoint, or
 * the info for a specific dataset if a vm object is passed that has a
 * 'zonepath'.
 */
function loadDatasetInfo(m, callback)
{
    var args;

    args = ['list', '-H', '-p', '-t', 'volume,filesystem', '-o',
        'name,quota,volsize,mountpoint,type'];

    if (m && m.hasOwnProperty('zonepath')) {
        args.push(m.zonepath);
    }

    // no VM, so we want all VM's quotas
    zfs(args, function (err, fds) {
        var dataset;
        var dsinfo = {};
        var fields;
        var line;
        var lines = fds.stdout.split('\n');
        var mountpoint;
        var quota;
        var type;
        var volsize;

        for (line in lines) {
            line = trim(lines[line]);
            fields = line.split(/\s+/);

            if (fields.length === 5) {
                dataset = fields[0];
                quota = fields[1];
                if (quota !== '-') {
                    quota = quota / (1024 * 1024 * 1024); // GiB
                }
                volsize = fields[2];
                if (volsize !== '-') {
                    volsize = volsize / (1024 * 1024); // MiB
                }
                mountpoint = fields[3];
                type = fields[4];

                if (type === 'volume') {
                    mountpoint = '/dev/zvol/rdsk/' + dataset;
                } else if (mountpoint === '-' || mountpoint === 'legacy') {
                    mountpoint = '/' + dataset;
                }

                // we use mountpoint as the key as zonepath comes from
                // zoneadm's "cheap" info.
                dsinfo[mountpoint] = {
                    'quota': quota,
                    'volsize': volsize,
                    'dataset': dataset
                };
            } else {
                VM.log('DEBUG', 'loadDatasetQuota(): ignoring line: ' + line);
            }
        }

        callback(null, dsinfo);
    });
}

function loadTags(vmcfg, callback)
{
    var filename;

    if (vmcfg.zonepath) {
        filename = vmcfg.zonepath + '/config/tags.json';
        VM.log('DEBUG', 'loadTags() loading tags from ' + filename);
        path.exists(filename, function (exists) {
            if (exists) {
                fs.readFile(filename, function (error, data) {
                    var tags;

                    if (error) {
                        VM.log('ERROR', 'loadTags() failed to load tags'
                            + ' from ' + filename, error);
                        callback(error);
                    } else {
                        try {
                            tags = JSON.parse(data.toString());
                        } catch (e) {
                            tags = {};
                        }
                        callback(null, tags);
                    }
                });
            } else {
                callback(null, {});
            }
        });
    } else {
        callback(null, {});
    }
}

function loadMetadata(vmcfg, callback)
{
    var filename;

    if (vmcfg.zonepath) {
        filename = vmcfg.zonepath + '/config/metadata.json';
        VM.log('DEBUG', 'loadMetadata() loading metadata from ' + filename);
        path.exists(filename, function (exists) {
            if (exists) {
                fs.readFile(filename, function (error, data) {
                    var metadata;

                    if (error) {
                        VM.log('ERROR', 'loadMetadata() failed to '
                            + 'load metadata from ' + filename, error);
                        callback(error);
                    } else {
                        try {
                            metadata = JSON.parse(data.toString());
                        } catch (e) {
                            metadata = {};
                        }

                        loadTags(vmcfg, function (err, tags) {
                            if (err) {
                                callback(null, metadata, {});
                            } else {
                                callback(null, metadata, tags);
                            }
                        });
                    }
                });
            } else {
                callback(null, {});
            }
        });
    } else {
        callback(null, {});
    }
}

function preloadZoneData(uuid, callback)
{
    var data = {};

    // NOTE: uuid can be null, in which case we get data for all VMs.

    async.series([
        function (cb) {
            getZoneRecords(uuid, function (err, records) {
                if (!err) {
                    data.records = records;
                }
                cb(err);
            });
        }, function (cb) {
            loadDatasetInfo(null, function (err, dsinfo) {
                if (!err) {
                    data.dsinfo = dsinfo;
                }
                cb(err);
            });
        }, function (cb) {
            getSysinfo(function (err, sysinfo) {
                if (!err) {
                    data.sysinfo = sysinfo;
                }
                cb(err);
            });
        }, function (cb) {
            var u;
            var uuids = [];

            for (u in data.records) {
                uuids.push(u);
            }
            async.forEachSeries(uuids, function (z_uuid, zcb) {
                var filename;
                var z = data.records[z_uuid];

                // NOTE: this is the zone data, so state is zone state.
                // That means running could also be 'stopping', etc.
                if (z.brand === 'kvm' && z.state === 'running') {
                    filename = z.zonepath + '/root/tmp/vm.pid';
                    VM.log('DEBUG', 'checking for ' + filename);
                    path.exists(filename, function (exists) {
                        if (exists) {
                            fs.readFile(filename,
                                function (error, filedata) {

                                var pid;

                                if (!error) {
                                    pid = Number(trim(filedata.toString()));
                                    if (pid > 0) {
                                        z.pid = pid;
                                        VM.log('DEBUG', 'found PID '
                                            + pid + ' for ' + z.uuid);
                                    }
                                } else {
                                    zcb(error);
                                    return;
                                }
                            });
                        } else {
                            VM.log('DEBUG', 'no PID file for ' + z.uuid);
                        }
                        zcb();
                    });
                } else {
                    zcb();
                }
            }, function (err) {
                cb(err);
            });
        }
    ], function (err, res) {
        VM.log('DEBUG', 'leaving preloadZoneData()');
        callback(err, data);
    });
}

function getZoneRecords(uuid, callback)
{
    var args = [];
    var results = {};

    if (uuid) {
        // this gives us zone info if uuid is *either* a zonename or uuid
        if (isUUID(uuid)) {
            args.push('-z');
            args.push(uuid);
            args.push('-u');
            args.push(uuid);
        } else {
            args.push('-z');
            args.push(uuid);
        }
    }
    args.push('list');
    args.push('-p');
    if (!uuid) {
        args.push('-c');
    }

    zoneadm(args, function (err, fds) {
        var errmsg;
        var fields;
        var line;
        var lines;
        var obj;

        if (err) {
            errmsg = rtrim(fds.stderr);
            if (!errmsg.match(/No such zone configured$/)) {
                // not existing isn't always a problem (eg. existence check), so
                // don't always log it as an error.
                VM.log('ERROR', 'getZoneRecords() zoneadm "'
                    + args.join(',') + '" failed', err);
            }

            callback(new Error(errmsg));
            return;
        }

        lines = fds.stdout.split('\n');
        for (line in lines) {
            fields = rtrim(lines[line]).split(':');
            if (fields.length === 8 && fields[1] !== 'global') {
                obj = {
                    'zoneid': Number(fields[0]),
                    'zonename': fields[1],
                    'state': fields[2],
                    'zonepath': fields[3],
                    'uuid': fields[4],
                    'brand': fields[5],
                    'ip_type': fields[6]
                };
                VM.log('DEBUG', 'loaded: ' + JSON.stringify(obj));
                // XXX zones in some states have no uuid. We should either fix
                //     that or use zonename for those.
                results[obj.uuid] = obj;
            } else {
                VM.log('DEBUG', 'getZoneRecords(' + uuid + ') ignoring line: '
                    + lines[line]);
            }
        }
        callback(null, results);
    });
}

exports.flatten = function (vmobj, key)
{
    var tokens = key.split('.');

    if (tokens.length === 3
        && VM.FLATTENABLE_ARRAY_HASH_KEYS.indexOf(tokens[0]) !== -1) {

        if (!vmobj.hasOwnProperty(tokens[0])) {
            return undefined;
        }
        if (!vmobj[tokens[0]].hasOwnProperty(tokens[1])) {
            return undefined;
        }
        return vmobj[tokens[0]][tokens[1]][tokens[2]];
    }

    if (tokens.length === 2
        && VM.FLATTENABLE_HASH_KEYS.indexOf(tokens[0]) !== -1) {

        if (!vmobj.hasOwnProperty(tokens[0])) {
            return undefined;
        }
        return vmobj[tokens[0]][tokens[1]];
    }

    return vmobj[key];
};

function loadVM(uuid, data, callback)
{
    var e;
    var info;

    // XXX need to always have data when we get here
    info = data.records[uuid];

    if (!info) {
        e = new Error('VM.load() empty info when getting record '
            + 'for vm ' + uuid);
        VM.log('ERROR', e.message, e);
        callback(e);
        return;
    }

    getVmobj(info.zonename, data, function (err, vmobj) {
        if (err) {
            callback(err);
            return;
        }

        // add the bits we can only find from zoneadm list
        vmobj.uuid = info.uuid;

        // In the case of 'configured' zones, we might only have zonename
        // because uuid isn't set yet.  Because of that case, we set uuid
        // to zonename if it is in UUID form.
        if ((!vmobj.uuid || vmobj.uuid.length === 0)
            && isUUID(vmobj.zonename)) {

            vmobj.uuid = vmobj.zonename;
        }

        // sysinfo has compute_node_uuid
        if (data.hasOwnProperty('sysinfo')
            && data.sysinfo.hasOwnProperty('UUID')) {

            vmobj.compute_node_uuid = data.sysinfo.UUID;
        }

        if (info.zoneid !== '-') {
            vmobj.zoneid = info.zoneid;
        }

        if (info.pid) {
            vmobj.pid = info.pid;
        }

        // state could already be set here if it was overriden by a
        // transition that's in progress.
        vmobj.zone_state = info.state;
        if (info.state === 'installed') {
            vmobj.state = 'stopped';
        } else if (!vmobj.hasOwnProperty('state')) {
            vmobj.state = info.state;
        }

        loadMetadata(vmobj, function (error, metadata, tags) {
            var d;
            var k;

            if (error) {
                callback(new Error('Unable to add metadata:'
                    + error.message));
                return;
            }

            if (data.dsinfo.hasOwnProperty(vmobj.zonepath)) {
                vmobj.quota = data.dsinfo[vmobj.zonepath].quota;
                VM.log('DEBUG', 'found quota "' + vmobj.quota + '" for '
                    + vmobj.uuid);
                vmobj.zfs_filesystem = data.dsinfo[vmobj.zonepath].dataset;
                VM.log('DEBUG', 'found dataset "' + vmobj.zfs_filesystem
                    + '" for ' + vmobj.uuid);
            } else {
                VM.log('DEBUG', 'no dsinfo for ' + vmobj.uuid);
            }

            if (vmobj.hasOwnProperty('zfs_filesystem')) {
                vmobj.zfs_storage_pool_name =
                    vmobj.zfs_filesystem.split('/')[0];
            }

            if (vmobj.hasOwnProperty('disks')) {
                for (d in vmobj.disks) {
                    d = vmobj.disks[d];
                    if (d.hasOwnProperty('path')
                        && data.dsinfo.hasOwnProperty(d.path)
                        && data.dsinfo[d.path].hasOwnProperty('volsize')) {

                        d.size = data.dsinfo[d.path].volsize;
                        VM.log('DEBUG', 'found size=' + d.size + ' for '
                            + JSON.stringify(d));
                    } else {
                        VM.log('WARN', 'no dsinfo for ' + JSON.stringify(d));
                    }
                }
            }

            for (k in metadata) {
                vmobj[k] = metadata[k];
            }
            if (!vmobj.hasOwnProperty('customer_metadata')) {
                vmobj.customer_metadata = {};
            }
            if (!vmobj.hasOwnProperty('internal_metadata')) {
                vmobj.internal_metadata = {};
            }
            if (tags) {
                vmobj.tags = tags;
            } else {
                vmobj.tags = {};
            }
            callback(null, vmobj);
        });
    });
}

exports.load = function (uuid, callback)
{
    // This is a wrapper so that other internal functions here (such as lookup)
    // can do smart things like check the quota for each VM with a separate call
    // to zfs get.

    preloadZoneData(uuid, function (error, data) {
        if (error) {
            VM.log('ERROR', 'VM.load() failed to get zone record'
                + ' for ' + uuid, error);
            callback(error);
        } else {
            loadVM(uuid, data, callback);
        }
    });
};

function fixMac(str)
{
    var fixed = [];
    var octet;
    var octets = str.split(':');

    for (octet in octets) {
        if (octets.hasOwnProperty(octet)) {
            octet = parseInt(octets[octet], 16);
            if (octet === 'nan') {
                octet = 0;
            }
            fixed.push(sprintf('%02x', octet));
        }
    }

    return fixed.join(':');
}

// zonecfg requires removing leading 0's in MACs like 01:02:03:04:05:06
// This function takes a MAC in normal form and puts it in the goofy form
// zonecfg wants.
function ruinMac(mac)
{
    var part;
    var parts = mac.split(':');
    var out = [];

    for (part in parts) {
        part = ltrim(parts[part], '0');
        if (part.length === 0) {
            part = '0';
        }
        out.push(part);
    }

    return (out.join(':'));
}

function matcher(zone, search)
{
    var fields;
    var found;
    var i;
    var key;
    var parameters_matched = 0;
    var regex;
    var target;

    function find_match(k, targ) {
        var value = VM.flatten(zone, k);

        if (!regex && k.match(/^nics\..*\.mac$/)) {
            // Fix for broken SmartOS MAC format
            targ = fixMac(targ);
        }

        if (regex && value && value.toString().match(targ)) {
            found = true;
        } else if (value && value.toString() === targ.toString()) {
            found = true;
        }
    }

    for (key in search) {
        found = false;
        regex = false;

        target = search[key];
        if (target[0] === '~') {
            regex = true;
            target = new RegExp(target.substr(1), 'i');
        }

        fields = key.split('.');
        if (fields.length === 3 && fields[1] === '*'
            && VM.FLATTENABLE_ARRAY_HASH_KEYS.indexOf(fields[0]) !== -1) {

            // Special case: for eg. nics.*.ip, we want to loop through all nics
            for (i = 0; i < zone[fields[0]].length; i++) {
                fields[1] = i;
                find_match(fields.join('.'), target);
            }
        } else {
            find_match(key, target);
        }

        if (!found) {
            return false;
        } else {
            parameters_matched++;
        }
    }

    if (parameters_matched > 0) {
        // we would have returned false from the loop had any parameters not
        // matched and we had at least one that did.
        return true;
    }

    return false;
}

exports.lookup = function (search, options, callback) {
    var key;
    var quick_ok = true;
    var results = [];
    var transform;

    if (!options) {
        options = {};
    }

    // XXX the 'transform' option is not intended to be public yet and should
    // only be used by tools willing to be rewritten if this is removed or
    // changed.
    if (options.hasOwnProperty('transform')) {
        transform = options.transform;
    }

    for (key in search) {
        if (QUICK_LOOKUP.indexOf(key) === -1) {
            quick_ok = false;
        }
    }
    preloadZoneData(null, function (err, data) {
        var records = data.records;
        var uuids = [];

        if (err) {
            callback(err);
            return;
        }

        if (quick_ok) {
            var full_results = [];
            var match;
            var regex;
            var target;
            var u;
            var z;

            if (err) {
                callback(err);
                return;
            }
            for (z in records) {
                z = records[z];
                match = true;
                for (key in search) {
                    regex = false;
                    target = search[key];
                    if (target[0] === '~') {
                        target = new RegExp(target.substr(1), 'i');
                        regex = true;
                    }
                    if (regex && !z[key].match(target)) {
                        match = false;
                    } else if (!regex && (z[key] !== search[key])) {
                        match = false;
                    }
                }
                if (match && z.uuid) {
                    results.push(z.uuid);
                }
            }
            if (!options.full) {
                // we don't need all the data so what we already got is enough
                callback(null, results);
                return;
            } else {
                // need to expand these
                function expander(uuid, cb)
                {
                    loadVM(uuid, data, function (e, obj) {
                        if (e) {
                            if (e.code === 'ENOENT') {
                                // zone likely was deleted since lookup, ignore
                                cb();
                            } else {
                                cb(e);
                            }
                        } else {
                            if (transform) {
                                transform(obj);
                            }
                            full_results.push(obj);
                            cb();
                        }
                    });
                }

                // create all the volumes we found that we need.
                async.forEachSeries(results, expander, function (e) {
                    if (e) {
                        VM.log('ERROR', 'VM.lookup failed to '
                            + 'expand results', e);
                        callback(e);
                    } else {
                        callback(null, full_results);
                    }
                });
            }
        } else {
            // have to search the hard way (through all the data)
            for (u in records) {
                uuids.push(u);
            }
            // this is parallel!
            async.forEach(uuids, function (uuid, cb) {
                var vmobj = records[uuid];

                loadVM(vmobj.uuid, data, function (error, obj) {
                    if (error) {
                        if (error.code === 'ENOENT') {
                            // zone likely was deleted since lookup, ignore
                            cb();
                        } else {
                            cb(error);
                        }
                    } else {
                        if (transform) {
                            transform(obj);
                        }
                        if (matcher(obj, search)) {
                            results.push(obj);
                        }
                        cb();
                    }
                });
            }, function (e) {
                var r;
                var short_results = [];

                if (e) {
                    callback(e);
                } else {
                    if (options.full) {
                        callback(null, results);
                    } else {
                        for (r in results) {
                            short_results.push(results[r].uuid);
                        }
                        callback(null, short_results);
                    }
                }
            });
        }
    });
};

// create a random new locally administered MAC address
function generateMAC()
{
    var data;
    var result;

    // time in milliseconds + 3 random digits
    data = ((Date.now() * 1000)
        + (Math.floor(Math.random()*1000) % 1000)).toString(16);

    // split to correct number of characters
    data = data.substr(data.length - 12);

    // set the 'locally administered' bit and don't set the multicast bit.
    // locally administered MAC addresses, won't conflict with OUIs
    data = data.substr(0, 1) + '2' + data.substr(2);

    // turn into MAC format
    result = data.match(/../g).join(':');

    VM.log('DEBUG', 'Generated new MAC address: ' + result);

    return result;
}

// Ensure we've got all the datasets necessary to create this VM
//
// IMPORTANT:
//
// On SmartOS, we assume a provisioner or some other external entity has already
// loaded the dataset into the system. This function just confirms that the
// dataset actually exists.
//
function checkDatasets(payload, callback)
{
    var checkme = [];
    var d;
    var disk;

    VM.log('DEBUG', 'Checking for required datasets.');

    // build list of datasets we need to download (downloadme)
    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            d = payload.disks[disk];
            if (d.hasOwnProperty('image_uuid')) {
                checkme.push(payload.zfs_storage_pool_name + '/'
                    + d.image_uuid);
            }
        }
    }

    function checker(dataset, cb) {
        zfs(['list', '-o', 'name', '-H', dataset], function (err, fds) {
            if (err) {
                VM.log('ERROR', 'zfs list ' + dataset + ' exited with'
                    + ' code: ' + err.code + ' stdout: "' + fds.stdout
                    + '" stderr:"' + fds.stderr + '"', err);
                cb(new Error('unable to find dataset: ' + dataset));
            } else {
                cb();
            }
        });
    }

    // check that we have all the volumes
    async.forEachSeries(checkme, checker, function (err) {
        if (err) {
            VM.log('ERROR', 'checkDatasets() failed to find required '
                + 'volumes', err);
            callback(err);
        } else {
            // progress(100, 'we have all necessary datasets');
            callback();
        }
    });
}

function lookupConflicts(macs, ips, callback) {
    var conflict = false;

    VM.log('DEBUG', 'checking for conflicts with '
        + JSON.stringify(macs) + ' and ' + JSON.stringify(ips));

    if (macs.length === 0 && ips.length === 0) {
        VM.log('DEBUG', 'returning from conflict check (nothing to check)');
        callback(null, conflict);
        return;
    }

    preloadZoneData(null, function (err, data) {
        var records = data.records;
        var uuid;
        var uuids = [];

        if (err) {
            callback(err);
            return;
        }

        for (uuid in records) {
            uuids.push(uuid);
        }

        // this is parallel!
        async.forEach(uuids, function (z_uuid, cb) {
            loadVM(z_uuid, data, function (error, obj) {
                var ip;
                var mac;

                if (error) {
                    if (error.code === 'ENOENT') {
                        // zone likely was deleted since lookup, ignore it
                        cb();
                    } else {
                        cb(error);
                    }
                    return;
                }
                for (ip in ips) {
                    if (ips[ip] !== 'dhcp'
                        && matcher(obj, {'nics.*.ip': ips[ip]})) {

                        VM.log('ERROR', 'Found conflict: ' + obj.uuid
                            + ' already has IP ' + ips[ip]);
                        conflict = true;
                    }
                }
                for (mac in macs) {
                    if (matcher(obj, {'nics.*.mac': macs[mac]})) {
                        VM.log('ERROR', 'Found conflict: ' + obj.uuid
                            + ' already has MAC ' + macs[mac]);
                        conflict = true;
                    }
                }
                cb();
            });
        }, function (e) {
            if (e) {
                callback(e);
            } else {
                VM.log('DEBUG', 'returning from conflict check');
                callback(null, conflict);
            }
        });
    });
}

// create a new zvol for a VM
function createVolume(volume, callback)
{
    var size;

    VM.log('DEBUG', 'creating volume ' + JSON.stringify(volume));

    if (volume.hasOwnProperty('image_size')) {
        size = volume.image_size;
    } else if (volume.hasOwnProperty('size')) {
        size = volume.size;
    } else {
        callback(new Error('FATAL: createVolume(' + JSON.stringify(volume)
            + '): ' + 'has no size or image_size'));
        return;
    }

    async.series([
        function (cb) {
            var args;
            var snapshot;
            var target;

            target = volume.zpool + '/' + volume.uuid;
            if (volume.hasOwnProperty('image_uuid')) {
                // This volume is from a template/dataset/image so we create
                // it as a clone of a snapshot of the original.
                snapshot = volume.zpool + '/' + volume.image_uuid
                    + '@' + volume.uuid;

                zfs(['snapshot', snapshot], function (err, fds) {
                    if (err) {
                        cb(err);
                    } else {
                        zfs(['clone', snapshot, target], function (e) {
                            if (e) {
                                cb(e);
                            } else {
                                volume.path = '/dev/zvol/rdsk/' + target;
                                cb();
                            }
                        });
                    }
                });
            } else {
                // This volume is not from a template/dataset/image so we create
                // a blank new zvol for it.
                args = ['create', '-o', 'refreservation=none', '-V', size + 'M',
                    target];

                zfs(args, function (err, fds) {
                    if (err) {
                        cb(err);
                    } else {
                        volume.path = '/dev/zvol/rdsk/' + target;
                        cb();
                    }
                });
            }
        }
    ], function (err, results) {
        callback(err);
    });
}

// Create all the volumes for a given VM property set
function createVolumes(payload, callback)
{
    var createme = [];
    var d;
    var disk;
    var disk_idx = 0;
    var used_disk_indexes = [];

    VM.log('DEBUG', 'creating volumes: ' + JSON.stringify(payload.disks));

    if (payload.hasOwnProperty('used_disk_indexes')) {
        used_disk_indexes = payload.used_disk_indexes;
    }

    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            d = payload.disks[disk];
            d.index = disk_idx;

            // skip to the next unused one.
            while (used_disk_indexes.indexOf(disk_idx) !== -1) {
                disk_idx++;
            }

            d.uuid = payload.uuid + '-disk' + disk_idx;
            used_disk_indexes.push(Number(disk_idx));
            if (!d.hasOwnProperty('zpool')) {
                d.zpool = payload.zfs_storage_pool_name;
            }
            createme.push(d);
        }
    }

    // create all the volumes we found that we need.
    async.forEachSeries(createme, createVolume, function (err) {
        if (err) {
            callback(err);
        } else {
            callback();
        }
    });
}

// writes a Zone's metadata JSON to /zones/<uuid>/config/metadata.json
// and /zones/<uuid>/config/tags.json.
function updateMetadata(vmobj, payload, callback)
{
    var mdata_filename;
    var tags_filename;
    var key;
    var mdata = {};
    var imdata = {};
    var cmdata = {};
    var tags = {};
    var zonepath = vmobj.zonepath = '/'
        + vmobj.zfs_storage_pool_name + '/'
        + vmobj.zonename;

    // paths are under zonepath but not zoneroot
    mdata_filename = zonepath + '/config/metadata.json';
    tags_filename = zonepath + '/config/tags.json';

    // customer_metadata
    for (key in vmobj.customer_metadata) {
        if (vmobj.customer_metadata.hasOwnProperty(key)) {
            cmdata[key] = vmobj.customer_metadata[key];
            if (payload.hasOwnProperty('remove_customer_metadata')
                && payload.remove_customer_metadata.indexOf(key) !== -1) {

                // in the remove_* list, don't load it.
                delete cmdata[key];
            }
        }
    }

    for (key in payload.set_customer_metadata) {
        if (payload.set_customer_metadata.hasOwnProperty(key)) {
            cmdata[key] = payload.set_customer_metadata[key];
        }
    }

    // internal_metadata
    for (key in vmobj.internal_metadata) {
        if (vmobj.internal_metadata.hasOwnProperty(key)) {
            imdata[key] = vmobj.internal_metadata[key];
            if (payload.hasOwnProperty('remove_internal_metadata')
                && payload.remove_internal_metadata.indexOf(key) !== -1) {

                // in the remove_* list, don't load it.
                delete imdata[key];
            }
        }
    }

    for (key in payload.set_internal_metadata) {
        if (payload.set_internal_metadata.hasOwnProperty(key)) {
            imdata[key] = payload.set_internal_metadata[key];
        }
    }

    // same thing for tags
    for (key in vmobj.tags) {
        if (vmobj.tags.hasOwnProperty(key)) {
            tags[key] = vmobj.tags[key];
            if (payload.hasOwnProperty('remove_tags')
                && payload.remove_tags.indexOf(key) !== -1) {

                // in the remove_* list, don't load it.
                delete tags[key];
            }
        }
    }

    for (key in payload.set_tags) {
        if (payload.set_tags.hasOwnProperty(key)) {
            tags[key] = payload.set_tags[key];
        }
    }

    mdata = {'customer_metadata': cmdata, 'internal_metadata': imdata};
    fs.writeFile(mdata_filename, JSON.stringify(mdata, null, 2),
        function (err) {
            if (err) {
                callback(err);
            } else {
                VM.log('DEBUG', 'wrote metadata to ' + mdata_filename);
                fs.writeFile(tags_filename, JSON.stringify(tags, null, 2),
                    function (e) {
                        if (e) {
                            callback(e);
                        } else {
                            VM.log('DEBUG', 'wrote tags to' + tags_filename);
                            callback();
                        }
                    }
                );
            }
        }
    );
}

function saveMetadata(payload, callback)
{
    var protovm = {};

    if (!payload.hasOwnProperty('zonepath')
        || !payload.hasOwnProperty('zfs_storage_pool_name')
        || !payload.hasOwnProperty('zonename')) {

        callback(new Error('saveMetadata payload is missing zone '
            + 'properties.'));
        return;
    }

    protovm.zonepath = payload.zonepath;
    protovm.zfs_storage_pool_name = payload.zfs_storage_pool_name;
    protovm.zonename = payload.zonename;
    protovm.customer_metadata = {};
    protovm.tags = {};

    if (payload.hasOwnProperty('tags')) {
        payload.set_tags = payload.tags;
        delete payload.tags;
    }
    if (payload.hasOwnProperty('customer_metadata')) {
        payload.set_customer_metadata = payload.customer_metadata;
        delete payload.customer_metadata;
    }
    if (payload.hasOwnProperty('internal_metadata')) {
        payload.set_internal_metadata = payload.internal_metadata;
        delete payload.internal_metadata;
    }

    updateMetadata(protovm, payload, callback);
}

function createVM(payload, callback)
{
    async.series([
        function (cb) {
            // progress(2, 'checking required datasets');
            checkDatasets(payload, cb);
        }, function (cb) {
            // progress(29, 'creating volumes');
            createVolumes(payload, cb);
        }, function (cb) {
            // progress(51, 'creating zone container');
            createZone(payload, cb);
        }
    ], function (err, results) {
        if (err) {
            callback(err);
        } else {
            callback(null, results);
        }
    });
}

// XXX do we still need this?
function writeZoneconfig(payload, callback)
{
    var data;
    var n;
    var nic;
    var primary_found = false;

    if (!payload.hasOwnProperty('hostname')) {
        payload.hostname = payload.zonename;
    }

    data = 'TEMPLATE_VERSION=0.0.1\n'
        + 'ZONENAME=' + payload.zonename + '\n'
        + 'HOSTNAME=' + payload.hostname + '.' + payload.dns_domain + '\n'
        + 'TMPFS=' + payload.tmpfs + 'm\n';

    if (payload.hasOwnProperty('add_nics') && payload.add_nics[0]) {

        if (payload.add_nics[0] && payload.add_nics[0].ip != 'dhcp') {
            data = data + 'PUBLIC_IP=' + payload.add_nics[0].ip + '\n';
        }
        if (payload.add_nics[1] && payload.add_nics[1].ip != 'dhcp') {
            data = data + 'PRIVATE_IP=' + payload.add_nics[1].ip + '\n';
        } else if (payload.add_nics[0] && payload.add_nics[0].ip != 'dhcp') {
            // zoneinit uses private_ip for /etc/hosts, we want to
            // make that same as public, if there's no actual private.
            data = data + 'PRIVATE_IP=' + payload.add_nics[0].ip + '\n';
        }
    }

    if (payload.hasOwnProperty('resolvers')) {
        // zoneinit appends to resolv.conf rather than overwriting, so just
        // add to the zoneconfig and let zoneinit handle it
        data = data + 'RESOLVERS="' + payload.resolvers.join(' ') + '"\n';
    }

    for (nic in payload.add_nics) {
        if (payload.add_nics.hasOwnProperty(nic)) {
            n = payload.add_nics[nic];
            data = data + n.interface.toUpperCase() + '_MAC=' + n.mac + '\n'
                + n.interface.toUpperCase() + '_INTERFACE='
                + n.interface.toUpperCase() + '\n';

            if (n.ip != 'dhcp') {
                fs.writeFileSync(payload.zonepath + '/root/etc/hostname.'
                    + n.interface, n.ip + ' netmask ' + n.netmask
                    + ' up' + '\n');
                data = data + n.interface.toUpperCase() + '_IP=' + n.ip + '\n'
                    + n.interface.toUpperCase() + '_NETMASK='
                    + n.netmask + '\n';
            }

            if (n.hasOwnProperty('primary') && !primary_found) {
                // only allow one primary network
                primary_found = true;
                if (n.hasOwnProperty('gateway')) {
                    fs.writeFileSync(payload.zonepath
                        + '/root/etc/defaultrouter', n.gateway + '\n');
                }
                if (n.ip == 'dhcp') {
                    fs.writeFileSync(payload.zonepath + '/root/etc/dhcp.'
                        + n.interface, '');
                }
            }
        }
    }

    VM.log('DEBUG', 'writing extra files to zone root');
    fs.writeFileSync(payload.zonepath + '/root/etc/nodename',
        payload.hostname + '\n');
    fs.writeFileSync(payload.zonepath
        + '/root/var/svc/log/system-zoneinit:default.log', '');

    VM.log('DEBUG', 'writing ' + JSON.stringify(data) + ' to /'
        + payload.zfs_storage_pool_name + '/' + payload.zonename);

    fs.writeFile('/' + payload.zfs_storage_pool_name + '/' + payload.zonename
        + '/root/root/zoneconfig', data, function (err, result) {

        if (err) {
            callback(err);
        } else {
            callback();
        }
    });
}

function zonecfg(args, callback)
{
    var cmd = '/usr/sbin/zonecfg';

    VM.log('DEBUG', cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            // TODO log here.
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            callback(null, {'stdout': stdout, 'stderr': stderr});
        }
    });
}

function zonecfgFile(data, args, callback)
{
    var tmpfile = '/tmp/zonecfg.' + process.pid + '.tmp';

    fs.writeFile(tmpfile, data, function (err, result) {
        if (err) {
            // On failure we don't delete the tmpfile so we can debug it.
            callback(err);
        } else {
            args.push('-f');
            args.push(tmpfile);

            zonecfg(args, function (e, fds) {
                if (e) {
                    // keep temp file around for investigation
                    callback(e, fds);
                } else {
                    fs.unlink(tmpfile, function () {
                        callback(null, fds);
                    });
                }
            });
        }
    });
}

function zoneadm(args, callback)
{
    var cmd = '/usr/sbin/zoneadm';

    VM.log('DEBUG', cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            callback(null, {'stdout': stdout, 'stderr': stderr});
        }
    });
}

function zfs(args, callback)
{
    var cmd = '/usr/sbin/zfs';

    VM.log('DEBUG', cmd + ' ' + args.join(' '));
    execFile(cmd, args, function (error, stdout, stderr) {
        if (error) {
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            callback(null, {'stdout': stdout, 'stderr': stderr});
        }
    });
}

function getSysinfo(callback)
{
    var cmd = '/usr/bin/sysinfo';

    VM.log('DEBUG', cmd);
    execFile(cmd, [], function (error, stdout, stderr) {
        var sysinfo;

        if (error) {
            callback(error, {'stdout': stdout, 'stderr': stderr});
        } else {
            try {
                sysinfo = JSON.parse(stdout.toString());
            } catch (e) {
                sysinfo = {};
            }
            callback(null, sysinfo);
        }
    });
}

// Call the callback when joyent zone has rebooted.
function waitForJoyentZone(payload, callback) {
    var buffer = '';
    var chunks;
    var found = false;
    var timeout;
    var timeout_secs = 5 * 60;
    var watcher;
    var watcher_pid;

    VM.log('DEBUG', '/usr/vm/sbin/zoneevent');
    watcher = spawn('/usr/vm/sbin/zoneevent', [], {'customFds': [-1, -1, -1]});
    VM.log('INFO', 'zoneevent running with pid ' + watcher.pid);
    watcher_pid = watcher.pid;

    function cleanup() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        if (watcher) {
            watcher.removeAllListeners('exit'); // so we don't fail on our kill
            watcher.kill();
            watcher = null;
        }
    }

    timeout = setTimeout(function () {
        cleanup();
        callback(new Error('Timed out waiting for zone to reboot'));
    }, timeout_secs * 1000);

    watcher.stdout.on('data', function (data) {
        var chunk;
        var obj;

        buffer += data.toString();
        chunks = buffer.split('\n');
        while (chunks.length > 1) {
            chunk = chunks.shift();
            obj = JSON.parse(chunk);

            if (obj.zonename === payload.zonename) {
                VM.log('DEBUG', 'zoneevent said: ' + JSON.stringify(obj));
                // Note: sometimes sysevent emits multiple events for the same
                // status, we only want the first one here because calling
                // callback() twice is not nice.
                if (!found && obj.newstate === 'running') {
                    VM.log('INFO', payload.uuid + ' went back to "running"'
                        + ', zoneinit is finished.');
                    found = true; // set this so the watcher.on('exit', works
                    cleanup();
                    callback();
                    return;
                }
            }
        }
        buffer = chunks.pop();
    });
    watcher.stdin.end();

    watcher.on('exit', function (code) {
        VM.log('ERROR', 'zoneevent watcher ' + watcher_pid + ' exited: ',
            JSON.stringify(code));
        cleanup();
        callback(new Error('zoneevent watcher exited prematurely with code: '
            + code));
    });
}

function fixPayloadMemory(payload, vmobj)
{
    var brand;
    var max_locked;
    var max_phys;
    var max_swap;
    var ram;

    if (vmobj.hasOwnProperty('brand')) {
        brand = vmobj.brand;
    } else if (payload.hasOwnProperty('brand')) {
        brand = payload.brand;
    }

    if (payload.hasOwnProperty('ram') && brand === 'kvm'
        && !payload.hasOwnProperty('max_physical_memory')) {

        // For now we add overhead to the memory caps for KVM zones, this
        // is for the qemu process itself.  Since customers don't have direct
        // access to zone memory, this exists mostly to protect against bugs.
        payload.max_physical_memory = payload.ram + VM.KVM_MEM_OVERHEAD;
    } else if (payload.hasOwnProperty('ram') && brand === 'joyent') {
        payload.max_physical_memory = payload.ram;
    }

    if (payload.hasOwnProperty('max_physical_memory')) {
        if (!payload.hasOwnProperty('max_locked_memory')) {
            if (vmobj.hasOwnProperty('max_locked_memory')
                && vmobj.hasOwnProperty('max_physical_memory')) {

                // we don't have a new value, so first try to keep the same
                // delta that existed before btw. max_phys and max_locked
                payload.max_locked_memory = payload.max_physical_memory
                    - (vmobj.max_physical_memory - vmobj.max_locked_memory);
            } else {
                // existing obj doesn't have max_locked, add one now
                payload.max_locked_memory = payload.max_physical_memory;
            }
        }

        if (!payload.hasOwnProperty('max_swap')) {
            if (vmobj.hasOwnProperty('max_swap')
                && vmobj.hasOwnProperty('max_physical_memory')) {

                // we don't have a new value, so first try to keep the same
                // delta that existed before btw. max_phys and max_swap
                payload.max_swap = payload.max_physical_memory
                    + (vmobj.max_swap - vmobj.max_physical_memory);
            } else {
                // existing obj doesn't have max_swap, add one now
                payload.max_swap = payload.max_physical_memory;
            }
        }
    }

    // if we're updating tmpfs it must be lower than our new max_physical or
    // if we're not also changing max_physical, it must be lower than the
    // current one.
    if (payload.hasOwnProperty('tmpfs')) {
        if (payload.hasOwnProperty('max_physical_memory')
            && (Number(payload.tmpfs)
                > Number(payload.max_physical_memory))) {

            payload.tmpfs = payload.max_physical_memory;
        } else if (Number(payload.tmpfs)
            > Number(vmobj.max_physical_memory)) {

            payload.tmpfs = vmobj.max_physical_memory;
        }
    }
    if (payload.hasOwnProperty('max_physical_memory')
        && brand === 'joyent'
        && !payload.hasOwnProperty('tmpfs')) {

        if (vmobj.hasOwnProperty('max_physical_memory')
            && vmobj.hasOwnProperty('tmpfs')) {

            // change tmpfs to be the same ratio of ram as before
            payload.tmpfs = ((vmobj.tmpfs / vmobj.max_physical_memory)
                * payload.max_physical_memory);
            payload.tmpfs = Number(payload.tmpfs).toFixed();
        } else {
            // tmpfs must be < max_physical_memory, if not: pretend it was
            payload.tmpfs = payload.max_physical_memory;
        }
    }

    // now that we've possibly adjusted target values, lower/raise values to
    // satisify max/min.

    if (brand === 'kvm') {
        ram = payload.hasOwnProperty('ram') ? payload.ram : vmobj.ram;
        max_phys = payload.hasOwnProperty('max_physical_memory')
            ? payload.max_physical_memory : vmobj.max_physical_memory;
        max_locked = payload.hasOwnProperty('max_locked_memory')
            ? payload.max_locked_memory : vmobj.max_locked_memory;

        if ((ram + VM.KVM_MIN_MEM_OVERHEAD) > max_phys) {
            payload.max_physical_memory = (ram + VM.KVM_MIN_MEM_OVERHEAD);
        }
        if ((ram + VM.KVM_MIN_MEM_OVERHEAD) > max_locked) {
            payload.max_locked_memory = (ram + VM.KVM_MIN_MEM_OVERHEAD);
        }
    }

    if (payload.hasOwnProperty('max_locked_memory')) {
        if (payload.hasOwnProperty('max_physical_memory')) {
            if (payload.max_locked_memory > payload.max_physical_memory) {
                VM.log('WARN', 'max_locked_memory (' + payload.max_locked_memory
                    + ') > max_physical_memory (' + payload.max_physical_memory
                    + ') clamping to ' + payload.max_physical_memory);
                payload.max_locked_memory = payload.max_physical_memory;
            }
        } else if (vmobj.hasOwnProperty('max_physical_memory')) {
            // new payload doesn't have a max_physical, so clamp to vmobj's
            if (payload.max_locked_memory > vmobj.max_physical_memory) {
                VM.log('WARN', 'max_locked_memory (' + payload.max_locked_memory
                    + ') > vm.max_physical_memory (' + vmobj.max_physical_memory
                    + ') clamping to ' + vmobj.max_physical_memory);
                payload.max_locked_memory = vmobj.max_physical_memory;
            }
        }
    }

    if (payload.hasOwnProperty('max_swap')) {
        if (payload.hasOwnProperty('max_physical_memory')) {
            if (payload.max_swap < payload.max_physical_memory) {
                VM.log('WARN', 'max_swap (' + payload.max_swap
                    + ') < max_physical_memory (' + payload.max_physical_memory
                    + ') raising to ' + payload.max_physical_memory);
                payload.max_swap = payload.max_physical_memory;
            }
        } else if (vmobj.hasOwnProperty('max_physical_memory')) {
            // new payload doesn't have a max_physical, so raise to vmobj's
            if (payload.max_swap < vmobj.max_physical_memory) {
                VM.log('WARN', 'max_swap (' + payload.max_swap
                    + ') < vm.max_physical_memory (' + vmobj.max_physical_memory
                    + ') raising to ' + vmobj.max_physical_memory);
                payload.max_swap = vmobj.max_physical_memory;
            }
        }
    }
}


// generate a new UUID if payload doesn't have one (also ensures that this uuid
// does not already belong to a zone).
function createZoneUUID(payload, callback)
{
    var uuid;

    if (payload.hasOwnProperty('uuid')) {
        // Ensure that the uuid is not already used.
        getZoneRecords(null, function (err, records) {
            if (err) {
                callback(err);
            } else {
                if (records.hasOwnProperty(payload.uuid)) {
                    callback(new Error('vm with UUID ' + payload.uuid
                        + 'already exists.'));
                } else {
                    callback(null, payload.uuid);
                }
            }
        });
    } else {
        VM.log('DEBUG', '/usr/bin/uuid -v 4');
        execFile('/usr/bin/uuid', ['-v', '4'], function (err, stdout, stderr) {
            if (err) {
                callback(err);
                return;
            }

            // chomp trailing spaces and newlines
            uuid = stdout.toString().replace(/\s+$/g, '');
            payload.uuid = uuid;
            VM.log('INFO', 'createZoneUUID() generated uuid ' + uuid);
            getZoneRecords(null, function (e, records) {
                if (e) {
                    callback(e);
                } else {
                    if (records.hasOwnProperty(payload.uuid)) {
                        callback(new Error('vm with UUID ' + payload.uuid
                            + 'already exists.'));
                    } else {
                        if (!payload.hasOwnProperty('zonename')) {
                            payload.zonename = payload.uuid;
                        }
                        callback(null, payload.uuid);
                    }
                }
            });
        });
    }
}

function applyZoneDefaults(payload)
{
    var disk;
    var n;
    var nic;
    var zvol;

    VM.log('DEBUG', 'applying zone defaults');

    if (payload.hasOwnProperty('uuid') && !payload.hasOwnProperty('zonename')) {
        payload.zonename = payload.uuid;
    }

    if (!payload.hasOwnProperty('owner_uuid')) {
        // We assume that this all-zero uuid can be treated as 'admin'
        payload.owner_uuid = '00000000-0000-0000-0000-000000000000';
    }

    if (!payload.hasOwnProperty('autoboot')) {
        payload.autoboot = 'true';
    }

    if (!payload.hasOwnProperty('brand')) {
        payload.brand = 'joyent';
    }

    if (!payload.hasOwnProperty('zfs_storage_pool_name')) {
        payload.zfs_storage_pool_name = 'zones';
    }

    if (!payload.hasOwnProperty('dns_domain')) {
        payload.dns_domain = 'local';
    }

    if (!payload.hasOwnProperty('cpu_shares')) {
        payload.cpu_shares = 100;
    } else {
        if (payload.cpu_shares > 65535) {
            VM.log('INFO', 'capping cpu_shares at 64k (was: '
                + payload.cpu_shares + ')');
            payload.cpu_shares = 65535; // max is 64K
        }
    }

    if (!payload.hasOwnProperty('zfs_io_priority')) {
        payload.zfs_io_priority = 100;
    }

    if (!payload.hasOwnProperty('max_lwps')) {
        payload.max_lwps = 2000;
    }

    // We need to set the RAM here because we use it as the default for
    // the max_physical_memory below.
    if (payload.brand === 'kvm' && !payload.hasOwnProperty('ram')) {
        payload.ram = 256;
    }

    if (payload.brand === 'joyent'
        && !payload.hasOwnProperty('max_physical_memory')) {

        payload.max_physical_memory = 256;
    }

    fixPayloadMemory(payload, {});

    if (payload.brand === 'kvm' && !payload.hasOwnProperty('vcpus')) {
        payload.vcpus = 1;
    } else if (payload.brand === 'joyent') {
        if (!payload.hasOwnProperty('tmpfs')
            || (Number(payload.tmpfs) > Number(payload.max_physical_memory))) {

            payload.tmpfs = payload.max_physical_memory;
        }
        if (!payload.hasOwnProperty('delegate_dataset')) {
            payload.delegate_dataset = false;
        } else {
            // ensure boolean
            payload.delegate_dataset = !!payload.delegate_dataset;
        }
    }

    if (!payload.hasOwnProperty('limit_priv')) {
        // note: the limit privs are going to be added to the brand and
        // shouldn't need to be set here by default when that's done.
        if (payload.brand === 'joyent') {
            payload.limit_priv = 'default';
        } else if (payload.brand === 'kvm') {
            // currently there's no way to disable these in the zone's
            // config.xml, see OS-989 for details.
            payload.limit_priv = [
                'default',
                '-file_link_any',
                '-net_access',
                '-proc_fork',
                '-proc_info',
                '-proc_session'
            ].join(',');
        }
    }

    if (!payload.hasOwnProperty('quota')) {
        payload.quota = '10'; // in GiB
    }

    if (!payload.hasOwnProperty('billing_id')) {
        if (payload.hasOwnProperty('dataset_uuid')) {
            payload.billing_id = payload.dataset_uuid;
        } else {
            payload.billing_id = '00000000-0000-0000-0000-000000000000';
        }
    }

    for (disk in payload.disks) {
        if (payload.disks.hasOwnProperty(disk)) {
            zvol = payload.disks[disk];
            if (!zvol.hasOwnProperty('model')
                && payload.hasOwnProperty('disk_driver')) {

                zvol.model = payload.disk_driver;
            }
        }
    }

    for (nic in payload.nics) {
        if (payload.nics.hasOwnProperty(nic)) {
            n = payload.nics[nic];
            if (!n.hasOwnProperty('model')
                && payload.hasOwnProperty('nic_driver')) {

                n.model = payload.nic_driver;
            }
        }
    }
}

// This function gets called for both create and update to check that payload
// properties are reasonable. If vmobj is null, create is assumed, otherwise
// update is assumed.
function checkProperties(payload, vmobj, callback)
{
    var disk;
    var field;
    var fields = ['nics', 'add_nics', 'update_nics'];
    var ips = [];
    var macs = [];
    var n;
    var nic;
    var primary_nics;
    var ram;
    var zvol;

    if (!vmobj) {
        // This is a CREATE

        // XXX some of these should also apply to update

        if (payload.brand === 'kvm'
            && payload.hasOwnProperty('available_MiB')) {

            if (payload.available_MiB < payload.ram) {
                callback(new Error('VM "ram" value: ' + payload.ram + ' is less'
                    + ' than' + ' available memory: ' + payload.available_MiB));
                return;
            } else {
                VM.log('DEBUG', 'checkProperties() memory ok: '
                    + payload.ram + ' requested and have: '
                    + payload.available_MiB);
            }
        }

        // These should have already been enforced
        if (payload.max_locked_memory > payload.max_physical_memory) {
            callback(new Error('max_locked_memory must be <= '
                + 'max_physical_memory'));
            return;
        }
        if (payload.max_swap < payload.max_physical_memory) {
            callback(new Error('max_swap must be >= max_physical_memory'));
            return;
        }

        for (disk in payload.disks) {
            if (payload.disks.hasOwnProperty(disk)) {
                zvol = payload.disks[disk];

                // TODO: also check if it exists.
                if (zvol.hasOwnProperty('zpool')
                    && !zvol.zpool.match(/^[a-z\-\_\.]+/)) {

                    callback(new Error('invalid zpool name: '
                        + zvol.zpool));
                    return;
                }

                if (payload.brand === 'kvm') {
                    if (!zvol.hasOwnProperty('model')
                        || zvol.model === 'undefined') {

                        callback(new Error('missing .model option for '
                            + 'disk: ' + JSON.stringify(zvol)));
                        return;
                    } else if (VM.DISK_MODELS.indexOf(zvol.model) === -1) {
                        callback(new Error('"' + zvol.model + '"'
                            + ' is not a valid disk model. Valid are: '
                            + VM.DISK_MODELS.join(',')));
                        return;
                    }
                }
            }
        }

        // We used to use zone_path instead of zonepath, so accept that too.
        if (payload.hasOwnProperty('zone_path')
            && !payload.hasOwnProperty('zonepath')) {

            payload.zonepath = payload.zone_path;
            delete payload.zone_path;
        }
    } else {
        // This is an UPDATE

        if (vmobj.brand === 'kvm') {
            if (payload.hasOwnProperty('ram')) {
                ram = payload.ram;
            } else {
                ram = vmobj.ram;
            }

            // ensure none of these is < ram
            if (payload.hasOwnProperty('max_physical_memory')
                && payload.max_physical_memory < ram) {

                callback(new Error('vm.max_physical_memory ('
                    + payload.max_physical_memory + ') cannot be lower than'
                    + ' vm.ram (' + ram + ')'));
                return;
            }
            if (payload.hasOwnProperty('max_locked_memory')
                && payload.max_locked_memory < ram) {

                callback(new Error('vm.max_locked_memory ('
                    + payload.max_locked_memory + ') cannot be lower than'
                    + ' vm.ram (' + ram + ')'));
                return;
            }
            // This should not be allowed anyway because max_swap will be raised
            // to match max_physical_memory if you set it lower.
            if (payload.hasOwnProperty('max_swap')
                && payload.max_swap < ram) {

                callback(new Error('vm.max_swap ('
                    + payload.max_swap + ') cannot be lower than'
                    + ' vm.ram (' + ram + ')'));
                return;
            }
        }
    }

    primary_nics = 0;
    for (field in fields) {
        field = fields[field];
        if (payload.hasOwnProperty(field)) {
            for (nic in payload[field]) {
                if (payload[field].hasOwnProperty(nic)) {
                    n = payload[field][nic];

                    // MAC will always conflict in update, since that's the key
                    if (field === 'add_nics' && n.hasOwnProperty('mac')) {
                        macs.push(n.mac);
                    }

                    if (field === 'add_nics' || field === 'update_nics') {
                        if (n.hasOwnProperty('primary')) {
                            if (n.primary !== true) {
                                callback(new Error('invalid value for NIC\'s '
                                    + 'primary flag: ' + n.primary + ' (must be'
                                    + ' true)'));
                                return;
                            }
                            primary_nics++;
                        }
                    }

                    if (n.hasOwnProperty('ip')) {
                        ips.push(n.ip);
                    }

                    if (payload.brand === 'kvm'
                        && (!n.hasOwnProperty('model')
                            || n.model === 'undefined')) {

                        callback(new Error('missing .model option for NIC: '
                            + JSON.stringify(n)));
                        return;
                    }
                }
            }
        }
    }

    // Since we always need a primary nic, don't allow a value other than true
    // for primary flag. Also ensure we're not trying to set primary for more
    // than one nic.
    if (primary_nics > 1) {
        callback(new Error('payload specifies more than 1 primary NIC'));
        return;
    }

    if (payload.brand === 'kvm') {
        if (payload.hasOwnProperty('vga')
            && VM.VGA_TYPES.indexOf(payload.vga) === -1) {

            callback(new Error('Invalid VGA type: "' + payload.vga
                + '", supported types are: ' + VM.VGA_TYPES.join(',')));
            return;
        }

        // Ensure password is not too long
        if (payload.hasOwnProperty('vnc_password')
            && payload.vnc_password.length > 8) {

            callback(new Error('VNC password is too long, maximum length is 8 '
                + 'characters.'));
            return;
        }
    }

    // Ensure MACs and IPs are not already used on this vm
    // NOTE: can't check other nodes yet.

    lookupConflicts(macs, ips, function (error, conflict) {
        if (error) {
            callback(error);
        } else {
            if (conflict) {
                callback(new Error('Conflict detected with another '
                    + 'vm, please check the MAC and IP'));
            } else {
                VM.log('DEBUG', 'no conflicts');
                callback();
            }
        }
    });
}

function addDelegatedDataset(payload, callback)
{
    var dataset;
    var zcfg = '';

    if (payload.delegate_dataset) {
        dataset = payload.zfs_filesystem + '/data';
        VM.log('DEBUG', 'adding delegated dataset ' + dataset + 'to '
            + 'vm ' + payload.uuid);

        zfs(['create', '-o', 'compression=on', dataset], function (err) {
            if (err) {
                callback(err);
            } else {
                zcfg = 'add dataset; set name=' + dataset + '; end';
                zonecfg(['-u', payload.uuid, zcfg], function (e, fds) {
                    if (e) {
                        VM.log('ERROR', 'unable to add delegated dataset to '
                            + payload.uuid + ' stderr: ' + fds.stderr, e);
                        callback(e);
                    } else {
                        callback();
                    }
                });
            }
        });
    } else {
        // no delegated dataset set, do nothing.
        callback();
    }
}

function buildAddRemoveList(vmobj, payload, type, key, updatable)
{
    var add = [];
    var add_key;
    var field;
    var newobj;
    var oldobj;
    var plural = type + 's';
    var remove = [];
    var remove_key;
    var update_key;

    // initialize some plurals
    add_key = 'add_' + plural;
    remove_key = 'remove_' + plural;
    update_key = 'update_' + plural;

    // There's no way to update properties on a disk or nic with zonecfg
    // currently.  Yes, really.  So any disks/nics that should be updated, we
    // remove then add with the new properties.
    if (payload.hasOwnProperty(update_key)) {
        for (newobj in payload[update_key]) {
            newobj = payload[update_key][newobj];
            for (oldobj in vmobj[plural]) {
                oldobj = vmobj[plural][oldobj];

                if (oldobj[key] === newobj[key]) {
                    // This is the one to update: remove and add.
                    remove.push(oldobj[key]);

                    // only some fields make sense to update.
                    for (field in updatable) {
                        field = updatable[field];
                        if (newobj.hasOwnProperty(field)) {
                            oldobj[field] = newobj[field];
                        }
                    }

                    add.push(oldobj);
                }
            }
        }
    }

    if (payload.hasOwnProperty(remove_key)) {
        for (newobj in payload[remove_key]) {
            newobj = payload[remove_key][newobj];
            remove.push(newobj);
        }
    }

    if (payload.hasOwnProperty(add_key)) {
        for (newobj in payload[add_key]) {
            newobj = payload[add_key][newobj];
            add.push(newobj);
        }
    }

    return ({'add': add, 'remove': remove});
}

function buildDiskZonecfg(vmobj, payload)
{
    var add = [];
    var disk;
    var lists;
    var remove = [];
    var zcfg = '';

    lists = buildAddRemoveList(vmobj, payload, 'disk', 'path',
        UPDATABLE_DISK_PROPS);
    remove = lists.remove;
    add = lists.add;

    // remove is a list of disk paths, add a remove for each now.
    for (disk in remove) {
        disk = remove[disk];
        zcfg = zcfg + 'remove device match=' + disk + '\n';
    }

    for (disk in add) {
        disk = add[disk];

        zcfg = zcfg + 'add device\n'
            + 'set match=' + disk.path + '\n'
            + 'add property (name=boot, value="'
            + (disk.boot ? 'true' : 'false') + '")\n'
            + 'add property (name=model, value="' + disk.model + '")\n';
        if (disk.hasOwnProperty('image_size')) {
            zcfg = zcfg
                + 'add property (name=image-size, value="'
                + disk.image_size + '")\n';
        } else if (disk.hasOwnProperty('size')) {
            zcfg = zcfg + 'add property (name=size, value="'
                + disk.size + '")\n';
        }

        if (disk.hasOwnProperty('image_uuid')) {
            zcfg = zcfg
                + 'add property (name=image-uuid, value="'
                + disk.image_uuid + '")\n';
        }

        if (disk.hasOwnProperty('image_name')) {
            zcfg = zcfg + 'add property (name=image-name, value="'
                + disk.image_name + '")\n';
        }

        zcfg = zcfg + 'end\n';
    }

    return zcfg;
}

function buildNicZonecfg(vmobj, payload)
{
    var add;
    var lists;
    var matches;
    var n;
    var new_primary;
    var nic;
    var nic_idx = 0;
    var remove;
    var updated_primary;
    var used_nic_indexes = [];
    var zcfg = '';

    if (vmobj.hasOwnProperty('nics')) {
        // check whether we're adding or updating to set the primary flag. If we
        // are also find the existing NIC with the primary flag. If that's not
        // being removed, update it to remove the primary flag.
        if (payload.hasOwnProperty('add_nics')) {
            for (nic in payload.add_nics) {
                nic = payload.add_nics[nic];
                if (nic.hasOwnProperty('primary')) {
                    new_primary = nic.mac;
                }
            }
        }
        if (payload.hasOwnProperty('update_nics')) {
            for (nic in payload.update_nics) {
                nic = payload.update_nics[nic];
                if (nic.hasOwnProperty('primary')) {
                    new_primary = nic.mac;
                }
            }
        }
        if (new_primary) {
            // find old primary
            for (nic in vmobj.nics) {
                nic = vmobj.nics[nic];
                if (nic.hasOwnProperty('primary') && nic.mac !== new_primary) {
                    // we have a new primary, so un-primary the old.
                    if (payload.hasOwnProperty('remove_nics')
                        && payload.remove_nics.indexOf(nic.mac) !== -1) {

                        // we're removing the old primary so: done.
                        break;
                    } else if (payload.hasOwnProperty('update_nics')) {
                        updated_primary = false;
                        for (n in payload.update_nics) {
                            n = payload.update_nics[n];
                            if (n.mac === nic.mac) {
                                n.primary = false;
                                updated_primary = true;
                            }
                        }
                        if (!updated_primary) {
                            payload.update_nics.push({'mac': nic.mac,
                                'primary': false});
                        }
                    } else {
                        // just add a new update to unset the
                        payload.update_nics =
                            [ {'mac': nic.mac, 'primary': false} ];
                    }
                }
            }
        }
    }

    lists = buildAddRemoveList(vmobj, payload, 'nic', 'mac',
        UPDATABLE_NIC_PROPS);
    remove = lists.remove;
    add = lists.add;

    // create a list of used indexes so we can find the free ones
    if (vmobj.hasOwnProperty('nics')) {
        for (n in vmobj.nics) {
            if (vmobj.nics[n].hasOwnProperty('interface')) {
                matches = vmobj.nics[n].interface.match(/^net(\d+)$/);
                if (matches) {
                    used_nic_indexes.push(Number(matches[1]));
                }
            }
        }
    }

    // assign next available interface for nics without one
    for (nic in add) {
        nic = add[nic];
        if (!nic.hasOwnProperty('interface')) {
            while (used_nic_indexes.indexOf(nic_idx) !== -1) {
                nic_idx++;
            }
            nic.interface = 'net' + nic_idx;
            used_nic_indexes.push(Number(nic_idx));
        }
    }

    // remove is a list of nic macs, add a remove for each now.
    for (nic in remove) {
        nic = remove[nic];
        zcfg = zcfg + 'remove net mac-addr=' + ruinMac(nic) + '\n';
    }

    for (nic in add) {
        nic = add[nic];

        zcfg = zcfg
            + 'add net\n'
            + 'set physical=' + nic.interface + '\n'
            + 'set mac-addr=' + ruinMac(nic.mac) + '\n';

        if (nic.hasOwnProperty('nic_tag')) {
            zcfg = zcfg + 'set global-nic=' + nic.nic_tag + '\n';
        }

        if (nic.hasOwnProperty('ip')) {
            zcfg = zcfg + 'add property (name=ip, value="' + nic.ip + '")\n';
        }

        if (nic.hasOwnProperty('netmask')) {
            zcfg = zcfg + 'add property (name=netmask, value="'
                + nic.netmask + '")\n';
        }

        if (nic.hasOwnProperty('gateway') && nic.gateway.length > 0) {
            zcfg = zcfg + 'add property (name=gateway, value="'
                + nic.gateway + '")\n';
        }

        if (nic.hasOwnProperty('model')) {
            zcfg = zcfg + 'add property (name=model, value="'
                + nic.model + '")\n';
        }

        if (nic.hasOwnProperty('primary') && nic.primary) {
            zcfg = zcfg + 'add property (name=primary, value="true")\n';
        }

        if (nic.hasOwnProperty('vlan_id') && (nic.vlan_id !== '0')) {
            zcfg = zcfg + 'set vlan-id=' + nic.vlan_id + '\n';
        }

        if (nic.hasOwnProperty('dhcp_server')) {
            zcfg = zcfg + 'add property (name=dhcp_server, value="'
                + nic.dhcp_server + '")\n';
        }

        if (nic.hasOwnProperty('blocked_outgoing_ports')) {
            zcfg = zcfg
                + 'add property (name=blocked-outgoing-ports, value="'
                + nic.blocked_outgoing_ports.join(',') + '")\n';
        }

        zcfg = zcfg + 'end\n';
    }

    return zcfg;
}

function buildFilesystemZonecfg(vmobj, payload)
{
    var add = [];
    var filesystem;
    var lists;
    var opt;
    var remove = [];
    var zcfg = '';

    lists = buildAddRemoveList(vmobj, payload, 'filesystem', 'target', []);
    remove = lists.remove;
    add = lists.add;

    // remove is a list of disk paths, add a remove for each now.
    for (filesystem in remove) {
        filesystem = remove[filesystem];
        zcfg = zcfg + 'remove fs match=' + filesystem + '\n';
    }

    for (filesystem in add) {
        filesystem = add[filesystem];

        zcfg = zcfg + 'add fs\n' + 'set dir=' + filesystem.target + '\n'
            + 'set special=' + filesystem.source + '\n' + 'set type='
            + filesystem.type + '\n';
        if (filesystem.hasOwnProperty('raw')) {
            zcfg = zcfg + 'set raw=' + filesystem.raw + '\n';
        }
        if (filesystem.hasOwnProperty('options')) {
            for (opt in filesystem.options) {
                opt = filesystem.options[opt];
                zcfg = zcfg + 'add options "' + opt + '"\n';
            }
        }
        zcfg = zcfg + 'end\n';
    }

    return zcfg;
}

function buildZonecfgUpdate(vmobj, payload)
{
    var tmp;
    var zcfg = '';

    VM.log('DEBUG', 'vmobj:\n' + JSON.stringify(vmobj, null, 2));
    VM.log('DEBUG', 'payload:\n' + JSON.stringify(payload, null, 2));

    // Global properties can just be set, no need to clear anything first.
    if (payload.hasOwnProperty('cpu_shares')) {
        zcfg = zcfg + 'set cpu-shares=' + payload.cpu_shares.toString() + '\n';
    }
    if (payload.hasOwnProperty('zfs_io_priority')) {
        zcfg = zcfg + 'set zfs-io-priority='
            + payload.zfs_io_priority.toString() + '\n';
    }
    if (payload.hasOwnProperty('max_lwps')) {
        zcfg = zcfg + 'set max-lwps=' + payload.max_lwps.toString() + '\n';
    }
    if (payload.hasOwnProperty('limit_priv')) {
        zcfg = zcfg + 'set limitpriv="' + payload.limit_priv + '"\n';
    }
    if (payload.hasOwnProperty('autoboot') && payload.brand === 'joyent') {
        // kvm autoboot is managed by the vm-autoboot attr instead
        zcfg = zcfg + 'set autoboot=' + payload.autoboot.toString() + '\n';
    }

    // Capped Memory properties are special
    if (payload.hasOwnProperty('max_physical_memory')
        || payload.hasOwnProperty('max_locked_memory')
        || payload.hasOwnProperty('max_swap')) {

        // Capped memory parameters need either an add or select first.
        if (vmobj.hasOwnProperty('max_physical_memory')
            || vmobj.hasOwnProperty('max_locked_memory')
            || vmobj.hasOwnProperty('max_swap')) {

            // there's already a capped-memory section, use that.
            zcfg = zcfg + 'select capped-memory; ';
        } else {
            zcfg = zcfg + 'add capped-memory; ';
        }

        if (payload.hasOwnProperty('max_physical_memory')) {
            zcfg = zcfg + 'set physical='
                + payload.max_physical_memory.toString() + 'm; ';
        }
        if (payload.hasOwnProperty('max_locked_memory')) {
            zcfg = zcfg + 'set locked='
                + payload.max_locked_memory.toString() + 'm; ';
        }
        if (payload.hasOwnProperty('max_swap')) {
            zcfg = zcfg + 'set swap='
                + payload.max_swap.toString() + 'm; ';
        }

        zcfg = zcfg + 'end\n';
    }

    // Capped CPU is special
    if (payload.hasOwnProperty('cpu_cap')) {
        if (vmobj.hasOwnProperty('cpu_cap')) {
            zcfg = zcfg + 'select capped-cpu; ';
        } else {
            zcfg = zcfg + 'add capped-cpu; ';
        }

        zcfg = zcfg + 'set ncpus='
            + (Number(payload.cpu_cap) * 0.01).toString() + '; end\n';
    }

    // set to empty string so property is removed when not true
    if (payload.hasOwnProperty('do_not_inventory')) {
        if (payload.do_not_inventory !== 'true') {
            payload.do_not_inventory = '';
        }
    }

    // Attributes
    function setAttr(attr, attr_name, value) {
        if (!value) {
            value = payload[attr_name];
        }

        if (payload.hasOwnProperty(attr_name)) {
            if ((typeof (value) !== 'boolean')
                && (!value || trim(value.toString()) === '')) {

                // empty values we either remove or ignore.
                if (vmobj.hasOwnProperty(attr_name)) {
                    zcfg = zcfg + 'remove attr name=' + attr + ';';
                    // else do nothing, we don't add empty values.
                }
            } else {
                if (vmobj.hasOwnProperty(attr_name)) {
                    zcfg = zcfg + 'select attr name=' + attr + '; ';
                } else {
                    zcfg = zcfg + 'add attr; set name="' + attr + '"; '
                        + 'set type=string; ';
                }
                zcfg = zcfg + 'set value="' + value.toString() + '"; end\n';
            }
        }
    }
    setAttr('billing-id', 'billing_id');
    setAttr('owner-uuid', 'owner_uuid');
    setAttr('package-name', 'package_name');
    setAttr('package-version', 'package_version');
    setAttr('tmpfs', 'tmpfs');
    setAttr('hostname', 'hostname');
    setAttr('dns-domain', 'dns_domain');
    setAttr('default-gateway', 'default_gateway');
    setAttr('do-not-inventory', 'do_not_inventory');

    if (payload.hasOwnProperty('resolvers')) {
        setAttr('resolvers', 'resolvers', payload.resolvers.join(','));
    }
    if (payload.hasOwnProperty('alias')) {
        tmp = '';
        if (payload.alias) {
            tmp = new Buffer(payload.alias).toString('base64');
        }
        setAttr('alias', 'alias', tmp);
    }

    // KVM specific attrs
    if (vmobj.brand === 'kvm' || payload.brand === 'kvm') {
        setAttr('vm-autoboot', 'autoboot');
        setAttr('ram', 'ram');
        setAttr('vcpus', 'vcpus');
        setAttr('boot', 'boot');
        setAttr('cpu-type', 'cpu_type');
        setAttr('vga', 'vga');
        setAttr('vnc-port', 'vnc_port');

        // we use base64 here for these next three options, since these can
        // contain characters zonecfg doesn't like.
        if (payload.hasOwnProperty('vnc_password')) {
            if (payload.vnc_password === ''
                && (vmobj.hasOwnProperty('vnc_password')
                && vmobj.vnc_password !== '')) {

                VM.log('WARN', 'Warning: VNC password was removed for VM '
                    + vmobj.uuid + ' but VM needs to be restarted for change to'
                    + 'take effect.');
            }
            if (payload.vnc_password.length > 0
                && !vmobj.hasOwnProperty('vnc_password')) {

                VM.log('WARN', 'Warning: VNC password was added to VM '
                    + vmobj.uuid + ' but VM needs to be restarted for change to'
                    + 'take effect.');
            }

            setAttr('vnc-password', 'vnc_password',
                new Buffer(payload.vnc_password).toString('base64'));
        }
        if (payload.hasOwnProperty('qemu_opts')) {
            setAttr('qemu-opts', 'qemu_opts',
                new Buffer(payload.qemu_opts).toString('base64'));
        }
        if (payload.hasOwnProperty('qemu_extra_opts')) {
            setAttr('qemu-extra-opts', 'qemu_extra_opts',
                new Buffer(payload.qemu_extra_opts).toString('base64'));
        }

        // Handle disks (VMs only)
        zcfg = zcfg + buildDiskZonecfg(vmobj, payload);
    } else {
        // brand=joyent specific attrs
        if (payload.hasOwnProperty('fs_allowed')) {
            if (payload.fs_allowed === '') {
                zcfg = zcfg + 'clear fs-allowed\n';
            } else {
                zcfg = zcfg + 'set fs-allowed="' + payload.fs_allowed + '"\n';
            }
        }
        zcfg = zcfg + buildFilesystemZonecfg(vmobj, payload);
    }

    zcfg = zcfg + buildNicZonecfg(vmobj, payload);

    return zcfg;
}

// create and install a 'joyent' or 'kvm' brand zone.
function createZone(payload, callback)
{
    var now = new Date;
    var zcfg;

    VM.log('DEBUG', 'createZone()');

    if (payload.brand === 'joyent' && !payload.hasOwnProperty('dataset_uuid')) {
        callback(new Error('createZone(): FAILED -- dataset_uuid is '
            + 'required.'));
        return;
    }

    payload.zfs_filesystem = payload.zfs_storage_pool_name + '/'
        + payload.zonename;
    payload.zonepath = '/' + payload.zfs_filesystem;

    // set the properties that can't be updated later here.
    zcfg = 'create -b\n'
        + 'set zonepath=' + payload.zonepath + '\n'
        + 'set brand=' + payload.brand + '\n'
        + 'set uuid=' + payload.uuid + '\n'
        + 'set ip-type=exclusive\n'
        + 'add attr; set name="create-timestamp"; set type=string; set value="'
        + now.toISOString() + '"; end\n';

    if (payload.hasOwnProperty('dataset_uuid')) {
        zcfg = zcfg + 'add attr; set name="dataset-uuid"; set type=string; '
            + 'set value="' + payload.dataset_uuid + '"; end\n';
    }

    // if do_not_inventory is set, we don't don't want there to be a window
    // where the VM might get accidentally imported.
    if (payload.hasOwnProperty('do_not_inventory')
        && payload.do_not_inventory) {

        zcfg = zcfg + 'add attr; set name="do-not-inventory"; set type=string; '
            + 'set value="true"; end\n';
    }

    if (payload.brand === 'kvm') {
        // we always set autoboot=false for VM zones, since we want vmadmd to
        // boot them and not the zones tools.  Use vm-autoboot to control VMs
        zcfg = zcfg + 'set autoboot=false\n';
    }

    // move disk and NIC properties to add_* so they get added.
    if (payload.hasOwnProperty('disks')) {
        payload.add_disks = payload.disks;
        delete payload.disks;
    }
    if (payload.hasOwnProperty('nics')) {
        payload.add_nics = payload.nics;
        delete payload.nics;
    }
    if (payload.hasOwnProperty('filesystems')) {
        payload.add_filesystems = payload.filesystems;
        delete payload.filesystems;
    }

    // ensure that we have a primary nic, even if one wasn't specified
    if (payload.hasOwnProperty('add_nics') && payload.add_nics.length != 0) {
        var n;
        var primary_found = false;

        for (n in payload.add_nics) {
            if (n.hasOwnProperty('primary') && n.primary) {
                primary_found = true;
                break;
            }
        }
        if (!primary_found) {
            payload.add_nics[0].primary = true;
        }
    }

    // Passing an empty first parameter here, tells buildZonecfgUpdate that
    // we're talking about a new machine.
    zcfg = zcfg + buildZonecfgUpdate({}, payload);

    async.series([
        function (cb) {
            // send the zonecfg data we just generated as a file to zonecfg,
            // this will create the zone.
            zonecfgFile(zcfg, ['-z', payload.zonename], function (err, fds) {
                cb(err);
            });
        }, function (cb) {
            // Install the zone.  This will create the dataset and mark the zone
            // 'installed'.
            var args = ['-z', payload.zonename, 'install', '-q',
                payload.quota.toString()];

            if (payload.brand === 'joyent' || (payload.brand === 'kvm'
                && payload.hasOwnProperty('zone_dataset_uuid'))) {

                args.push('-t');
                if (payload.brand === 'joyent') {
                    args.push(payload.dataset_uuid);
                } else {
                    args.push(payload.zone_dataset_uuid);
                }
                args.push('-x');
                args.push('nodataset');
            }

            zoneadm(args, function (err, fds) {
                if (err) {
                    VM.log('ERROR', 'zoneadm failed to install: '
                        + JSON.stringify(fds), err);
                    cb(err);
                } else {
                    cb();
                }
            });
        }, function (cb) {
            // Write out the zone's metadata
            saveMetadata(payload, function (err) {
                if (err) {
                    VM.log('ERROR', 'unable to save metadata: ' + err.message,
                        err);
                    cb(err);
                } else {
                    cb();
                }
            });
        }, function (cb) {
            // This writes out the 'zoneconfig' file used by zoneinit to root's
            // home directory in the zone.
            if (payload.brand === 'joyent') {
                writeZoneconfig(payload, function (err, result) {
                    if (err) {
                        cb(err);
                    } else {
                        cb();
                    }
                });
            } else {
                cb();
            }
        }, function (cb) {
            // Joyent branded zones can have an additional 'data' dataset
            // delegated to them for use in the zone.  This will set that up.
            if (payload.brand === 'joyent') {
                addDelegatedDataset(payload, function (err) {
                    if (err) {
                        cb(err);
                    } else {
                        cb();
                    }
                });
            } else {
                cb();
            }
        }, function (cb) {
            // The vm is now ready to start, we'll start if autoboot is set.
            if (payload.autoboot) {
                VM.start(payload.uuid, {}, function (err, res) {
                    if (err) {
                        cb(err);
                    } else {
                        cb();
                    }
                });
            } else {
                cb();
            }
        }, function (cb) {
            // zoneinit runs in joyent branded zones and the zone is not
            // considered provisioned until it's rebooted once.
            if (payload.brand !== 'joyent' || !payload.autoboot
                || payload.nowait) {

                cb();
                return;
            }

            waitForJoyentZone(payload, function (err, result) {
                if (err) {
                    execFile('/usr/bin/ptree', ['-z', payload.zonename],
                        function (error, stdout, stderr) {
                            if (error) {
                                VM.log('ERROR', 'unable to get ptree from '
                                    + payload.uuid + ': ' + stderr);
                            } else {
                                VM.log('WARN', 'processes running in '
                                    + payload.uuid + ' at fail time:\n'
                                    + stdout);
                            }
                            VM.log('WARN', 'zoneinit failed, zone is being '
                                + 'stopped for manual investigation.', err);
                            VM.stop(payload.uuid, {'force': true}, function () {
                                // ignore errors because there's nothing to do
                                cb(err);
                            });
                        }
                    );
                } else {
                    cb();
                }
            });
        }], function (error) {
            callback(error);
        }
    );
}

function normalizeNics(payload)
{
    var field;
    var fields = ['nics', 'add_nics'];
    var n;
    var nic;

    // ensure all NICs being created/added have a MAC, remove the 'index' if it
    // is passed (that's deprecated), rename 'interface' to 'physical'.
    for (field in fields) {
        field = fields[field];
        if (payload.hasOwnProperty(field)) {
            for (n in payload[field]) {
                if (payload[field].hasOwnProperty(n)) {
                    nic = payload[field][n];
                    if (!nic.hasOwnProperty('mac')) {
                        nic.mac = generateMAC();
                    }
                    delete nic.index;
                    if (nic.hasOwnProperty('interface')) {
                        nic.physical = nic.interface;
                        delete nic.interface;
                    }
                }
            }
        }
    }
}

function normalizePayload(payload, callback)
{
    normalizeNics(payload);
    applyZoneDefaults(payload);

    // Fix types for boolean fields in case someone put in 'false'/'true'
    // instead of false/true
    if (payload.hasOwnProperty('autoboot')
        && typeof (payload.autoboot) !== 'boolean') {

        payload.autoboot = fixBoolean(payload.autoboot.toString());
    }
    if (payload.hasOwnProperty('delegate_dataset')
        && typeof (payload.delegate_dataset) !== 'boolean') {

        payload.delegate_dataset =
            fixBoolean(payload.delegate_dataset.toString());
    }
    if (payload.hasOwnProperty('nowait')
        && typeof (payload.nowait) !== 'boolean') {

        payload.nowait = fixBoolean(payload.nowait.toString());
    }
    if (payload.hasOwnProperty('do_not_inventory')
        && typeof (payload.do_not_inventory) !== 'boolean') {

        payload.do_not_inventory =
            fixBoolean(payload.do_not_inventory.toString());
    }

    system.getProvisionableMemory(function (err, available_MiB) {
        if (err) {
            VM.log('WARN', 'unable to determine system memory '
                + 'usage, assuming we have sufficient memory.');
            payload.available_MiB = payload.ram;
        } else {
            payload.available_MiB = available_MiB;
        }
        checkProperties(payload, null, function (e) {
            if (e) {
                callback(e);
            } else {
                callback();
            }
        });
    });
}

function unsetTransition(m, callback)
{
    zonecfg(['-u', m.uuid, 'remove attr name=transition'], function (err, fds) {
        if (err) {
            VM.log('ERROR', 'unable to remove transition for zone '
                + m.uuid + ' stderr: ' + fds.stderr, err);
        }
        // We don't error here because we want to be idempotent.

        if (m.transition_to && m.transition_to === 'start') {
            VM.log('DEBUG', 'vm was stopping for reboot, '
                + 'transitioning to start.');
            VM.start(m.uuid, {}, function (e) {
                if (e) {
                    VM.log('ERROR', 'failed to start when clearing '
                        + 'transition', e);
                }
            });
        }

        callback();
    });
}

function setTransition(m, transition, target, timeout, callback)
{
    if (!timeout) {
        callback(new Error('setTransition() requires timeout argument.'));
        return;
    }

    async.series([
        function (cb) {
            if (m.hasOwnProperty('transition')) {
                unsetTransition(m, cb);
            } else {
                cb();
            }
        }, function (cb) {
            zonecfg(['-u', m.uuid, 'add attr; set name=transition; set value="'
                + transition + ':' + target + ':'
                + (Date.now() + timeout).toString()
                + '"; set type=string; end'], function () {

                // TODO: handle errors

                VM.log('DEBUG', 'setting transition=' + transition
                    + ' for vm ' + m.uuid);

                cb();
            });
        }
    ], function (error) {
        callback(error);
    });
}

exports.create = function (payload, callback)
{
    VM.resetLog('create');

    VM.log('INFO', 'Creating zone with payload:\n'
        + JSON.stringify(payload, null, 2));

    normalizePayload(payload, function (err) {
        if (err) {
            callback(err);
            return;
        }
        VM.log('DEBUG', 'Used payload:\n' + JSON.stringify(payload, null, 2));
        if (payload.brand === 'kvm') {
            createZoneUUID(payload, function (e, uuid) {
                if (e) {
                    callback(e);
                } else {
                    createVM(payload, function (error, result) {
                        if (error) {
                            callback(error);
                        } else {
                            callback(null, {'uuid': payload.uuid,
                                'zonename': payload.zonename});
                        }
                    });
                }
            });
        } else if (payload.brand === 'joyent') {
            createZoneUUID(payload, function (e, uuid) {
                if (e) {
                    callback(e);
                } else {
                    createZone(payload, function (error, result) {
                        if (error) {
                            callback(error);
                        } else {
                            callback(null, {'uuid': payload.uuid,
                                'zonename': payload.zonename});
                        }
                    });
                }
            });
        } else {
            callback(new Error('Don\'t know how to create a "'
                + payload.brand + '"'));
        }
    });
};

// delete a zvol
function deleteVolume(volume, callback)
{
    var args = ['destroy', '-F', volume.zfs_filesystem];

    zfs(args, function (err, fds) {
        // err will be non-null if something broke
        callback(err);
    });
}

exports.delete = function (uuid, callback)
{
    var zoneobj;

    VM.resetLog('delete');
    VM.log('INFO', 'Deleting VM ' + uuid);

    async.series([
        function (cb) {
            VM.load(uuid, function (err, obj) {
                if (err) {
                    cb(err);
                }
                zoneobj = obj;
                cb();
            });
        }, function (cb) {
            VM.log('DEBUG', 'setting autoboot=false');
            zonecfg(['-u', uuid, 'set autoboot=false'], function () {
                // TODO: log error?
                cb();
            });
        }, function (cb) {
            VM.log('DEBUG', 'halting zone');
            zoneadm(['-u', uuid, 'halt', '-X'], function () {
                // TODO: log error?
                cb();
            });
        }, function (cb) {
            VM.log('DEBUG', 'uninstalling zone');
            zoneadm(['-u', uuid, 'uninstall', '-F'], function () {
                // TODO: log error?
                cb();
            });
        }, function (cb) {
            if (zoneobj && zoneobj.brand === 'kvm') {
                async.forEachSeries(zoneobj.disks, deleteVolume,
                    function (err) {

                    if (err) {
                        VM.log('ERROR', 'unknown error deleting volumes', err);
                        cb(err);
                    } else {
                        VM.log('INFO', 'successfully deleted volumes');
                        cb();
                    }
                });
            } else {
                VM.log('DEBUG', 'skipping volume destruction for '
                    + 'non-VM ' + zoneobj.uuid);
                cb();
            }
        }, function (cb) {
            if (zoneobj.zonename) {
                VM.log('DEBUG', 'deleting zone');
                // XXX for some reason -u <uuid> doesn't work with delete
                zonecfg(['-z', zoneobj.zonename, 'delete', '-F'], function () {
                    cb();
                });
            } else {
                cb();
            }
        }
    ], function (error) {
        callback(error);
    });
};

function startZone(zoneobj, callback)
{
    var set_autoboot = 'set autoboot=true';
    var uuid = zoneobj.uuid;

    VM.log('DEBUG', 'startZone starting ' + uuid);

    //
    // We set autoboot (or vm-autoboot) here because we've just intentionally
    // started this vm, so we want it to come up if the host is rebooted.
    //
    if (zoneobj.brand === 'kvm') {
        set_autoboot = 'select attr name=vm-autoboot; set value=true; end';
    }

    zoneadm(['-u', uuid, 'boot'], function (err, boot_fds) {
        if (err) {
            VM.log('ERROR', err.message, err);
            callback(err);
            return;
        }
        zonecfg(['-u', uuid, set_autoboot], function (e, autoboot_fds) {
            if (e) {
                // The vm is running at this point, erroring out here would
                // do no good, so we just log it.
                VM.log('ERROR', 'startVM(): Failed to ' + set_autoboot
                    + ' for ' + uuid, e);
            }

            if (zoneobj.never_booted) {
                zonecfg(['-u', uuid, 'remove attr name=never-booted' ],
                    function (error, neverbooted_fds) {
                        // Ignore errors here, because we're started.
                        if (error) {
                            VM.log('WARN', 'failed to remove '
                                + 'never-booted flag for ' + uuid, error);
                        }
                        callback();
                    }
                );
            } else {
                VM.log('NOTICE', 'Started ' + uuid);
                callback();
            }
        });
    });
}

// build the qemu cmdline and start up a VM
function startVM(vmobj, extra, callback)
{
    var check_path;
    var cmdargs = [];
    var d;
    var defaultgw = '';
    var disk;
    var diskargs = '';
    var disk_idx = 0;
    var found;
    var hostname = vmobj.uuid;
    var nic;
    var nic_idx = 0;
    var primary_found = false;
    var qemu_opts = '';
    var r;
    var script;
    var uuid = vmobj.uuid;
    var vnic_opts;

    VM.log('DEBUG', 'startVM(' + uuid + ')');

    if (vmobj.hasOwnProperty('state') && vmobj.state !== 'stopped') {
        callback(new Error('Cannot start VM from state: ' + vmobj.state
            + ', must be "stopped"'));
        return;
    }

    // XXX TODO: validate vmobj data is ok to start

    cmdargs.push('-m', vmobj.ram);
    cmdargs.push('-name', vmobj.uuid);
    cmdargs.push('-uuid', vmobj.uuid);

    if (vmobj.hasOwnProperty('cpu_type')) {
        cmdargs.push('-cpu', vmobj.cpu_type);
    } else {
        cmdargs.push('-cpu', 'qemu64');
    }

    if (vmobj.vcpus > 1) {
        cmdargs.push('-smp', vmobj.vcpus);
    }

    for (disk in vmobj.disks) {
        if (vmobj.disks.hasOwnProperty(disk)) {
            disk = vmobj.disks[disk];
            if (!disk.media) {
                disk.media = 'disk';
            }
            diskargs = 'file=' + disk.path + ',if=' + disk.model
                + ',index=' + disk_idx + ',media=' + disk.media;
            if (disk.boot) {
                diskargs = diskargs + ',boot=on';
            }
            cmdargs.push('-drive', diskargs);
            disk_idx++;
        }
    }

    // extra payload can include additional disks that we want to include only
    // on this one boot.  It can also contain a boot parameter to control boot
    // device.  See qemu http://qemu.weilnetz.de/qemu-doc.html for info on
    // -boot options.
    if (extra.hasOwnProperty('disks')) {
        for (disk in extra.disks) {
            if (extra.disks.hasOwnProperty(disk)) {
                disk = extra.disks[disk];

                // ensure this is either a disk that gets mounted in or a
                // file that's been dropped in to the zonepath
                found = false;
                for (d in vmobj.disks) {
                    if (!found && vmobj.disks.hasOwnProperty(d)) {
                        d = vmobj.disks[d];
                        if (d.path === disk.path) {
                            found = true;
                        }
                    }
                }
                check_path = path.join(vmobj.zonepath, 'root', disk.path);
                if (!found && path.existsSync(check_path)) {
                    found = true;
                }
                if (!found) {
                    callback(new Error('Cannot find disk: ' + disk.path));
                    return;
                }

                if (!disk.media) {
                    disk.media = 'disk';
                }
                diskargs = 'file=' + disk.path + ',if=' + disk.model
                    + ',index=' + disk_idx + ',media=' + disk.media;
                if (disk.boot) {
                    diskargs = diskargs + ',boot=on';
                }
                cmdargs.push('-drive', diskargs);
                disk_idx++;
            }
        }
    }

    // helpful values:
    // order=nc (network boot, then fallback to disk)
    // once=d (boot on disk once and the fallback to default)
    // order=c,once=d (boot on CDROM this time, but not subsequent boots)
    if (extra.hasOwnProperty('boot')) {
        cmdargs.push('-boot', extra.boot);
    } else if (vmobj.hasOwnProperty('boot')) {
        cmdargs.push('-boot', vmobj.boot);
    } else {
        // order=cd means try harddisk first (c) and cdrom if that fails (d)
        cmdargs.push('-boot', 'order=cd');
    }

    if (vmobj.hasOwnProperty('hostname')) {
        hostname = vmobj.hostname;
    }

    if (vmobj.hasOwnProperty('default-gateway')) {
        defaultgw = vmobj['default-gateway'];
    }

    for (nic in vmobj.nics) {
        if (vmobj.nics.hasOwnProperty(nic)) {
            nic = vmobj.nics[nic];
            cmdargs.push('-net',
                'nic,macaddr=' + nic.mac
                + ',vlan=' + nic_idx
                + ',name=net' + nic_idx
                + ',model=' + nic.model);
            vnic_opts = 'vnic,name=net' + nic_idx
                + ',vlan=' + nic_idx
                + ',ifname=net' + nic_idx;

            if (nic.ip != 'dhcp') {
                vnic_opts = vnic_opts
                    + ',ip=' + nic.ip
                    + ',netmask=' + nic.netmask;
            }

            // The primary network provides the resolvers, default gateway
            // and hostname to prevent vm from trying to use settings
            // from more than one nic
            if (!primary_found) {
                if (nic.hasOwnProperty('primary') && nic.primary) {
                    if (nic.hasOwnProperty('gateway') && nic.ip != 'dhcp') {
                        vnic_opts += ',gateway_ip=' + nic.gateway;
                    }
                    primary_found = true;
                } else if (defaultgw && nic.hasOwnProperty('gateway')
                    && nic.gateway == defaultgw) {

                    if (nic.ip != 'dhcp') {
                        vnic_opts += ',gateway_ip=' + nic.gateway;
                    }
                    primary_found = true;
                }

                if (primary_found && nic.ip != 'dhcp') {
                    if (hostname) {
                        vnic_opts += ',hostname=' + hostname;
                    }
                    if (vmobj.hasOwnProperty('resolvers')) {
                        for (r in vmobj.resolvers) {
                            vnic_opts += ',dns_ip' + r + '='
                                + vmobj.resolvers[r];
                        }
                    }
                }
            }

            cmdargs.push('-net', vnic_opts);
            nic_idx++;
        }
    }

    cmdargs.push('-smbios', 'type=1,manufacturer=Joyent,'
        + 'product=SmartDC HVM,version=6.2012Q1,'
        + 'serial=' + vmobj.uuid + ',uuid=' + vmobj.uuid + ','
        + 'sku=001,family=Virtual Machine');

    cmdargs.push('-pidfile', '/tmp/vm.pid');

    if (vmobj.hasOwnProperty('vga')) {
        cmdargs.push('-vga', vmobj.vga);
    } else {
        cmdargs.push('-vga', 'cirrus');
    }

    cmdargs.push('-chardev',
        'socket,id=qmp,path=/tmp/vm.qmp,server,nowait');
    cmdargs.push('-qmp', 'chardev:qmp');

    // serial0 is for serial console
    cmdargs.push('-chardev',
        'socket,id=serial0,path=/tmp/vm.console,server,nowait');
    cmdargs.push('-serial', 'chardev:serial0');

    // serial1 is used for metadata API
    cmdargs.push('-chardev',
        'socket,id=serial1,path=/tmp/vm.ttyb,server,nowait');
    cmdargs.push('-serial', 'chardev:serial1');

    if (!vmobj.qemu_opts) {
        if (vmobj.hasOwnProperty('vnc_password')
            && vmobj.vnc_password.length > 0) {

            cmdargs.push('-vnc', 'unix:/tmp/vm.vnc,password');
        } else {
            cmdargs.push('-vnc', 'unix:/tmp/vm.vnc');
        }
        cmdargs.push('-parallel', 'none');
        cmdargs.push('-usb');
        cmdargs.push('-usbdevice', 'tablet');
        cmdargs.push('-k', 'en-us');
    } else {
        qemu_opts = vmobj.qemu_opts.toString();
    }

    if (vmobj.qemu_extra_opts) {
        qemu_opts = qemu_opts + ' ' + vmobj.qemu_extra_opts;
    }

    // This actually creates the qemu process
    script = '#!/usr/bin/bash\n\n'
        + 'exec >/tmp/vm.startvm.log 2>&1\n\n'
        + 'set -o xtrace\n\n'
        + 'if [[ -x /startvm.zone ]]; then\n'
        + '    exec /smartdc/bin/qemu-exec /startvm.zone "'
        + cmdargs.join('" "')
        + '" ' + qemu_opts + '\n'
        + 'else\n'
        + '    exec /smartdc/bin/qemu-exec /smartdc/bin/qemu-system-x86_64 "'
        + cmdargs.join('" "')
        + '" ' + qemu_opts + '\n'
        + 'fi\n\n'
        + 'exit 1\n';

    fs.writeFileSync(vmobj.zonepath + '/root/startvm', script);
    fs.chmodSync(vmobj.zonepath + '/root/startvm', '0755');

    startZone(vmobj, callback);
}

exports.start = function (uuid, extra, callback)
{
    var zoneobj;

    VM.resetLog('start');
    VM.log('INFO', 'Starting VM ' + uuid);

    VM.load(uuid, function (err, obj) {
        if (err) {
            callback(err);
        } else {
            if (obj.state !== 'stopped') {
                err = new Error('Cannot to start vm from state "' + obj.state
                    + '", must be "stopped".');
                VM.log('ERROR', err.message, err);
                callback(err);
                return;
            }
            zoneobj = obj;
            if (zoneobj.hasOwnProperty('brand') && zoneobj.brand === 'joyent') {
                // TODO: warning if 'extra' is non-empty
                startZone(zoneobj, callback);
            } else if (zoneobj.hasOwnProperty('brand')
                && zoneobj.brand === 'kvm') {

                startVM(zoneobj, extra, callback);
            } else {
                err = new Error('no idea how to start a vm with brand: '
                    + zoneobj.brand);
                VM.log('ERROR', err.message, err);
                callback(err);
            }
        }
    });
};

function setRctl(zonename, rctl, value, callback)
{
    var args;

    args = ['-n', rctl, '-v', value.toString(), '-r', '-i', 'zone', zonename];
    VM.log('DEBUG', '/usr/bin/prctl ' + args.join(' '));
    execFile('/usr/bin/prctl', args, function (error, stdout, stderr) {
        if (error) {
            VM.log('ERROR', 'setRctl() failed with: ' + stderr, error);
            callback(error);
        } else {
            callback();
        }
    });
}

function resizeTmp(zonename, newsize, callback)
{
    var args;
    var newvfsline = 'swap        -   /tmp                tmpfs    -   yes    '
        + 'size=' + newsize + 'm';
    var vfsreplace = '"s|^swap.*/tmp.*tmpfs.*size=.*$|' + newvfsline + '|"';

    args = [zonename, '/usr/sbin/mount', '-F', 'tmpfs', '-o', 'remount,size='
        + newsize + 'm', '/tmp'];
    VM.log('DEBUG', '/usr/sbin/zlogin ' + args.join(' '));
    execFile('/usr/sbin/zlogin', args, function (err, mnt_stdout, mnt_stderr) {
        if (err) {
            VM.log('ERROR', 'zlogin for ' + zonename + ' exited with code'
                + err.code + ' stdout: "' + mnt_stdout + '" stderr:"'
                + mnt_stderr + '"', err);
            // error here is not fatal as we want to still try to fix for next
            // reboot.
        }

        args = [zonename, '/usr/bin/sed', '-i', '""', '-e', vfsreplace,
            '/etc/vfstab'];
        VM.log('DEBUG', '/usr/sbin/zlogin ' + args.join(' '));
        execFile('/usr/sbin/zlogin', args,
            function (e, sed_stdout, sed_stderr) {

                if (e) {
                    VM.log('ERROR', 'zlogin for ' + zonename + ' exited with '
                        + 'code ' + e.code + ' stdout: "' + sed_stdout
                        + '" stderr:"' + sed_stderr + '"', e);
                    // error here is not fatal as there's nothing really to do
                    // about it.
            }
            callback();
        });
    });
}

function resizeDisks(disks, updates, callback)
{
    var d;
    var disk;
    var vols = [];

    for (disk in updates) {
        disk = updates[disk];
        for (d in disks) {
            d = disks[d];
            if (d.path === disk.path && disk.hasOwnProperty('size')) {
                vols.push({'disk': d, 'new_size': disk.size});
            }
        }
    }

    function resize(vol, cb) {
        var args;
        var dsk = vol.disk;
        var size = vol.new_size;

        if (dsk.hasOwnProperty('zfs_filesystem')) {
            if (dsk.size > size) {
                cb(new Error('cannot resize ' + dsk.zfs_filesystem
                    + ' new size must be greater than current size. ('
                    + dsk.size + ' > ' + dsk.size + ')'));
            } else if (dsk.size === size) {
                // no point resizing if the old+new are the same
                cb();
            } else {
                args = ['set', 'volsize=' + size + 'M', dsk.zfs_filesystem];
                zfs(args, function (err, fds) {
                    cb(err);
                });
            }
        } else {
            cb(new Error('could not find zfs_filesystem in '
                + JSON.stringify(dsk)));
        }
    }

    async.forEachSeries(vols, resize, function (err) {
        if (err) {
            VM.log('ERROR', 'Unable to resize disks', err);
            callback(err);
        } else {
            callback();
        }
    });
}

function applyUpdates(oldobj, newobj, payload, callback)
{
    // Note: oldobj is the VM *before* the update, newobj *after*

    async.series([
        function (cb) {
            if (payload.hasOwnProperty('update_disks')
                && oldobj.hasOwnProperty('disks')) {

                resizeDisks(oldobj.disks, payload.update_disks, cb);
            } else {
                cb();
            }
        }, function (cb) {
            if (payload.hasOwnProperty('quota')) {
                setQuota(newobj.zfs_filesystem, payload.quota, cb);
            } else {
                cb();
            }
        }, function (cb) {
            var filename;
            var n;

            for (n in newobj.nics) {
                n = newobj.nics[n];

                filename = newobj.zonepath + '/root/etc/hostname.'
                    + n.interface;
                if (n.ip !== 'dhcp') {
                    fs.writeFileSync(filename, n.ip + ' netmask ' + n.netmask
                        + ' up' + '\n');
                } else {
                    // try to unlink if it exists, error is non-fatal.
                    try {
                        fs.unlinkSync(filename);
                    } catch (e) {
                        // don't care
                    }
                }

                filename = newobj.zonepath + '/root/etc/dhcp.'
                    + n.interface;
                // try to unlink if it exists, error is non-fatal.
                try {
                    fs.unlinkSync(filename);
                } catch (e) {
                    // don't care
                }

                if (n.hasOwnProperty('primary')) {
                    if (n.hasOwnProperty('gateway')) {
                        fs.writeFileSync(newobj.zonepath + '/root/etc/'
                            + 'defaultrouter', n.gateway + '\n');
                    }
                    if (n.ip === 'dhcp') {
                        fs.writeFileSync(filename, '');
                    }
                }
            }

            // XXX we leave old hostname.netX files around and just replace when
            //     we have one next.

            cb();
        }, function (cb) {
            var factor;
            var keys = [];
            var rctl;
            var rctls = {
                'cpu_shares': ['zone.cpu-shares'],
                'zfs_io_priority': ['zone.zfs-io-priority'],
                'max_lwps': ['zone.max-lwps'],
                'max_physical_memory': ['zone.max-physical-memory',
                    (1024 * 1024)],
                'max_locked_memory': ['zone.max-locked-memory', (1024 * 1024)],
                'max_swap': ['zone.max-swap', (1024 * 1024)],
                'cpu_cap': ['zone.cpu-cap']
            };

            if (newobj.brand === 'kvm') {
                // no changing VM rctls while running
                cb();
                return;
            }

            for (rctl in rctls) {
                keys.push(rctl);
            }

            async.forEachSeries(keys, function (prop, c) {
                rctl = rctls[prop][0];
                if (rctls[prop][1]) {
                    factor = rctls[prop][1];
                } else {
                    factor = 1;
                }

                if (newobj.brand === 'joyent' && payload.hasOwnProperty(prop)) {
                    setRctl(newobj.zonename, rctl,
                        Number(payload[prop]) * factor,
                        function (err) {
                            if (err) {
                                VM.log('WARN', 'failed to set rctl: '
                                    + prop, err);
                            }
                            c();
                        }
                    );
                } else {
                    c();
                }
            }, function (err) {
                cb(err);
            });
        }, function (cb) {
            if ((payload.hasOwnProperty('vnc_password')
                && (oldobj.vnc_password !== newobj.vnc_password))
                || (payload.hasOwnProperty('vnc_port')
                    && (oldobj.vnc_port !== newobj.vnc_port))) {

                // tell vmadmd to refresh_password and port (will restart vnc
                // listener)
                postVmadmd(newobj.uuid, 'reload_vnc', {}, function (e) {
                    if (e) {
                        cb(new Error('Unable to tell vmadmd to reload VNC'));
                    } else {
                        cb();
                    }
                });
            } else {
                cb();
            }
        }, function (cb) {
            // we do this last, since we need the memory in the zone updated
            // first if we're growing this.
            if (payload.hasOwnProperty('tmpfs') && newobj.brand !== 'kvm') {
                resizeTmp(newobj.zonename, payload.tmpfs, cb);
            } else {
                cb();
            }
        }
    ], function (err, res) {
        callback(err);
    });
}

exports.update = function (uuid, payload, callback)
{
    VM.resetLog('update');

    VM.log('INFO', 'Updating VM ' + uuid + ' with initial payload:\n'
        + JSON.stringify(payload, null, 2));

    normalizeNics(payload);

    VM.load(uuid, function (err, obj) {
        var disks = [];
        var matches;
        var n;
        var new_vmobj;
        var p;
        var used_disk_indexes = [];
        var zcfg;

        if (err) {
            callback(err);
            return;
        }

        // normalizePayload(payload)
        fixPayloadMemory(payload, obj);

        // create any new volumes we need.
        if (payload.hasOwnProperty('add_disks')) {
            disks = payload.add_disks;
        }

        // create a list of used indexes so we can find the free ones to
        // use in createVolume()
        if (obj.hasOwnProperty('disks')) {
            for (n in obj.disks) {
                matches = obj.disks[n].path.match(/^.*-disk(\d+)$/);
                if (matches) {
                    used_disk_indexes.push(Number(matches[1]));
                }
            }
        }

        // add the bits of payload createVolumes() needs.
        p = {'disks': disks};
        p.uuid = uuid;
        if (obj.hasOwnProperty('zfs_storage_pool_name')) {
            p.zfs_storage_pool_name = obj.zfs_storage_pool_name;
        }
        p.used_disk_indexes = used_disk_indexes;

        async.series([
            function (cb) {
                checkProperties(payload, obj, function (e) {
                    VM.log('DEBUG', 'Used payload:\n'
                        + JSON.stringify(payload, null, 2));
                    cb(e);
                });
            }, function (cb) {
                createVolumes(p, function (e) {
                    cb(e);
                });
            }, function (cb) {
                updateMetadata(obj, payload, function (e) {
                    cb(e);
                });
            }, function (cb) {
                // generate a payload and send as a file to zonecfg to update
                // the zone.
                zcfg = buildZonecfgUpdate(obj, payload);
                zonecfgFile(zcfg, ['-u', uuid], function (e, fds) {
                    cb(e);
                });
            }, function (cb) {
                VM.load(uuid, function (e, newobj) {
                    if (e) {
                        cb(e);
                    } else {
                        new_vmobj = newobj;
                        cb();
                    }
                });
            }, function (cb) {
                applyUpdates(obj, new_vmobj, payload, function () {
                    cb();
                });
            }
        ], function (e) {
            callback(e);
        });
    });
};

function kill(uuid, callback)
{
    var unset_autoboot = 'set autoboot=false';

    VM.log('INFO', 'Killing VM ' + uuid);

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        if (err) {
            callback(err);
            return;
        }
        if (obj.brand === 'kvm') {
            unset_autoboot =
                'select attr name=vm-autoboot; set value=false; end';
        }

        zoneadm(['-u', uuid, 'halt', '-X'], function (e, fds) {
            var msg = trim(fds.stderr);

            if (msg.match(/zone is already halted$/)) {
                // remove transition marker, since vm is not running now.
                unsetTransition(obj, function () {
                    callback(null, 'vm is not running');
                });
            } else if (e) {
                VM.log('ERROR', 'failed to kill ' + uuid + ': '
                    + fds.stderr, e);
                callback(err, msg);
            } else {
                zonecfg(['-u', uuid, unset_autoboot],
                    function (error, unset_fds) {

                    if (error) {
                        // The vm is dead at this point, erroring out here would
                        // do no good, so we just log it.
                        VM.log('ERROR', 'killVM(): Failed to '
                            + unset_autoboot + ' for ' + uuid);
                    }
                    if (obj.state === 'stopping') {
                        // remove transition marker
                        unsetTransition(obj, function () {
                            callback(null, msg);
                        });
                    } else {
                        callback(null, msg);
                    }
                });
            }
        });
    });
}

function postVmadmd(uuid, action, args, callback)
{
    var arg;
    var url_path = '/vm/' + uuid + '?action=' + action;
    var req;

    if (args) {
        for (arg in args) {
            if (args.hasOwnProperty(arg)) {
                url_path = url_path + '&' + arg + '=' + args[arg];
            }
        }
    }

    VM.log('DEBUG', 'HTTP POST ' + url_path);
    req = http.request(
        { method: 'POST', socketPath: VMADMD_SOCK, path: url_path },
        function (res) {

            VM.log('DEBUG', 'HTTP STATUS: ' + res.statusCode);
            VM.log('DEBUG', 'HTTP HEADERS: ' + JSON.stringify(res.headers));
            res.setEncoding('utf8');
            res.on('data', function (chunk) {
                VM.log('DEBUG', 'HTTP BODY: ' + chunk);
            });
            res.on('end', function () {
                VM.log('DEBUG', 'HTTP conversation has completed.');
                callback();
            });
        }
    );
    req.on('error', function (e) {
        VM.log('ERROR', 'HTTP error', e);
        callback(e);
    });
    req.end();
}

exports.stop = function (uuid, options, callback)
{
    var unset_autoboot = 'set autoboot=false';
    var vmobj;

    if (options.hasOwnProperty('force') && options.force) {
        VM.resetLog('stop-F');
        kill(uuid, callback);
        return;
    } else {
        VM.resetLog('stop');
    }

    VM.log('INFO', 'Stopping VM ' + uuid);

    if (!options) {
        options = {};
    }
    if (!options.timeout) {
        options.timeout = 180;
    }
    if (!options.transition_to) {
        options.transition_to = 'stopped';
    }

    async.series([
        function (cb) {
            /* We load here to ensure this vm exists. */
            VM.load(uuid, function (err, obj) {
                if (err) {
                    VM.log('ERROR', err.message, err);
                    cb(err);
                    return;
                } else {
                    vmobj = obj;
                    cb();
                }
            });
        }, function (cb) {
            // KVM brand specific stuff
            if (vmobj.brand === 'kvm') {
                async.series([
                    function (callbk) {
                        setTransition(vmobj, 'stopping', options.transition_to,
                            (options.timeout * 1000), function (err) {

                            callbk(err);
                        });
                    }, function (callbk) {
                        postVmadmd(vmobj.uuid, 'stop',
                            {'timeout': options.timeout}, function (err) {

                            if (err) {
                                VM.log('ERROR', err.message, err);
                            }
                            callback(err);
                        });
                    }, function (callbk) {

                        // different version for VMs
                        unset_autoboot = 'select attr name=vm-autoboot; '
                            + 'set value=false; end';

                        zonecfg(['-u', uuid, unset_autoboot],
                            function (err, fds) {
                                if (err) {
                                    // The vm is dead at this point, failing
                                    // here would do no good, so we just log it.
                                    VM.log('ERROR', 'stop(): Failed to '
                                        + unset_autoboot + ' for ' + uuid, err);
                                } else {
                                    VM.log('NOTICE', 'Stopped ' + uuid);
                                }
                                callbk();
                            }
                        );
                    }
                ], function (err) {
                    cb(err);
                });
            } else { // not brand === kvm
                cb();
            }
        }, function (cb) {
            var args;

            // joyent brand specific stuff
            args = [vmobj.zonename, '/usr/sbin/shutdown', '-y', '-g', '0',
                '-i', '5'];

            if (vmobj.brand === 'joyent') {
                async.series([
                    function (callbk) {
                        VM.log('DEBUG', '/usr/sbin/zlogin ' + args.join(' '));
                        execFile('/usr/sbin/zlogin', args,
                            function (err, stdout, stderr) {

                            if (err) {
                                VM.log('ERROR', 'zlogin for ' + vmobj.zonename
                                    + ' exited with code' + err.code
                                    + ' stdout: "' + stdout + '" stderr:"'
                                    + stderr + '"', err);
                                callbk(err);
                            } else {
                                callbk(err);
                            }
                        });
                    }, function (callbk) {
                        zonecfg(['-u', uuid, unset_autoboot],
                            function (err, fds) {
                                if (err) {
                                    // The vm is dead at this point, failing
                                    // do no good, so we just log it.
                                    VM.log('WARN', 'Failed to ' + unset_autoboot
                                        + ' for ' + uuid, err);
                                } else {
                                    VM.log('NOTICE', 'Stopped ' + uuid);
                                }
                                callback();
                            }
                        );
                    }
                ], function (err) {
                    cb(err);
                });
            } else { // not brand === joyent
                cb();
            }
        }
    ], function (err) {
        callback(err);
    });
};

// sends several query-* commands to QMP to get details for a VM
exports.info = function (uuid, types, callback)
{
    // load to ensure we're a VM
    VM.load(uuid, function (err, obj) {
        var type;

        if (err) {
            callback(err);
            return;
        }

        if (obj.brand !== 'kvm') {
            callback(new Error('the info command is only supported for VMs'));
            return;
        }

        if (obj.state !== 'running' && obj.state !== 'stopping') {
            callback(new Error('Unable to get info for vm from state "'
                + obj.state + '", must be "running" or "stopping".'));
            return;
        }

        if (!types) {
            types = ['all'];
        }

        for (type in types) {
            type = types[type];
            if (VM.INFO_TYPES.indexOf(type) === -1) {
                callback(new Error('unknown info type: ' + type));
                return;
            }
        }

        http.get({ socketPath: VMADMD_SOCK, path: '/vm/' + uuid + '?types='
            + types.join(',') },
            function (res) {
                var data = '';

                if (res.statusCode !== 200) {
                    callback(new Error('Unable to get info from vmadmd, query '
                        + 'returned ' + res.statusCode + '.'));
                } else {
                    res.on('data', function (d) {
                        data = data + d.toString();
                    });
                    res.on('end', function (d) {
                        callback(null, JSON.parse(data));
                    });
                }
            }
        ).on('error', function (e) {
            console.error(e);
        });
    });
};

function reset(uuid, callback)
{
    VM.log('INFO', 'Resetting VM ' + uuid);

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        if (err) {
            callback(err);
            return;
        }

        if (obj.state !== 'running') {
            callback(new Error('Cannot reset vm from state "'
                + obj.state + '", must be "running".'));
            return;
        }

        if (obj.brand === 'kvm') {
            postVmadmd(obj.uuid, 'reset', {}, function (e) {
                if (e) {
                    callback(new Error('Unable to post "reset" to '
                        + 'vmadmd'));
                } else {
                    callback();
                }
            });
        } else {
            zoneadm(['-u', obj.uuid, 'reboot', '-X'], function (e, fds) {
                if (e) {
                    callback(new Error(rtrim(fds.stderr)));
                } else {
                    callback();
                }
            });
        }
    });
}

exports.reboot = function (uuid, options, callback)
{

    if (options.hasOwnProperty('force') && options.force) {
        VM.resetLog('reboot-F');
        reset(uuid, callback);
        return;
    } else {
        VM.resetLog('reboot');
    }

    VM.log('INFO', 'Rebooting VM ' + uuid);

    if (!options) {
        options = {};
    }

    VM.load(uuid, function (err, m) {
        var args;

        if (err) {
            callback(err);
            return;
        }

        if (m.state !== 'running') {
            callback(new Error('Cannot reboot vm from state "' + m.state
                + '", must be "running"'));
            return;
        }

        if (m.brand === 'kvm') {
            options.transition_to = 'start';
            VM.stop(uuid, options, function (e) {
                if (e) {
                    callback(e);
                } else {
                    callback();
                }
            });
        } else {
            // joyent branded zones
            args = [m.zonename, '/usr/sbin/shutdown', '-y', '-g', '0',
                '-i', '6'];
            VM.log('DEBUG', '/usr/sbin/zlogin ' + args.join(' '));
            execFile('/usr/sbin/zlogin', args, function (e, stdout, stderr) {
                if (e) {
                    VM.log('ERROR', 'zlogin for ' + m.zonename
                        + ' exited with code' + e.code + ' stdout: "'
                        + stdout + '" stderr:"' + stderr + '"', e);
                    callback(e);
                } else {
                    callback();
                }
            });
        }
    });
};

exports.sysrq = function (uuid, req, options, callback)
{
    VM.resetLog('sysrq-' + req);

    VM.log('INFO', 'Sending sysrq "' + req + '" to ' + uuid);

    /* We load here to ensure this vm exists. */
    VM.load(uuid, function (err, obj) {
        if (err) {
            callback(err);
            return;
        }

        if (obj.state !== 'running' && obj.state !== 'stopping') {
            callback(new Error('Unable to send request to vm from state "'
                + obj.state + '", must be "running" or "stopping".'));
            return;
        }

        if (obj.brand !== 'kvm') {
            callback(new Error('The sysrq command is only supported for KVM.'));
            return;
        }

        if (VM.SYSRQ_TYPES.indexOf(req) === -1) {
            callback(new Error('Invalid sysrq "' + req + '" valid values: '
                + '"' + VM.SYSRQ_TYPES.join('","') + '".'));
            return;
        }

        postVmadmd(obj.uuid, 'sysrq', {'request': req}, function (e) {
            if (e) {
                callback(new Error('Unable to post "sysrq" to vmadmd'));
            } else {
                callback();
            }
        });
    });
};

exports.console = function (uuid, callback)
{
    VM.load(uuid, function (err, obj) {
        var args;
        var child;
        var cmd;
        var stty;

        if (err) {
            callback(err);
            return;
        }
        if (obj.state !== 'running') {
            callback(new Error('cannot connect to console when state is '
                + '"' + obj.state + '" must be "running".'));
            return;
        }

        if (obj.brand === 'joyent') {
            cmd = '/usr/sbin/zlogin';
            args = ['-C', '-e', '\\035', obj.zonename];

            VM.log('DEBUG', cmd + ' ' + args.join(' '));
            child = spawn(cmd, args, {customFds: [0, 1, 2]});
            child.on('exit', function (code) {
                VM.log('DEBUG', 'zlogin process exited with code ' + code);
                callback();
            });
        } else if (obj.brand === 'kvm') {
            async.series([
                function (cb) {
                    cmd = '/usr/bin/stty';
                    args = ['-g'];
                    stty = '';

                    VM.log('DEBUG', cmd + ' ' + args.join(' '));
                    child = spawn(cmd, args, {customFds: [0, -1, -1]});
                    child.stdout.on('data', function (data) {
                        // VM.log('DEBUG', 'data: ' + data.toString());
                        stty = data.toString();
                    });
                    child.on('exit', function (code) {
                        VM.log('DEBUG', 'stty process exited with code '
                            + code);
                        cb();
                    });
                }, function (cb) {
                    cmd = '/usr/bin/socat';
                    args = ['unix-client:' + obj.zonepath
                        + '/root/tmp/vm.console', '-,raw,echo=0,escape=0x1d'];

                    VM.log('DEBUG', cmd + ' ' + args.join(' '));
                    child = spawn(cmd, args, {customFds: [0, 1, 2]});
                    child.on('exit', function (code) {
                        VM.log('DEBUG', 'zlogin process exited with code '
                            + code);
                        cb();
                    });
                }, function (cb) {
                    cmd = '/usr/bin/stty';
                    args = [stty];

                    VM.log('DEBUG', cmd + ' ' + args.join(' '));
                    child = spawn(cmd, args, {customFds: [0, -1, -1]});
                    child.on('exit', function (code) {
                        VM.log('DEBUG', 'stty process exited with code '
                            + code);
                        cb();
                    });
                }
            ], function (e, results) {
                callback(e);
            });
        } else {
            callback(new Error('Cannot get console for brand: ' + obj.brand));
        }
    });
};
