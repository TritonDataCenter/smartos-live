/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2019, Joyent, Inc.
 *
 */

/*
 * The primary function of this module is to mantain an up-to-date copy of:
 *
 *   1) the complete vmobj list
 *   2) a vmload cache object.
 *
 * The vmload cache object will be maintained internally by this daemon while
 * the vmobj list can be consumed from the HTTP interface:
 *
 *   - The complete vm list can be consumed at GET /vms
 *   - A single vm can be consumed at GET /vms/UUID
 *
 * To use the daemon, you should do something like:
 *
 *  var vminfod = new Vminfod({log: log});
 *  vminfod.start(callback);
 *  vminfod.stop([callback]);
 *  vminfod.on(<event type>, callback(data));
 *
 * Where the event types can be:
 *
 *  ready - emitted when vminfo has initialized after start()
 *  end - emitted when vminfo has shutdown after stop()
 *  create - emitted when a new vm is created
 *  modify - emitted when an existing vm is modified
 *  delete - emitted when an existing vm is deleted
 *
 * on 'ready' the callback will be called, passing the list of vmobjs as the
 * first and only argument.
 *
 * on 'end' the callback will be called, without any arguments
 *
 * on 'create' the callback will be called, passing the newly created vmobj as
 * the first and only argument.
 *
 * on 'modify' the callback will be called, passing the updated vmobj as the
 * first argument, and a list of changes as the second argument.
 *
 * on 'delete' the callback will be called, passing the zonename of the vmobj
 * as the first and only argument.
 *
 * Note: The main consumer of this module will be the daemon
 * /usr/vm/sbin/vminfod, found under the SMF service
 * system-smartdc-vminfod:default.
 *
 * To query this daemon as a client however, use the vminfod/client.js library.
 *
 * As a client, Events can be consumed through the webservice at GET /events.
 * The client connection will be held open until the client explicitly closes
 * the socket. Events will be streamed to the client in http chunks as
 * newline-separated-JSON where each event will be a JSON object. When
 * unwrapped, the 'type' attribute will indicate the event type. All relevant
 * data to the event will be included in the JSON object.
 *
 * How this daemon works:
 *
 *   The tl;dr overview is that this module will listen for events within 3
 *   broad categories: zone state, zone config files, and zfs datasets.
 *   When an event is fired, we will delete portions of the cache object that
 *   are relevant to the event, then ask vmload to fill in the holes with
 *   getZoneData, which we can then update the vmobjs that were affected
 *   by the change, and lastly inform any subscribed consumers of the specific
 *   changes to the vmobj data.
 *
 *   This module is not necessarily concerned with the details of a vmobj -
 *   meaning, the structure of the vmobj, where the data is derived, and how
 *   the data is transformed are not the concern of this module. This module
 *   will delegate that responsibility to the vmload modules. This module is
 *   concerned with knowing when pieces of the cache object are likely
 *   out-of-date, how to re-populate those pieces, and which vmobjs will be
 *   affected by the change.
 *
 *   There a 3 broad event categories that are monitored via 2 event sources to
 *   determine if a change has happened on a machine that *may* result in the
 *   creation, modification, or deletion of a vm.
 *
 *     1. Sysevents (using sysevent-stream.js)
 *
 *       A. zpoolwatcher.js: watches ZFS sysevents for dataset modifications
 *       B. zonewatcher.js: watches zone sysevents for zone modifications
 *
 *     2. File System Events (via event ports using fswatcher.js)
 *     Each VM has 5 files that are watched for modifications
 *
 *       1. /etc/zones/<uuid>.xml
 *       2. /zones/<uuid>/lastexited
 *       3. /zones/<uuid>/config/tags.json
 *       4. /zones/<uuid>/config/routes.json
 *       5. /zones/<uuid>/config/metadata.json
 *
 *   At a routine interval, we will also force-refresh the cache and regenerate
 *   the vmobj sets to ensure data integrity. This is because sysevents are
 *   emitted "best-effort" from the kernel, so it is possible that this module
 *   may be unaware of changes to a zfs dataset or a zanoe.  The refresh
 *   interval will also do its best to run when the queue is idle, but will
 *   eventually just force run if its taking too long (if the system is
 *   particularly busy with zone or zfs operations).  When the refresh interval
 *   is fired, we will first pause the event queue, then request a new cache
 *   object. Once we have received a new cache object, we will "fastForward"
 *   the queue to the current time, performing all modifications to our current
 *   cache, as well as the new cache object received from the full load.  This
 *   way, any events seen while the cacehe was being fully loaded from the
 *   system will be accounted for in both objects (to eliminate any sort of
 *   race). We will replace the current cache object with the new one if the
 *   two cache objects are different.
 *
 *   Only if the two objects are different, we will iterate through all vmobjs
 *   and generate a new vmobj from the new cache and report any deltas along the
 *   way. Finally, after all vmobjs have been updated, we will resume the queue.
 *
 *   A new vmobj is created when a zone event is received for a uuid that we're
 *   not currently watching, which will then register observers for relevant
 *   config files.
 *
 *   A vmobj is removed when the watched /etc/zones/<uuid>.xml receives the
 *   DELETE event. At this point, we will also remove all watchers that were
 *   setup for that vmobj.
 *
 */

var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var http = require('http');
var path = require('path');
var url = require('url');
var util = require('util');

var assert = require('/usr/node/node_modules/assert-plus');
var diff = require('/usr/vm/node_modules/diff');
var getDatasets = require('/usr/vm/node_modules/vmload/vmload-datasets').
    getDatasets;
var getZoneRecords = require('/usr/vm/node_modules/vmload/vmload-zoneadm').
    getZoneRecords;
var hrtime = require('/usr/vm/node_modules/hrtime');
var utils = require('/usr/vm/node_modules/utils');
var libuuid = require('/usr/node/node_modules/uuid');
var vasync = require('/usr/vm/node_modules/vasync');
var vmload = require('/usr/vm/node_modules/vmload');

var FsWatcher = require('/usr/vm/node_modules/fswatcher').FsWatcher;
var Queue = require('/usr/vm/node_modules//queue').Queue;
var RingBuffer = require('/usr/vm/node_modules/bunyan').RingBuffer;
var ZoneWatcher = require('./zonewatcher').ZoneWatcher;
var ZpoolWatcher = require('./zpoolwatcher').ZpoolWatcher;

/*
 * Files in /zones/<uuid>/config to watch
 */
var CONFIG_FILES = [
    'metadata.json',
    'routes.json',
    'tags.json'
];

/*
 * sysinfo(1M) cache file
 */
var SYSINFO_FILE = '/tmp/.sysinfo.json';

/*
 * The keys of this map (ie. "disks" and "nics") are keys to a VM's JSON
 * payload that are:
 * 1: Guaranteed to be arrays of objects (this is asserted and will throw
 * if not true)
 *
 * The values (ie. "path" and "mac" respectively) are keys inside the objects
 * inside the array that are used as the unique identifiers.  This helps
 * diff.js determine what kind of changes are made to an object.
 */
var DIFF_MAP = {
    disks: 'path',
    nics: 'mac'
};

/*
 * Default job timeout for the queue.  Each task enqueued will have 1 minute
 * from the time it starts to finish processing.  On average, most tasks
 * take less than 1 second - this is just a kill switch for a hanging task.
 */
var QUEUE_TASK_TIMEOUT = 1 * 60 * 1000;

/*
 * Default number of records to store for refresh errors and log messages.
 */
var DEFAULT_REFRESH_RECORDS = 5;

/*
 * Dataset name for delegated datasets.
 */
var DELEGATED_DATASET_NAME = 'data';

/*
 * Default interval timer to do a full system refresh of the vminfod cache.
 */
var DEFAULT_REFRESH_INTERVAL = 5 * 60 * 1000;

/*
 * How long to wait for the event queue to become idle before forcing a full
 * refresh.
 */
var KILL_TIMER_WAIT = 5 * 60 * 1000;

module.exports = Vminfod;
function Vminfod(options) {
    var self = this;

    // global state/status - these are used primarily for debugging purposes
    // and should be modified with the setState/setStatus functions
    self.state = 'stopped';
    self.status = 'initialized';

    // consumers of the '/events' stream
    self.events_listeners = {};

    /*
     * Structures to hold the raw data.
     *
     * The _tmp variants are used while the queue is paused and a full system
     * refresh is being performed.  The full system refresh data will be stored
     * in these variables, and then compared to the live data at the end of the
     * refresh.  We store these globally so they can be modified during the
     * queue fastForward portion of the "reset".
     */
    self.vm_data = {};
    self.vm_data_tmp = undefined;
    self.zone_vm_data = {};
    self.zone_vm_data_tmp = {};

    // the actual vmobjs held in memory
    self.vmobjs = {};

    // structures to hold the pre-serialized data - these are managed by the
    // serialize* functions
    self.vm_data_json = {};
    self.vmobjs_json = {};

    // configurable options
    self.log = options.log;
    assert(self.log, 'must provide a logger');
    assert.optionalNumber(options.port, 'options.port');
    assert.optionalArrayOfString(options.ips, 'options.ips');
    assert.optionalNumber(options.refresh_interval, 'options.refresh_interval');

    // set default ips and port
    self.ips = options.ips || ['127.0.0.1'];
    self.port = options.port || 9090;

    // set default refresh interval for the periodic_timer
    self.refresh_interval = options.refresh_interval
        || DEFAULT_REFRESH_INTERVAL;

    /*
     * Keep a log of every time self.reset() finds differences from what is on
     * the system and what is in vminfod.
     */
    self.refresh_log = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});

    /*
     * Sometimes, self.reset() can fail but we don't necessarily want to kill
     * the process. Instead, store the errors in a log and expose them over
     * /status.
     */
    self.refresh_errors = new RingBuffer({limit: DEFAULT_REFRESH_RECORDS});

    /*
     * The last time a full refresh was performed
     */
    self.last_refresh_time = null;

    /*
     * We need to create intermediate event listeners between self and
     * clients subscribed to /events so we only have to JSON.stringify
     * once per event, instead of once per client per event.
     */
    self.on('create', function vminfodVmCreated(vmobj) {
        var data;
        var json;

        data = {
            type: 'create',
            date: new Date(),
            zonename: vmobj.zonename,
            uuid: vmobj.uuid,
            vm: vmobj
        };

        self.log.info({ev: data}, 'emitting "create" event (%d VMs total)',
            Object.keys(self.vmobjs).length);

        json = JSON.stringify(data);

        self.emit('create-json', json);
    });

    self.on('modify', function vminfodVmModified(vmobj, changes) {
        var data;
        var json;

        data = {
            type: 'modify',
            date: new Date(),
            zonename: vmobj.zonename,
            uuid: vmobj.uuid,
            vm: vmobj,
            changes: changes
        };

        self.log.info({ev: data}, 'emitting "modify" event (%d VMs total)',
            Object.keys(self.vmobjs).length);

        json = JSON.stringify(data);

        self.emit('modify-json', json);
    });

    self.on('delete', function vminfodVmDeleted(vmobj) {
        var data;
        var json;

        data = {
            type: 'delete',
            date: new Date(),
            zonename: vmobj.zonename,
            uuid: vmobj.uuid
        };

        self.log.info({ev: data}, 'emitting "delete" event (%d VMs total)',
            Object.keys(self.vmobjs).length);

        json = JSON.stringify(data);

        self.emit('delete-json', json);
    });
}
util.inherits(Vminfod, EventEmitter);

/*
 * Set the internal state value
 *
 * This, and setStatus below, are useful for tracking what vminfod is currently
 * processing (or at least, what it shoud be).  These internal variables can
 * be accessed over the GET /status interface, and each variable transition
 * can be seen in the log file.
 */
Vminfod.prototype.setState = function setState(/* args */) {
    var self = this;

    var state = util.format.apply(this, arguments);

    self.log.debug({
        oldstate: self.state,
        newstate: state
    }, 'state changed from "%s" to "%s"', self.state, state);

    self.state = state;
};

/*
 * Set the internal status value, see setState for more information
 */
Vminfod.prototype.setStatus = function setStatus(/* args */) {
    var self = this;

    var status = util.format.apply(this, arguments);

    self.log.debug({
        oldstatus: self.status,
        newstatus: status
    }, 'status changed from "%s" to "%s"', self.status, status);

    self.status = status;
};

/*
 * start vminfod
 */
Vminfod.prototype.start = function start(callback) {
    var self = this;

    assert.func(callback, 'callback');

    self.started_time = process.hrtime();
    self.log.info('vminfod starting');

    vasync.pipeline({funcs: [
        // update state
        function startSetInitialState(_, cb) {
            self.setState('booting');
            cb();
        },
        // init queue
        function startInitQueue(_, cb) {
            self.setStatus('initializing event queue');
            var opts = {
                workers: 1,
                paused: true,
                dedup: true,
                idleTime: 1000,
                log: self.log
            };
            self.event_queue = new Queue(opts);
            self.event_queue.on('error', function queueError(err) {
                self.log.debug({err: err}, 'ignoring queue error: %s',
                    err.message);
            });
            cb();
        },
        // start global watchers
        function startInitGlobalWatchers(_, cb) {
            self.setStatus('starting global watchers');
            self.startWatchers(cb);
        },
        // start vm watchers
        function startInitVmWatchers(_, cb) {
            self.setStatus('starting vm watchers');
            self.startVmWatchers(cb);
        },
        // set vm_data
        function startInitVmData(_, cb) {
            self.setStatus('setting initial cache data');
            self.setVmData(cb);
        },
        // set vmobjs data
        function startInitVmobjs(_, cb) {
            self.setStatus('setting initial vmobjs data');
            self.setVmobjs(cb);
        },
        // store last "refresh" time
        function startRefreshTime(_, cb) {
            self.last_refresh_time = process.hrtime();
            cb();
        },
        // resume queue
        function startResumeQueue(_, cb) {
            self.setStatus('resuming the event queue');
            self.event_queue.resume();
            cb();
        },
        // start http server
        function startHTTPServer(_, cb) {
            self.setStatus('starting http server');
            self.startHTTPHandlers(cb);
        },
        // start refresh timers
        function startInitRefreshTimers(_, cb) {
            self.setStatus('starting refresh timers');
            self.startTimers(cb);
        }
    ]}, function startPipelineDone(err) {
        var delta = process.hrtime(self.started_time);
        var prettyDelta = hrtime.prettyHrtime(delta);

        if (err) {
            self.log.error({err: err}, 'failed to complete boot sequence');
            callback(err);
            return;
        }

        self.setState('running');
        self.setStatus('working');
        self.log.info('boot sequence complete, took %s', prettyDelta);
        self.emit('ready', self.vmobjs);

        callback();
    });
};

/*
 * setVmobjs() sets the initial vmobjs data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request vmobjs from vmload.getVmobjs, using the cache
 * object set in vm_cache. The result will then be converted from an array
 * into a hash where the key is the vm uuid and the value is the vmobj.
 *
 * called by .start()
 *
 */
Vminfod.prototype.setVmobjs = function setVmobjs(callback) {
    var self = this;

    var opts = {
        cache: self.vm_data,
        log: self.log,
        keepalive: true,
        loadManually: true
    };
    vmload.getVmobjs(function vmloadGetVmobjsFilter(_, cb) {
        cb(null, true);
    }, opts, function vmloadGetVmobjsCallback(err, results) {
        var i = 0;

        if (err) {
            self.log.error({err: err}, 'failed to vmload.getVmobjs: %s',
                err.message);
            callback(err);
            return;
        }

        self.vmobjs = {};
        results.forEach(function forEachVmobjs(vmobj) {
            i++;
            assert.object(vmobj, 'vmobj');
            assert.uuid(vmobj.uuid, 'vmobj.uuid');
            self.vmobjs[vmobj.zonename] = vmobj;
        });

        self.log.debug('setVmobjs %d VMs found', i);
        callback();
    });
};

/*
 * setVmData() sets the initial vm_data
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will request a cache object from _loadVmData and set
 * vm_data
 *
 */
Vminfod.prototype.setVmData = function setVmData(callback) {
    var self = this;

    self._loadVmData(function loadVmDataCallback(err, cache) {
        if (err) {
            self.log.error('failed to set initial vm_data');
            callback(err);
            return;
        }
        self.log.debug('setting initial vm_data: %j', cache);
        self.vm_data = cache;
        callback();
    });
};

/*
 * Start any and all periodic timers needed by vminfod
 *
 * called by .start()
 */
Vminfod.prototype.startTimers = function startTimers(callback) {
    var self = this;

    assert(!self.periodic_timeout, 'timers already started');

    function makeTimer(cb) {
        self.periodic_timeout = setTimeout(function periodicTimeout() {
            var started;
            var killTimer;

            if (self.event_queue.idle) {
                self.log.debug(
                    'event queue idle - starting full refresh immediately');
                go();
            } else {
                self.log.debug('event queue busy - queueing full refresh');
                started = process.hrtime();

                /*
                 * Set a kill switch so we don't potentially wait forever for
                 * an idle event.
                 */
                killTimer = setTimeout(function killTimerTimeout() {
                    self.log.warn('event queue idle timeout exceeded (%dms) - '
                        + 'forcing refresh', KILL_TIMER_WAIT);
                    self.event_queue.removeListener('idle', go);
                    started = null;
                    killTimer = null;
                    go();
                }, KILL_TIMER_WAIT);

                self.event_queue.once('idle', go);
            }

            function go() {
                var now;
                var deltaPretty;

                if (killTimer) {
                    clearTimeout(killTimer);
                    killTimer = null;
                }

                if (started) {
                    now = process.hrtime();
                    deltaPretty = hrtime.hrtimeDeltaPretty(now, started);

                    self.log.debug('event queue now idle - took %s',
                        deltaPretty);
                }
                refresh(function refreshDone(err) {
                    /*
                     * In the event of an error, we log it (both with bunyan
                     * and to the refresh_errors log that is visible on `GET
                     * /status`) and move on.
                     *
                     * There are legitmate situations that can cause "refresh"
                     * to fail where we don't actually want vminfod to crash as
                     * a result.  An example of this is doing a full
                     * `self.reset` which loads all VMs off of the running
                     * system using vmload.getVmobjs.  This function is
                     * inherently racy as it first gets a list of all zone
                     * UUIDs on the system *and then* does a load on each zone.
                     * It's possible that in that time a zone that was seen
                     * doing the full UUID list could have been deleted.  In
                     * this situtation, `self.reset` will callback with an
                     * error but that is not cause for us to stop vminfod when
                     * running the periodic timer.  Instead, we just log it and
                     * try again later.
                     */
                    if (err) {
                        self.refresh_errors.write({
                            err: err,
                            time: process.hrtime()
                        });
                        self.log.error({err: err}, 'failed to refresh data');

                    }

                    makeTimer();
                });
            }
        }, self.refresh_interval);

        if (cb) {
            cb();
        }
    }

    function refresh(cb) {
        self.log.info('full data refresh');
        var started = process.hrtime();

        vasync.pipeline({funcs: [
            function refreshResetData(_, cb2) {
                self.log.debug('full VM reset');
                self.reset(cb2);
            }, function refreshFindStaleFiles(_, cb2) {
                self.log.debug('checking for stale files to unwatch');

                var vms = Object.keys(self.vmobjs);
                var files = Object.keys(self.fsw.watching).filter(
                    function filterSysinfoFile(f) {

                    // Ignore sysinfo since we always watch this file
                    if (f === SYSINFO_FILE) {
                        return false;
                    }

                    /*
                     * Loop every VM on the system (the UUIDs).  If the UUID is
                     * found inside the filename of the file being watched,
                     * then we continue watching the file (filter it out of the
                     * array). Any files left over are files being watched for
                     * a VM that does not exist and can be unwatched.
                     */
                    return !(vms.some(function someVms(vm) {
                        return (f.indexOf(vm) > -1);
                    }));
                });

                if (files.length === 0) {
                    self.log.debug('found 0 stale files');
                    cb2();
                    return;
                }

                self.log.error({files: files}, 'found %d stale files',
                    files.length);

                vasync.forEachPipeline({
                    func: function refreshFswUnwatch(f, cb3) {
                        self.fsw.unwatch(f, cb3);
                    },
                    inputs: files
                }, cb2);
            }
        ]}, function refreshDone(err) {
            var now = process.hrtime();
            var deltaPretty = hrtime.hrtimeDeltaPretty(now, started);

            self.log.debug('full data refresh took %s', deltaPretty);

            self.last_refresh_time = now;
            cb(err);
        });
    }

    makeTimer(callback);
};

/*
 * startWatchers() starts global watchers
 *
 * Arguments:
 *   'callback' - will be called with (err)
 *
 * This function will:
 *   1) Create a FsWatcher object
 *   2) Watch for changes to the sysinfo cache file
 *   3) Create a ZoneWatcher
 *   4) Create a ZpoolWatcher
 */
Vminfod.prototype.startWatchers = function startWatchers(callback) {
    var self = this;

    vasync.pipeline({funcs: [
        function startFsWatcher(_, cb) {
            self.fsw = new FsWatcher({log: self.log});

            self.fsw.on('event', function fswOnEvent(obj) {
                self.handleFsEvent(obj);
            });

            self.fsw.once('ready', function fswOnReady(obj) {
                self.log.debug('filesystem watcher ready');
                cb();
            });

            self.fsw.start();
        }, function startFsWatcherSysinfoWatcher(_, cb) {
            self.fsw.watch(SYSINFO_FILE, cb);
        }, function startZoneWatcher(_, cb) {
            self.zonew = new ZoneWatcher({log: self.log});

            self.zonew.on('event', function zonewOnEvent(obj) {
                self.handleZoneEvent(obj);
            });

            self.zonew.once('ready', function fswOnReady() {
                self.log.debug('zone watcher ready');
                cb();
            });
        }, function startZpoolWatcher(_, cb) {
            self.zpoolw = new ZpoolWatcher({log: self.log});

            self.zpoolw.on('event', function zpoolwOnEvent(obj) {
                self.handleZpoolEvent(obj);
            });

            self.zpoolw.once('ready', function zpoolwOnReady() {
                self.log.debug('zpool watcher ready');
                cb();
            });
        }
    ]}, function startWatchersDone() {
        self.log.info('global watchers ready');
        callback();
    });
};

/*
 * startVmWatchers() starts the watchers for a VM
 *
 * Arguments:
 *   'zonename' - a specific vm zonename to start watchers on
 *   'callback' - will be called with (err)
 *
 *   'zonename' argument is optional, and when omitted will start watchers
 *   for all vms.
 */
Vminfod.prototype.startVmWatchers =
    function startVmWatchers(zonename, callback) {

    var self = this;

    if (typeof (zonename) === 'function') {
        callback = zonename;
        zonename = undefined;
    }

    // start watchers for a single VM
    if (zonename) {
        addVmFsWatches(zonename, callback);
        return;
    }

    // start watchers for all VMs - since this function is ran before
    // any cached data is gathered, we must gather the list of vms manually
    var records;
    vasync.pipeline({funcs: [
        // load zone records
        function startVmWatchersLoadZoneRecords(_, cb) {
            var opts = {
                log: self.log
            };
            getZoneRecords(null, opts,
                function getZoneRecordsDone(err, _records) {

                if (err) {
                    self.log.debug({err: err}, 'failed to load zone records');
                    cb(err);
                    return;
                }

                records = _records;
                cb();
            });
        },
        // start watchers
        function startVmWatchersAddVmWatchers(_, cb) {
            vasync.forEachPipeline({
                func: function startVmWatcherAddVmFsWatcher(uuid, cb2) {
                    addVmFsWatches(records[uuid].zonename, cb2);
                },
                inputs: Object.keys(records)
            }, function addVmFsWatcherDone(err, results) {
                cb(err);
            });
        }
    ]}, function startVmWatchersDone(err) {
        if (err) {
            self.log.error({err: err}, 'failed to start vm watchers');
            callback(err);
            return;
        }

        callback();
    });


    /*
     * create fs watches for a given zone
     */
    function addVmFsWatches(zone, cb) {
        var files = [
            util.format('/etc/zones/%s.xml', zone),
            util.format('/zones/%s/lastexited', zone)
        ];
        CONFIG_FILES.forEach(function forEachConfigFile(f) {
            files.push(util.format('/zones/%s/config/%s', zone, f));
        });

        self.log.debug({files: files}, 'adding vm fs watchers for %s',
            zone);

        vasync.forEachPipeline({
            func: function fswWatchFile(f, cb2) {
                self.fsw.watch(f, cb2);
            },
            inputs: files
        }, function fswWatchFileDone(err, results) {
            self.log.debug({err: err},
                'finished adding vm fs watchers for %s', zone);
            cb(err);
        });
    }
};


/*
 * Start the HTTP interface
 *
 * called by .start()
 */
Vminfod.prototype.startHTTPHandlers = function startHTTPHandlers(callback) {
    var self = this;

    vasync.forEachPipeline({
        inputs: self.ips,
        func: function startHTTPServer(ip, cb) {
            http.createServer(handler).listen(self.port, ip,
                function serverListening() {

                self.log.debug('listening on http://%s:%d', ip, self.port);
                cb();
            });
        }
    }, callback);

    // http handler
    function handler(req, res) {
        var args;
        var c;
        var url_parts;

        url_parts = url.parse(req.url, true);
        c = path.normalize(url_parts.pathname).split('/');
        c.shift();

        args = url_parts.query || {};
        self.log.info({req: req}, 'HTTP request');

        if (req.method !== 'GET') {
            // Bad request
            res.writeHead(400, {'Content-Type': 'application/json'});
            res.end();
        } else {
            handleGet(c, args, req, res);
        }
    }

    // handler specifically for GET requests
    function handleGet(c, args, req, res) {
        var ret;
        var uuid;
        var now;

        switch (c[0]) {
        case 'ping':
            ret = {
                ping: 'pong'
            };
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(JSON.stringify(ret), 'utf-8');
            break;
        case 'status':
            now = process.hrtime();
            ret = {
                pid: process.pid,
                uptime: hrtime.hrtimeDeltaPretty(now, self.started_time),
                memory: process.memoryUsage(),
                state: self.state,
                status: self.status,
                numVms: Object.keys(self.vmobjs).length,
                curDate: new Date(),
                curTime: hrtime.hrtimeToString(now),
                queue: self.event_queue.dump(),
                lastRefresh: self.last_refresh_time ?
                    hrtime.hrtimeDeltaPretty(now, self.last_refresh_time) :
                    null,
                refreshErrors:
                    formatRefreshErrors(self.refresh_errors.records),
                eventsListeners: formatEventsListeners(self.events_listeners)
            };
            if (args.full) {
                ret.refreshLog = formatRefreshLog(self.refresh_log.records);
                ret.fswatcher = self.fsw.dump();
            }
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(JSON.stringify(ret), 'utf-8');
            break;
        case 'vms':
            var zonename = c[1];

            if (zonename) {
                // requesting a vmobj with zonename
                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    res.writeHead(404, {'Content-Type': 'application/json'});
                    res.write('VM Not Found: ' + zonename);
                    res.end();
                } else {
                    res.writeHead(200, {'Content-Type': 'application/json'});
                    res.end(self.serializeVm(zonename), 'utf-8');
                }
                break;
            }

            // requesting the vmobj list
            res.writeHead(200, {'Content-Type': 'application/json'});
            res.end(self.serializeVms(), 'utf-8');
            break;
        case 'events':
            uuid = libuuid.create();
            ret = {
                // currently vminfod listens on localhost only so
                // the ip addresses are always the same
                // ip: request.connection.remoteAddress,
                userAgent: req.headers['user-agent'],
                createdDate: new Date(),
                createdTime: process.hrtime()
            };
            self.log.debug({uuid: uuid, ret: ret},
                'new /events listener created');

            res.writeHead(200, {'Content-Type': 'application/json'});

            var on_create = function onCreate(json) {
                res.write(json + '\n');
            };
            var on_modify = function onModify(json) {
                res.write(json + '\n');
            };
            var on_delete = function onDelete(json) {
                res.write(json + '\n');
            };
            var on_close = function onClose() {
                res.end();
                cleanup();
            };

            function cleanup() {
                self.log.debug({uuid: uuid, ret: ret},
                    '/events listener removed');
                self.removeListener('create-json', on_create);
                self.removeListener('modify-json', on_modify);
                self.removeListener('delete-json', on_delete);
                self.removeListener('close', on_close);
                delete self.events_listeners[uuid];
            }

            self.on('create-json', on_create);
            self.on('modify-json', on_modify);
            self.on('delete-json', on_delete);
            self.on('close', on_close);
            self.events_listeners[uuid] = ret;

            res.on('close', cleanup);

            // let this client stay open forever
            res.connection.setTimeout(0);

            // let the client know it is subscribed
            res.write(JSON.stringify({
                type: 'ready',
                date: ret.createdDate,
                uuid: uuid,
                vms: self.serializeVms()
            }) + '\n');
            break;
        default:
            res.writeHead(404, {'Content-Type': 'application/json'});
            res.write('Unsupported URL Path');
            res.end();
            break;
        }
    }
};

/*
 * Stop the vminfod daemon
 */
Vminfod.prototype.stop = function stop(callback) {
    var self = this;

    self.zonew.stop();
    self.zpoolw.stop();

    if (self.periodic_timer) {
        clearTimeout(self.periodic_timer);
        self.periodic_timer = null;
    }

    self.fsw.stop(function fswStopped() {
        self.emit('end');

        if (callback) {
            callback();
        }
    });
};


/*
 * stopVmWatchers() stops the watchers for a VM
 *
 * Arguments:
 *   'zonename' - a specific vm zonename to stop watchers on
 *   'callback' - will be called with (err)
 *
 *   'zonename' argument is optional, and when omitted will stop watchers
 *   for all vms.
 */
Vminfod.prototype.stopVmWatchers = function stopVmWatchers(zonename, callback) {
    var self = this;

    if (typeof (zonename) === 'function') {
        callback = zonename;
        zonename = undefined;
    }

    // stop watchers for a single VM
    if (zonename) {
        removeVmFsWatches(zonename, callback);
        return;
    }

    // stop watchers for all VMs
    vasync.forEachPipeline({
        func: removeVmFsWatches,
        inputs: Object.keys(self.vmobjs)
    }, function removeVmFsWatchesDone(err, results) {
        callback(err);
    });

    /*
     * remove fs watches for a given zone
     */
    function removeVmFsWatches(zone, cb) {
        var files = [
            util.format('/etc/zones/%s.xml', zone),
            util.format('/zones/%s/lastexited', zone)
        ];
        CONFIG_FILES.forEach(function configFileForEach(f) {
            files.push(util.format('/zones/%s/config/%s', zone, f));
        });

        self.log.debug({files: files}, 'removing vm fs watchers for %s',
            zone);

        vasync.forEachPipeline({
            func: function FsWatcherUnwatchFile(f, cb2) {
                self.fsw.unwatch(f, cb2);
            },
            inputs: files
        }, function FsWatcherUnwatchFilesDone(err, results) {
            self.log.debug({err: err},
                'finished removing vm fs watchers for %s', zone);
            cb(err);
        });
    }
};

/*
 * Stop and start all watchers for a specific zone
 */
Vminfod.prototype.restartVmWatchers =
    function restartVmWatchers(zonename, callback) {

    var self = this;

    assert.string(zonename, 'zonename');
    assert.func(callback, 'callback');

    vasync.pipeline({funcs: [
        function restartVmWatchersStopWatchers(_, cb) {
            self.stopVmWatchers(zonename, function stopWatchersDone(err) {
                /*
                 * If we fail here it's not a big deal since we will restart the
                 * watchers below.
                 */
                if (err) {
                    self.log.warn(err, 'restartVmWatchers stopWatchers error');
                }
                cb();
            });
        },
        function restartVmWatchersStartWatchers(_, cb) {
            self.startVmWatchers(zonename, cb);
        }
    ]}, callback);
};

/*
 * Return a JSON serialized string for a given vm.  This will return
 * a cached object, or generate the contents and cache the result.
 *
 * Returns undefined if the vm is not found
 */
Vminfod.prototype.serializeVm = function serializeVm(zonename) {
    var self = this;

    if (!self.vmobjs_json.hasOwnProperty(zonename)) {
        self.vmobjs_json[zonename] = JSON.stringify(self.vmobjs[zonename]);
    }

    return self.vmobjs_json[zonename];
};

/*
 * Return a JSON serialized string for all zones.
 */
Vminfod.prototype.serializeVms = function serializeVms() {
    var self = this;

    var json = '[';
    var zones = Object.keys(self.vmobjs);

    zones.forEach(function forEachZoneSerialize(zone, index) {
        json += self.serializeVm(zone);

        if (index < zones.length - 1) {
            json += ',';
        }
    });

    json += ']';

    return json;
};

/*
 * reset() hard reset the data to ensure integrity
 *
 * This function will:
 *   1- pause the event queue
 *   2- fetch new vm_data
 *   3- fast-forward the event queue
 *   4- compare datasets
 *   5- replace vm_data with vm_data_tmp if the sets are different
 *   6- refresh vmobjs if the sets are different
 *   7- resume the event queue
 */
Vminfod.prototype.reset = function reset(callback) {
    var self = this;

    var old_vm_data;
    var obj = {
        started: process.hrtime(),
        vmChanges: [],
        cacheChanges: null
    };

    vasync.pipeline({funcs: [
        // pause the queue
        function resetPauseQueue(_, cb) {
            self.setState('paused');
            self.setStatus('pausing the event queue');
            self.log.debug('%d VMs total', Object.keys(self.vmobjs).length);

            self.event_queue.pause({timeout: 5 * 60 * 1000},
                function queuePaused(err) {

                if (err) {
                    self.log.warn('failed to pause the queue: %s',
                        err.message);
                    cb(err);
                    return;
                }

                cb();
            });
        },
        // fetch new data
        function resetFetchNewData(_, cb) {
            self.setStatus('fetching vm cache data');
            self._loadVmData(function loadVmDataDone(err, results) {
                if (err) {
                    self.log.error('failed to fetch new vm_data');
                    cb(err);
                    return;
                }

                self.vm_data_tmp = results;
                cb();
            });
        },
        // fast-forward the queue
        function resetFastForwardQueue(_, cb) {
            var now = process.hrtime();
            self.setStatus('fast-forwarding the queue to %j', now);
            self.event_queue.fastForward(now, {timeout: 5 * 60 * 1000},
                function queueFastForwarded(err) {

                if (err) {
                    self.log.warn('failed to fast-forward queue: %s',
                        err.message);
                    cb(err);
                    return;
                }

                cb();
            });
        },
        // compare/update vmobjs
        function resetCompareVmobjSets(_, cb) {
            self.setStatus('comparing vmobj sets');

            var changes = diff(self.vm_data, self.vm_data_tmp);

            // if changes are empty, we have nothing left to do
            if (changes.length === 0) {
                self.log.info('vmobj sets are in sync');
                cb();
                return;
            }

            self.log.warn({changes: changes}, 'vm_data and vm_data_tmp diff');

            obj.cacheChanges = changes;

            self.setStatus('synchronizing data');

            // keep a temporary reference to compare against
            old_vm_data = self.vm_data;

            // replace the data with new
            self.vm_data = self.vm_data_tmp;

            vasync.pipeline({funcs: [
                // create vmobjs we don't know about
                function createNewVmobjs(__, cb2) {
                    var new_objs = self.vm_data.zoneadm_objects;
                    var keys = Object.keys(new_objs);

                    vasync.forEachParallel({
                        inputs: keys,
                        func: function createNewVmobj(zonename, cb3) {
                            var old_objs = old_vm_data.zoneadm_objects;
                            if (old_objs.hasOwnProperty(zonename)) {
                                cb3();
                                return;
                            }

                            obj.vmChanges.push({
                                zonename: zonename,
                                action: 'create'
                            });
                            self.createVmobj(zonename, cb3);
                        }
                    }, cb2);
                },
                // delete vmobjs we shouldn't know about
                function deleteOldVmobjs(__, cb2) {
                    var old_objs = old_vm_data.zoneadm_objects;
                    var keys = Object.keys(old_objs);

                    vasync.forEachParallel({
                        inputs: keys,
                        func: function deleteOldVmobj(zonename, cb3) {
                            var new_objs = self.vm_data.zoneadm_objects;
                            if (new_objs.hasOwnProperty(zonename)) {
                                cb3();
                                return;
                            }

                            obj.vmChanges.push({
                                zonename: zonename,
                                action: 'delete'
                            });
                            self.deleteVmobj(zonename, cb3);
                        }
                    }, cb2);
                },
                // refresh the rest
                function refreshModifiedVmobjs(__, cb2) {
                    vasync.forEachParallel({
                        inputs: Object.keys(self.vmobjs),
                        func: function refreshModifiedVmobj(zone, cb3) {
                            self.refreshVmobj(zone,
                                function refreshVmobjDone(err, o) {

                                var changeObj;

                                if (o && (o.changed || o.deleted)) {
                                    changeObj = {
                                        zonename: zone,
                                        action: o.deleted ? 'delete' : 'modify'
                                    };
                                    if (changeObj.action === 'modify') {
                                        changeObj.changes = o.changes;
                                    }

                                    obj.vmChanges.push(changeObj);
                                }

                                cb3(err);
                            });
                        }
                    }, cb2);
                }
            ]}, cb);
        }
    ]}, function resetDone(err) {
        // always make sure vminfod goes back to a running state
        self.setState('running');
        self.setStatus('working');
        self.vm_data_tmp = undefined;

        var ended = process.hrtime();
        var delta = hrtime.hrtimeDelta(ended, obj.started);
        var prettyDelta = hrtime.prettyHrtime(delta);

        if (obj.cacheChanges) {
            obj.ended = ended;
            obj.delta = delta;
            obj.prettyDelta = prettyDelta;
            self.refresh_log.write(obj);
        }

        self.log.debug({obj: obj}, 'self.reset() took %s: %d vms changed',
            prettyDelta, obj.vmChanges.length);

        self.log.info('resuming the event queue');
        self.event_queue.resume();


        callback(err);
    });
};

/*
 * loadVmData() loads a cache object from vmload.getZoneData
 *
 * Arguments:
 *   'callback' - will be called with (err, cache)
 *
 * This function will load a cache object from vmload.getZoneData
 * passing a nocache: true flag to ensure the cache object is generated
 * from raw data.
 *
 */
Vminfod.prototype._loadVmData = function _loadVmData(callback) {
    var self = this;

    var opts = {
        log: self.log,
        nocache: true,
        keepalive: true
    };
    vmload.getZoneData(null, opts, function getZoneDataDone(err, cache) {
        if (err) {
            self.log.error({err: err}, 'failed vmload.getZoneData: %s',
                err.message);
            callback(err);
            return;
        }

        callback(null, cache);
    });
};

/*
 * Called when a new VM is seen
 *
 * This will create all internal variables needed for the VM, as well as
 * emit a "create" event
 */
Vminfod.prototype.createVmobj = function createVmobj(zonename, callback) {
    var self = this;

    var uuid;

    if (self.vmobjs.hasOwnProperty(zonename)) {
        self.log.warn('createVmobj(%s) called for zone already known about',
            zonename);
        callback();
        return;
    }

    vasync.pipeline({funcs: [
        function createVmobjGetUUID(_, cb) {
            /*
             * Figure out the zone UUID from the zonename seen.  If the
             * zonename is a UUID, assume that it is the zones UUID and skip
             * the call to getZoneRecords.
             */
            if (utils.isUUID(zonename)) {
                uuid = zonename;
                cb();
                return;
            }

            var opts = {
                log: self.log
            };
            getZoneRecords(zonename, opts,
                function getZoneRecordsDone(err, records) {

                if (err) {
                    self.log.debug({err: err}, 'failed to getZoneRecords(%s)',
                        zonename);
                    cb(err);
                    return;
                }

                var keys = Object.keys(records);

                assert.equal(keys.length, 1, 'Only 1 record found');

                uuid = keys[0];

                self.log.warn('VM zonename "%s" does not match uuid "%s"',
                    zonename, uuid);

                cb();
            });
        }, function createVmobjAssertUUID(_, cb) {
            assert.uuid(uuid, 'uuid');

            self.log.debug({uuid: uuid, zonename: zonename},
                'createVmobj zonename: %s -> uuid: %s', zonename, uuid);

            cb();
        }, function createVmobjGetZoneData(_, cb) {
            var opts = {
                log: self.log,
                keepalive: true
            };
            vmload.getZoneData(uuid, opts, function getZoneDataDone(err, res) {
                if (err) {
                    self.log.error('failed to getZoneData(%s): %s',
                        uuid, err.message);
                    cb(err);
                    return;
                }

                if (self.vm_data_tmp !== undefined)
                    self.zone_vm_data_tmp[zonename] = res;
                self.zone_vm_data[zonename] = res;

                cb();
            });
        }, function createVmobjMergeVmDatasets(_, cb) {
            self.mergeZoneVmDatasets(zonename);
            cb();
        }, function createVmobjGetVmobj(_, cb) {
            vasync.forEachParallel({
                inputs: self.vmDatasets(),
                func: function getVmobj(vm_data, cb2) {
                    var opts = {
                        log: self.log,
                        cache: vm_data,
                        keepalive: true,
                        loadManually: true
                    };
                    vmload.getVmobj(uuid, opts,
                        function getVmobjDone(err2, vmobj) {

                        if (err2) {
                            self.log.error('failed to getVmobj(%s): %s',
                                uuid, err2.message);
                            cb2(err2);
                            return;
                        }

                        if (self.vmobjs.hasOwnProperty(zonename)) {
                            self.log.error('vmobj already created for %s',
                                zonename);
                            cb2();
                            return;
                        }

                        assert.object(vmobj, 'vmobj');
                        assert.uuid(vmobj.uuid, 'vmobj.uuid');

                        self.vmobjs[zonename] = vmobj;
                        self.startVmWatchers(zonename,
                            function startVmWatchersDone(err) {

                            self.log.info('started watching %s', zonename);
                            self.emit('create', vmobj);
                            cb2();
                        });
                    });
                }
            }, cb);
        }
    ]}, function createVmobjDone(err) {
        if (err) {
            /*
             * We ignore any errors here as they will be rectified when the
             * periodic timer runs.
             */
            self.log.error({err: err}, 'createVmobj(%s) (uuid: %s)',
                zonename, uuid);
        }
        callback();
    });
};

/*
 * Called when a VM is deleted
 *
 * This will remove all internal variables needed by the VM as well as emit a
 * "delete" event
 */
Vminfod.prototype.deleteVmobj = function deleteVmobj(zonename, callback) {
    var self = this;

    if (!self.vmobjs.hasOwnProperty(zonename)) {
        self.log.warn('deleteVmobj(%s) called for non-existent zone',
            zonename);
        callback();
        return;
    }

    var obj = {
        zonename: zonename,
        uuid: self.vmobjs[zonename].uuid
    };
    assert.uuid(obj.uuid, 'obj.uuid for: ' + zonename);

    vasync.pipeline({funcs: [
        // delete vmobj
        function deleteVmobjRemoveCache(_, cb) {
            delete (self.vmobjs)[zonename];
            delete (self.vmobjs_json)[zonename];
            cb();
        },
        // clean vm_data
        function deleteVmobjCleanVmData(_, cb) {
            self.vmDatasets().forEach(function forEachVmDataset(data) {
                for (var key in data) {
                    if (data[key].hasOwnProperty(zonename)) {
                        delete (data[key])[zonename];
                    }
                }
            });
            cb();
        },
        // unregister events
        function deleteVmobjStopWatchers(_, cb) {
            self.stopVmWatchers(zonename, cb);
        }
    ]}, function deleteVmobjDone(err) {
        if (err) {
            self.log.error({err: err}, 'deleteVmobj(%s)', zonename);
            /*
             * If this fails we keep going since the periodic timer refresh
             * will handle cleaning up any stray files that haven't been
             * unwatched.
             */
        }
        self.log.info('stopped watching %s', zonename);
        self.emit('delete', obj);
        callback();
    });
};

/*
 * refreshVmobj() refreshes the cached vmobj and reports any changes
 *
 * Process:
 *     1) refresh the vm_data cache by calling vmload.getZoneData
 *     2) request a new vmobj by calling vmload.getVmobj
 *     3) analyze vmobj delta
 *     4) if different:
 *       4a) replace the vmobj with the new vmobj
 *       4b) log the delta
 *       4c) inform any subscribers of the delta
 */
Vminfod.prototype.refreshVmobj =
    function refreshVmobj(zonename, vm_datasets, callback) {

    var self = this;

    var ret = {
        changed: false,
        deleted: false,
        changes: []
    };

    if (typeof (vm_datasets) === 'function') {
        callback = vm_datasets;
        self.cloneVmDatasets(zonename);
        vm_datasets = self.vmDatasets(zonename);
    }

    // short-circuit if this vmobj doesn't exist
    if (!self.vmobjs.hasOwnProperty(zonename)) {
        self.log.debug('cannot refresh vmobj, doesn\'t exist');
        self.resetVmDatasets(zonename);
        callback(null, ret);
        return;
    }

    var vmobj;
    vasync.pipeline({funcs: [
        // refresh vm_data cache
        function refreshVmobjRefreshZoneData(_, cb) {
            self.log.debug('refreshing zoneData for %s', zonename);
            vasync.forEachParallel({
                inputs: vm_datasets,
                func: function getZoneData(vm_data, cb2) {
                    var opts = {
                        log: self.log,
                        cache: vm_data,
                        keepalive: true
                    };
                    vmload.getZoneData(zonename, opts,
                        function getZoneDataDone(err, cache) {

                        /*
                         * We don't care about cache here because we provided a
                         * cache object that was transformed by reference. So,
                         * cache in this case is just a reference to vm_data,
                         * which we already store globally. The idea here is
                         * that we just fill in the holes that we previously
                         * created.
                         */

                        if (err) {
                            self.log.error({err: err},
                                'failed to refresh vmobj %s: getZoneData %s',
                                zonename, err.message);

                            if (err.code === 'ENOENT'
                                && err.message.
                                match(/No such zone configured$/)) {

                                ret.deleted = true;
                            }

                            cb2(err);
                            return;
                        }

                        cb2();
                    });
                }
            }, cb);
        },
        // merge zone_vm_objs
        function refreshVmobjMergeZoneDataset(_, cb) {
            self.mergeZoneVmDatasets(zonename);
            cb();
        },
        // request a new vmobj
        function refreshVmobjRequestNewVmobj(_, cb) {
            self.log.debug('requesting new vmobj for %s', zonename);
            var opts = {
                log: self.log,
                keepalive: true,
                cache: self.vm_data,
                loadManually: true
            };
            vmload.getVmobj(zonename, opts,
                function getVmobjDone(err, _vmobj) {

                if (err) {
                    self.log.error({err: err},
                        'unable to refresh vmobj for %s, failed getVmobj',
                        zonename);

                    if (err.code === 'ENOENT'
                        && err.message.match(/No such zone configured$/)) {

                        ret.deleted = true;
                    }

                    cb(err);
                    return;
                }

                vmobj = _vmobj;
                cb();
            });
        },
        // analyze delta, update live copy
        function refreshVmobjAnalyzeDelte(_, cb) {
            var changes;
            try {
                changes = diff(self.vmobjs[zonename], vmobj, {
                    map: DIFF_MAP
                });
            } catch (err) {
                self.log.error({
                    from: self.vmobjs[zonename],
                    to: vmobj,
                    err: err},
                    'failed to calculate object diff');
                throw err;
            }

            if (changes.length > 0) {
                self.vmobjs[zonename] = vmobj;
                delete (self.vmobjs_json[zonename]);
                ret.changed = true;
                ret.changes = changes;
                self.emit('modify', vmobj, changes);
            }

            cb();
        }
    ]}, function refreshVmobjDone(err) {
        if (ret.deleted) {
            assert(err, 'error not set when ret.deleted');
            delete ret.changes;

            self.log.debug({uuid: zonename},
                'marking %s as deleted', zonename);

            self.deleteVmobj(zonename, function deleteVmobjDone(err2) {
                if (err2) {
                    self.log.error({uuid: zonename, err: err2},
                        'error marking %s as deleted',
                        zonename);
                } else {
                    self.log.debug({uuid: zonename},
                        'successfully marked %s as deleted',
                        zonename);
                }

                callback(err2, ret);
            });
            return;
        }

        callback(err, ret);
    });
};

/*
 * return the active data objects for a given zone (if zonename is set)
 * or for all zones.
 */
Vminfod.prototype.vmDatasets = function vmDatasets(zonename) {
    var self = this;
    var ret = [];

    if (zonename) {
        ret.push(self.zone_vm_data[zonename]);
        if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
            ret.push(self.zone_vm_data_tmp[zonename]);
        }
    } else {
        ret.push(self.vm_data);
        if (self.vm_data_tmp !== undefined) {
            ret.push(self.vm_data_tmp);
        }
    }

    return (ret);
};

/*
 * remove the given zone from the internal zone data
 */
Vminfod.prototype.resetVmDatasets = function resetVmDatasets(zonename) {
    var self = this;

    if (self.zone_vm_data_tmp.hasOwnProperty(zonename)) {
        delete (self.zone_vm_data_tmp)[zonename];
    }

    if (self.zone_vm_data.hasOwnProperty(zonename)) {
        delete (self.zone_vm_data)[zonename];
    }
};

/*
 * copy a single zone's information from the "all zones" cache to an
 * individual cache specific to the zone
 */
Vminfod.prototype.cloneVmDatasets = function cloneVmDatasets(zonename) {
    var self = this;

    function cloneVmDataset(from, to) {
        Object.keys(from).forEach(function cloneForEach(key) {
            switch (key) {
            case 'dataset_objects':
            case 'sysinfo':
                to[key] = from[key];
                break;
            default:
                if (!to.hasOwnProperty(key)) {
                    to[key] = {};
                }
                if (from[key].hasOwnProperty(zonename)) {
                    to[key][zonename] = from[key][zonename];
                }
                break;
            }
        });
    }

    if (self.vm_data_tmp !== undefined) {
        self.zone_vm_data_tmp[zonename] = {};
        cloneVmDataset(self.vm_data_tmp, self.zone_vm_data_tmp[zonename]);
    }

    self.zone_vm_data[zonename] = {};
    cloneVmDataset(self.vm_data, self.zone_vm_data[zonename]);
};

/*
 * take a zones specific information and put it in the "all zones" cache, as
 * well as clear the individual zones cache
 */
Vminfod.prototype.mergeZoneVmDatasets = function mergeZoneVmDatasets(zonename) {
    var self = this;

    /*
     * The rationale here is to iterate through all of the keys in the from
     * object and check for a zonename key. If it exists, copy it over. Then
     * we remove any objects containing the zonename key in the to object
     * that aren't in the from object, to ensure we don't leave any cruft.
     */
    function mergeVmDataset(from, to) {
        Object.keys(from).forEach(function mergeForEach(key) {
            if (from[key].hasOwnProperty(zonename)) {
                to[key][zonename] = from[key][zonename];
            } else {
                if (to[key].hasOwnProperty(zonename)) {
                    delete (to[key])[zonename];
                }
            }
        });
    }

    /*
     * Any time a point of data has been merged, we also need to clear
     * the cached JSON for this data. The JSON will later be generated
     * and cached as needed by incoming requests.
     */
    function clearCache(from) {
        Object.keys(from).forEach(function clearForEach(key) {
            if (from[key].hasOwnProperty(zonename)
                && self.vm_data_json.hasOwnProperty(key)
                && self.vm_data_json[key].hasOwnProperty(zonename)) {

                delete (self.vm_data_json[key])[zonename];
            }
        });
    }

    if (self.vm_data_tmp !== undefined
        && self.zone_vm_data_tmp.hasOwnProperty(zonename)) {

        mergeVmDataset(self.zone_vm_data_tmp[zonename], self.vm_data_tmp);
        clearCache(self.zone_vm_data_tmp[zonename]);
    }

    if (self.zone_vm_data.hasOwnProperty(zonename)) {
        mergeVmDataset(self.zone_vm_data[zonename], self.vm_data);
        clearCache(self.zone_vm_data[zonename]);
    }

    self.resetVmDatasets(zonename);
};

/*
 * poke holes in cache objects for a specific zone
 */
Vminfod.prototype.invalidateZoneDataCache =
    function invalidateZoneDataCache(zonename, vm_datasets, contexts) {

    vm_datasets.forEach(function invalidateForEach(data) {
        contexts.forEach(function contextForEach(context) {
            if (!data.hasOwnProperty(context))
                return;

            if (data[context].hasOwnProperty(zonename))
                delete (data[context])[zonename];

            if (Object.keys(data[context]).length === 0)
                delete data[context];
        });
    });
};

/*
 * handleZoneEvent() is a callback for a ZoneWatcher
 *
 * Process:
 *
 *   First we extract the zonename property from the event, then see if we
 *   have any vmobjs registered with that zonename. If not, then this must
 *   be a vm create, which we will:
 *     1) fetch the vmobj from vmload.getVmobj
 *     2) register observers
 *     3) inform subscribers of the new vmobj
 *   If this is a vm that we already know about, we will:
 *     1) invalidate the relevant pieces of the vm_data
 *     2) refresh the vmobj by calling refreshVmobj
 */
Vminfod.prototype.handleZoneEvent = function handleZoneEvent(obj) {
    var self = this;

    assert.object(obj, 'obj');
    assert.string(obj.zonename, 'obj.zonename');

    var zonename = obj.zonename;
    var meta = util.format('zonename: %s newstate: %s',
        zonename, obj.newstate);
    var vm_datasets;

    self.log.debug({obj: obj}, 'handleZoneEvent: %s', meta);

    self.event_queue.enqueue({
        description: 'handle zone event - zonename: ' + zonename,
        timeout: QUEUE_TASK_TIMEOUT,
        func: function handleZoneEventTask(extras, callback) {
            if (!self.vmobjs.hasOwnProperty(zonename)) {
                // a new vm!
                self.createVmobj(zonename, callback);
                return;
            }

            self.cloneVmDatasets(zonename);
            vm_datasets = self.vmDatasets(zonename);

            // remove pieces of the cache that might have been affected
            var contexts = [
                'last_modified',
                'pids',
                'zoneadm_objects',
                'zonexml_objects',
                'zoneinfo_objects'
            ];

            self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
            self.refreshVmobj(zonename, vm_datasets, callback);
        }
    });
};

/*
 * handleFsEvent() is a callback for a FsWatcher
 */
Vminfod.prototype.handleFsEvent = function handleFsEvent(obj) {
    var self = this;

    var zonexml_re = /\/etc\/zones\/(.+)\.xml/;
    var metadata_re = /\/zones\/(.+)\/config\/.+\.json/;
    var lastexit_re = /\/zones\/(.+)\/lastexited/;
    var contexts;
    var matches;
    var meta;
    var vm_datasets;
    var zonename;

    assert.object(obj, 'obj');
    assert.string(obj.pathname, 'obj.pathname');

    meta = util.format('pathname: %s (%s)',
        obj.pathname, obj.changes || obj.type);

    self.log.debug({obj: obj}, 'handleFsEvent: %s', meta);

    // zone XML file
    if ((matches = obj.pathname.match(zonexml_re))) {
        zonename = matches[1];

        self.event_queue.enqueue({
            description: 'handle zonexml fs change - ' + meta,
            timeout: QUEUE_TASK_TIMEOUT,
            func: function handleZoneXMLEventTask(extras, callback) {
                // short-circuit if this vmobj doesn't exist
                if (!self.vmobjs.hasOwnProperty(zonename)) {
                    extras.log.debug('vmobj doesn\'t exist for %s',
                        zonename);
                    callback();
                    return;
                }

                switch (obj.type) {
                case 'delete':
                    /*
                     * A delete event has been seen for the zone's XML file.  It
                     * is possible however that the zone has not actually
                     * been deleted - this can happen in the event where a file
                     * is moved to the location of the zones XML file from a
                     * different filesystem, for example:
                     *
                     * # cp /etc/zones/<uuid>.xml /var/tmp/
                     * # mv /var/tmp/<uuid>.xml /etc/zones/
                     *
                     * This will trigger a delete event for the zone's XML file.
                     *
                     * To handle this situation, we follow up with a stat(2) on
                     * the file to see if it is actually gone.  If the file is
                     * gone, we delete the vmobj from our cache and emit a
                     * "delete" event.  If it is still present, we treat this
                     * event as a "change" and not "delete" event.
                     *
                     * Because there is a delay from when the delete event is
                     * seen, and when the stat(2) of the file is done, it is
                     * possible that the zone could have been deleted and then a
                     * new zone with the same name (zonename, not alias) was
                     * created immediately after.  In this specific scenario,
                     * vminfod will *not* be aware of that change, nor will
                     * it notify its subscribers of it.  This is similar to how
                     * if a ZFS modification (or really, any VM modification) is
                     * done and then reverted right after, vminfod may miss the
                     * transient state.
                     *
                     * This is OK, because tools like `vmadm` are vminfod-aware,
                     * and will properly block on certain events (like "create"
                     * or "delete") being seen by vminfod before proceeding.  If
                     * a tool like `zonecfg` is used, or even just editing the
                     * raw zone XML file (not advised), you are on your own.
                     * vminfod will guarantee eventual consistency, but can't
                     * guarantee that intermediate states will be seen or
                     * reported.
                     */
                    extras.log.debug('%s delete event, checking file existence',
                        obj.pathname);

                    fs.stat(obj.pathname, function (err, stats) {
                        if (err && err.code === 'ENOENT') {
                            extras.log.debug('%s deleted, removing VM',
                                obj.pathname);
                            self.deleteVmobj(zonename, callback);
                            return;
                        }

                        if (err) {
                            extras.log.error(err, 'unexpected error stating %s',
                                obj.pathname);
                            callback();
                            return;
                        }

                        extras.log.debug('%s still exists, updating zone data',
                            obj.pathname);
                        handleChange(callback);
                    });
                    break;
                case 'change':
                    extras.log.debug('%s modified', obj.pathname);
                    handleChange(callback);
                    break;
                default:
                    extras.log.warn({obj: obj},
                        'unhandled fs change type "%s"',
                        obj.type);
                    callback();
                    break;
                }

                function handleChange(cb) {
                    assert.func(cb, 'cb');

                    self.cloneVmDatasets(zonename);
                    vm_datasets = self.vmDatasets(zonename);

                    // clear the missing pieces and refresh
                    contexts = [
                        'last_modified',
                        'zonexml_objects',
                        'zoneinfo_objects'
                    ];

                    self.invalidateZoneDataCache(zonename, vm_datasets,
                        contexts);
                    self.refreshVmobj(zonename, vm_datasets, cb);
                }
            }
        });

    // zone metadata file
    } else if ((matches = obj.pathname.match(metadata_re))) {
        zonename = matches[1];

        self.enqueueMetadataFileUpdate(zonename, meta);

    // zone lastexited file
    } else if ((matches = obj.pathname.match(lastexit_re))) {
        zonename = matches[1];

        self.enqueueLastexitFileUpdate(zonename, meta);

    // sysinfo
    } else if (obj.pathname === SYSINFO_FILE) {
        self.enqueueSysinfoFileUpdate(meta);

    } else {
        self.log.warn('unhandled event for file: %s', obj.pathname);
    }
};

/*
 * handleZpoolEvent() is a callback for a zpool watcher
 *
 * All zpool related events for the system will funnel through this function.
 * Filtering will be done on the incoming events to determine 1. if any data
 * should be reloaded and 2. if so, how much data.  We attempt to be as
 * performant as possible by only reloading data when absolutely necessary, and
 * only reloading the necessary bits of information.
 *
 * Any filtering that can be done without concern for the existing VMs on the
 * system is done immediately (before pushing any tasks to the event queue).
 * Any filtering that relies on knowing VM objects on the system is done as part
 * of the task pushed to the queue.  This ensures that, when a ZFS event is
 * processed and looks at which VMs are on the system, it has the most
 * up-to-date version of the VMs possible.  For example, if a zone event came in
 * followed immediately after by a ZFS event, the zone event is what is
 * responsible for letting vminfod know that a VM has been created.  If the ZFS
 * event filtering logic were to run before the VM was considered created, the
 * ZFS event would be prematurely filtered out and never properly processed
 * because the filtering logic wouldn't find a corresponding VM to the dataset
 * modified.
 *
 * The non VM filtering logic will simply look at the type of event coming in,
 * and determine if any are duplicates, or would result in duplicate work being
 * done.  An example of this is a `zfs rollback` which can result in 0 or many
 * "destroy" events for any snapshots that are removed during the rollback
 * process.  This function will filter out any excess events that won't result
 * in any modifications for the VM objects that vminfod cares about.
 *
 * The VM filtering logic will do a couple of steps that can be seen below.
 * The quick synopsis of them is:
 *
 * 1. Filter out events for zpools that don't contain VMs.
 * 2. Filter out events for child datasets of a VMs delegated dataset.
 *
 * Before a task is pushed to the queue, there is logic to make the "action" as
 * seen from the sysevent, to an "action" which denotes what task to do that is
 * specific to vminfod.  For example, a sysevent of "clone", "create", or
 * "snapshot" will result in the "fetchAndCopy" task of vminfod.  There is
 * nothing inherently special about the name "fetchAndCopy" - descriptive
 */
Vminfod.prototype.handleZpoolEvent = function handleZpoolEvent(obj) {
    var self = this;

    var _s;
    var action;
    var description;
    var dsname;
    var name;
    var parts;
    var rollbackRe = /\/%rollback$/;
    var sections = ['datasets', 'mountpoints', 'snapshots'];
    var snapname;
    var zpool;
    var meta = util.format('dsname: %s action: %s %s',
        obj.dsname, obj.action, obj.extras).trim();

    self.log.debug({obj: obj}, 'handleZpoolEvent: %s', meta);

    /*
     * Break the "dsname" property into the dataset name and the snapshot name
     * (may be empty).
     *
     */
    name = obj.dsname;
    _s = name.split('@');
    dsname = _s[0];
    snapname = _s[1];

    assert.string(dsname, 'dsname');
    assert.optionalString(snapname, 'snapname');
    assert(!_s[2], 'invalid dataset name');

    /*
     * ZFS sysevents may end in "/%rollback" during a `rollback` command; "%" is
     * a special character that will never be in a valid dataset name.
     *
     * A `zfs rollback` command may result in multiple sysevents, for example:
     *
     * # sysevent -j EC_zfs ESC_ZFS_history_event | json -ag \
     *     data.history_dsname data.history_internal_name
     * zones/foo/%rollback destroy
     * zones/foo/%rollback clone swap
     *
     * This can also be more if snapshots are deleted as a result of the
     * `rollback`.  The only action we care about is a "clone swap" for a
     * dataset that ends in "/%rollback", anything else will be discarded.
     *
     * "/%rollback" will be removed from the dsname variable.
     */
    if (dsname.match(rollbackRe)) {
        if (obj.action !== 'clone swap') {
            self.log.debug({obj: obj},
                'ignoring %rollback dataset for action "%s"', obj.action);
            return;
        }

        dsname = dsname.replace(rollbackRe, '');
    }

    /*
     * break the incoming zfs dataset into an array
     * ex => ['zones', '<uuid>', 'config']
     */
    parts = dsname.split('/');
    zpool = parts[0];

    assert.string(zpool, 'zpool');

    /*
     * Based on the "action" seen from the ZFS sysevent, we determine ahead of
     * time what kind of action we will need to take as a response.  By doing
     * this we can dedup the tasks pushed to the queue, because while the ZFS
     * sysevents might differ, the actions we take as a response may be the
     * same, in which case they only need to be done once.
     */
    switch (obj.action) {
    case 'clone':
    case 'create':
    case 'snapshot':
        action = 'fetchAndCopy';
        break;
    case 'set':
    case 'hold':
    case 'release':
    case 'rename':
    case 'finish receiving':
        action = 'fetchExpireAndCopy';
        break;
    case 'clone swap': // rollback
        action = 'fetchExpireCopyAndRollback';
        break;
    case 'destroy':
        action = 'expire';
        break;
    case 'receive':
        // do nothing
        self.log.debug('ignoring action: %s', obj.action);
        return;
    default:
        self.log.fatal('unknown action: %s', obj.action);
        return;
    }

    assert.string(action, 'action');
    description = util.format('dsname: %s action: %s', obj.dsname, action);

    self.event_queue.enqueue({
        description: 'handle zfs event - ' + description,
        timeout: QUEUE_TASK_TIMEOUT,
        func: function handleZfsEventTask(extras, cb) {
            var datasetObj = {};
            var uuid;

            /*
             * If this doesn't look like it could be a zonepath dataset, ensure
             * that the dataset's zpool is one that is used by any VM.
             */
            if (parts.length !== 2) {
                var zpools = self.zonesZpools();
                if (!zpools.hasOwnProperty(zpool)) {
                    self.log.debug({zpool: zpool, zpools: Object.keys(zpools)},
                        'ignoring %s zfs event for zpool: %s', dsname, zpool);
                    cb();
                    return;
                }
            }

            if (parts[1]) {
                /*
                 * Attempt to extract a UUID from the second part.  This will
                 * succeed for KVM instances (for example) that have a dataset
                 * like /zones/<uuid>-disk0.
                 */
                uuid = extractUUID(parts[1]);
            }

            /*
             * If we extracted a UUID, we then check to see if it maps to a VM
             * that we know about.  It can be the case where the ZFS dataset
             * being modified here has a UUID as the second part of its name but
             * does not belong to a VM (a simple example is the ZFS dataset of
             * an image).  We unset the `uuid` variable if it does not belong to
             * a valid VM and proceed as usual without refreshing a specific VM
             * at the end.
             */
            if (uuid && !self.vmobjs.hasOwnProperty(uuid)) {
                self.log.debug('UUID "%s" extracted for a non-vm', uuid);
                uuid = null;
            }

            /*
             * Check to see if the dataset being modified will affect the VM
             * object itself, or is a child dataset (via delegated datasets or
             * manual intervention by the user) that can be ignored.
             */
            if (uuid && parts[1] === uuid) {
                /*
                 * If the dataset name is for a child of the zone's delegated
                 * dataset, we ignore it here as it won't affect the VM object.
                 * i.e.:
                 *
                 * "/zones/<uuid>/data/..."
                 */
                if (parts[2] && parts[2] === DELEGATED_DATASET_NAME
                    && parts[3]) {

                    self.log.debug({zpool: zpool, uuid: uuid, dataset: dsname},
                        'ignoring zfs event for delegated child dataset %s',
                        dsname);
                    cb();
                    return;
                }
            }

            /*
             * - `zonepath` is set to the dataset that was affected (getDatasets
             * requires it be passed with a leading '/' character).
             * - `depth` is set to 1 to ensure that any snapshots for the given
             * dataset affected are also loaded.  This is important for VM
             * properties such as "indestructible_zoneroot" which is determined
             * based on the presence of a snapshot on the zone root dataset.
             */
            datasetObj.zonepath = util.format('/%s', dsname);
            datasetObj.depth = 1;

            switch (action) {
            case 'fetchAndCopy':
                fetch(datasetObj, function fetchAndCopyDone(err, cache) {
                    if (err) {
                        finish();
                        return;
                    }
                    copy(cache);
                    finish();
                });
                return;
            case 'fetchExpireAndCopy':
                fetch(datasetObj, function fetchExpireAndCopyDone(err, cache) {
                    if (err) {
                        finish();
                        return;
                    }
                    expire();
                    copy(cache);
                    finish();
                });
                return;
            case 'fetchExpireCopyAndRollback':
                self.log.debug('zfs rollback seen for VM "%s" on %s',
                    uuid, dsname);

                /*
                 * In the event of a ZFS rollback for a zones' dataset (or one
                 * of its child datasets), the procedure is fairly involved.
                 * Because files may be modified or deleted as a result of the
                 * rollback operation, we process the following tasks:
                 *
                 * 1. (finish this task) ZFS event to fetchExpireCopyAndRollback
                 * 2. restart the VM's FS watches
                 * 3. check the metadata files (json files in config/ for the
                 *    zone)
                 * 4. check the last exited file (lastexited)
                 */
                if (uuid) {
                    self.event_queue.enqueue({
                        description: util.format('zone %s restart watchers',
                            uuid),
                        timeout: QUEUE_TASK_TIMEOUT,
                        func: function
                            zfsRollbackRestartWatcher(fsExtras, callback) {
                            /*
                             * Ensure the VM exists before trying to restart
                             * its file watchers.  It can be the case that
                             * the VM existed when the "rollback" event came
                             * in, but has since been deleted.
                             */
                            if (!self.vmobjs.hasOwnProperty(uuid)) {
                                fsExtras.log.debug(
                                    'vmobj doesn\'t exist for %s',
                                    uuid);
                                callback();
                                return;
                            }

                            self.restartVmWatchers(uuid, callback);
                        }
                    });

                    self.enqueueMetadataFileUpdate(uuid, 'rollback');
                    self.enqueueLastexitFileUpdate(uuid, 'rollback');
                }

                fetch(datasetObj,
                    function fetchExpireCopyAndRollbackDone(err, cache) {

                    if (err) {
                        finish();
                        return;
                    }
                    expire();
                    copy(cache);
                    finish();
                });
                return;
            case 'expire':
                expire();
                finish();
                break;
            default:
                assert(false, util.format('unknown action: %s', action));
                break;
            }

            function finish() {
                if (!uuid) {
                    cb();
                    return;
                }

                extras.log.debug('refreshing vmobj %s after zfs event', uuid);
                self.refreshVmobj(uuid, cb);
            }
        }
    });

    function expire() {
        function expireObjects(ds_objects) {
            sections.forEach(function forEachSection(section) {
                if (!ds_objects.hasOwnProperty(section)) {
                    return;
                }

                switch (section) {
                case 'mountpoints':
                    for (var key in ds_objects[section]) {
                        if (ds_objects[section][key] === name) {
                            delete (ds_objects[section])[key];
                        }
                    }
                    break;
                default:
                    if (ds_objects[section].hasOwnProperty(name)) {
                        delete (ds_objects[section])[name];
                    }
                    break;
                }

                if (snapname && section === 'snapshots') {
                    // remove the snapshot here as well
                    if (ds_objects[section].hasOwnProperty(dsname)) {
                        ds_objects[section][dsname] =
                            ds_objects[section][dsname].filter(
                            function filterSnap(o) {

                            return o.snapname !== snapname;
                        });
                    }
                }
            });
        }

        self.vmDatasets().forEach(function forEachDatasetExpire(data) {
            expireObjects(data.dataset_objects);
        });

        if (self.vm_data_json.hasOwnProperty('dataset_objects')) {
            expireObjects(self.vm_data_json.dataset_objects);
        }
    }

    function fetch(datasetObj, cb) {
        var opts = {
            log: self.log,
            dataset: name
        };
        getDatasets(datasetObj, opts, function getDatasetsDone(err, results) {
            if (err) {
                self.log.warn('failed to fetch datasets');
            }
            cb(err, results);
        });
    }

    function copy(cache) {
        self.vmDatasets().forEach(function forEachDateset(data) {
            sections.forEach(function forEachSection(section) {
                for (var key in cache[section]) {
                    if (!data.hasOwnProperty('dataset_objects')) {
                        data.dataset_objects = {};
                    }
                    if (!data.dataset_objects.hasOwnProperty(section)) {
                        data.dataset_objects[section] = {};
                    }
                    data.dataset_objects[section][key] = cache[section][key];
                }
            });
        });
    }
};

/*
 * Enqueue a task to update context for a single zone
 */
Vminfod.prototype._enqueueZoneContextUpdate =
    function _enqueueZoneContextUpdate(zonename, meta, contexts) {

    var self = this;

    assert.string(zonename, 'zonename');
    assert.string(meta, 'meta');
    assert.arrayOfString(contexts, 'contexts');

    var description = util.format('zone context update for %s - %s - [%s]',
        zonename, meta, contexts.join(', '));

    self.event_queue.enqueue({
        description: description,
        timeout: QUEUE_TASK_TIMEOUT,
        func: function handleZoneContextUpdate(extras, callback) {
            // short-circuit if this vmobj doesn't exist
            if (!self.vmobjs.hasOwnProperty(zonename)) {
                extras.log.debug('vmobj doesn\'t exist for %s',
                    zonename);
                callback();
                return;
            }

            self.cloneVmDatasets(zonename);
            var vm_datasets = self.vmDatasets(zonename);

            // clear the missing pieces and refresh
            self.invalidateZoneDataCache(zonename, vm_datasets, contexts);
            self.refreshVmobj(zonename, vm_datasets, callback);
        }
    });
};
/*
 * Enqueue a task to update a single zones metadata file
 */
Vminfod.prototype.enqueueMetadataFileUpdate =
    function enqueueMetadataFileUpdate(zonename, meta) {

    var self = this;

    assert.string(zonename, 'zonename');
    assert.string(meta, 'meta');

    var contexts = [
        'last_modified',
        'json_objects'
    ];

    self._enqueueZoneContextUpdate(zonename, meta, contexts);
};

/*
 * Enqueue a task to update a single zones lastexit file
 */
Vminfod.prototype.enqueueLastexitFileUpdate =
    function enqueueLastexitFileUpdate(zonename, meta) {

    var self = this;

    assert.string(zonename, 'zonename');
    assert.string(meta, 'meta');

    var contexts = [
        'last_modified',
        'last_exited'
    ];

    self._enqueueZoneContextUpdate(zonename, meta, contexts);
};

/*
 * Enqueue a task to the sysinfo file
 */
Vminfod.prototype.enqueueSysinfoFileUpdate =
    function enqueueSysinfoFileUpdate(meta) {

    var self = this;

    assert.string(meta, 'meta');

    self.event_queue.enqueue({
        description: util.format('handle sysinfo fs change - %s', meta),
        timeout: QUEUE_TASK_TIMEOUT,
        func: function handleSysinfoEventTask(extras, callback) {
            vasync.forEachParallel({
                inputs: self.vmDatasets(),
                func: function getZoneData(data, cb) {
                    if (data.hasOwnProperty('sysinfo')) {
                        delete data.sysinfo;
                    }

                    var opts = {
                        log: extras.log,
                        cache: data,
                        keepalive: true
                    };
                    vmload.getZoneData(null, opts,
                        function getZoneDataDone(err, cache) {

                        if (err) {
                            extras.log.error('failed to refresh '
                                + 'sysinfo, failed to getZoneData');
                        }

                        cb();
                    });
                }
            }, callback);
        }
    });
};

/*
 * Extract the current active zpools used for VMs.  This looks through all of
 * the VMs on the system, and creates a list of all of the `zpool` properties
 * mapped to their zonenames.  For example:
 *
 * {
 *   "zones": [<zonename1>, <zonename2>, ...],
 *   "foo": [<zonename3>, ...],
 *   ...
 * }
 */
Vminfod.prototype.zonesZpools = function zonesZpools() {
    var self = this;

    assert.object(self.vmobjs, 'self.vmobjs');

    var zpools = {};

    Object.keys(self.vmobjs).forEach(function loopVms(zonename) {
        var vmobj = self.vmobjs[zonename];

        assert.object(vmobj, 'vmobj');
        assert.optionalString(vmobj.zpool, 'vmobj.zpool');

        if (!vmobj.zpool) {
            return;
        }

        if (!zpools[vmobj.zpool]) {
            zpools[vmobj.zpool] = [];
        }

        zpools[vmobj.zpool].push(zonename);
    });

    self.log.trace({zpools: zpools}, 'got zonesZpools');

    return zpools;
};

/*
 * Extract a (the first) UUID from a string
 */
function extractUUID(s) {
    var uuid_re = new RegExp('('
        + '[a-f0-9]{8}-'
        + '[a-f0-9]{4}-'
        + '[a-f0-9]{4}-'
        + '[a-f0-9]{4}-'
        + '[a-f0-9]{12}'
        + ')'
    );
    var match = uuid_re.exec(s);

    return match && match[1];
}

function formatEventsListeners(evls) {
    var now = process.hrtime();
    var ret = {};

    assert.object(evls, 'evls');

    Object.keys(evls).forEach(function forEachListener(uuid) {
        var evl = evls[uuid];

        ret[uuid] = {
            userAgent: evl.userAgent,
            createdTime: hrtime.hrtimeToString(evl.createdTime),
            createdDate: evl.createdDate,
            createdAgo: hrtime.hrtimeDeltaPretty(now, evl.createdTime)
        };
    });

    return ret;
}

function formatRefreshErrors(refreshErrors) {
    var now = process.hrtime();
    var ret;

    assert.arrayOfObject(refreshErrors, 'refreshErrors');

    ret = refreshErrors.map(function forEachRefreshError(re) {
        var o = {
            err: re.err.message,
            time: hrtime.hrtimeToString(re.time),
            ago: hrtime.hrtimeDeltaPretty(now, re.time)
        };

        return o;
    });

    return ret;
}

function formatRefreshLog(refreshLog) {
    assert.arrayOfObject(refreshLog, 'refreshLog');

    var now = process.hrtime();
    var ret;

    ret = refreshLog.map(function forEachRefreshLog(rl) {
        var o = {
            cacheChanges: rl.cacheChanges,
            vmChanges: rl.vmChanges,
            started: hrtime.hrtimeToString(rl.started),
            ended: hrtime.hrtimeToString(rl.ended),
            took: rl.prettyDelta,
            endedAgo: hrtime.hrtimeDeltaPretty(now, rl.ended)
        };

        return o;
    });

    return ret;
}
