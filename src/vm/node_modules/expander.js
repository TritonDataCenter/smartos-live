#!/usr/node/bin/node
/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2018, Joyent, Inc.
 *
 */

var assert = require('assert');
var proptable = require('./proptable');

console.log(
    '/*\n'
    + ' * CDDL HEADER START\n'
    + ' *\n'
    + ' * The contents of this file are subject to the terms of the\n'
    + ' * Common Development and Distribution License, Version 1.0 only\n'
    + ' * (the "License").  You may not use this file except in compliance\n'
    + ' * with the License.\n'
    + ' *\n'
    + ' * You can obtain a copy of the license at http://smartos.org/CDDL\n'
    + ' *\n'
    + ' * See the License for the specific language governing permissions\n'
    + ' * and limitations under the License.\n'
    + ' *\n'
    + ' * When distributing Covered Code, include this CDDL HEADER in each\n'
    + ' * file.\n'
    + ' *\n'
    + ' * If applicable, add the following below this CDDL HEADER, with the\n'
    + ' * fields enclosed by brackets "[]" replaced with your own identifying\n'
    + ' * information: Portions Copyright [yyyy] [name of copyright owner]\n'
    + ' *\n'
    + ' * CDDL HEADER END\n'
    + ' */\n'
    + '\n'
    + '/*\n'
    + ' * Copyright (c) 2018, Joyent, Inc.\n'
    + ' *\n'
    + ' * THIS FILE IS AUTOGENERATED FROM proptable.js DO NOT EDIT!!!\n'
    + ' * CHANGES WILL BE LOST.\n'
    + ' *\n'
    + ' */\n'
    + '\n'
    + 'var utils = require(\'utils\');\n'
);

var brand_options;
var flattenable = {array: [], array_hash_key: [], hash_key: []};
var keep_zero_props = [];
var load_deps = {};
var output;
var payload_props = {};
var sysinfo = {};
var updatable_disk_props = [];
var updatable_nic_props = [];
var updatable_pci_device_props = [];
var vmobj_json_fields = [];
var vmobj_sysinfo_fields = [];
var vmobj_zfs_fields = [];
var vmobj_zoneinfo_fields = [];
var vmobj_zonexml_fields = [];
var zfs_depends = {};
var zfs_fields = [];
var zfs_types = [];
var zoneinfo = {};
var zonexml = {};

brand_options = proptable.brand_options;

Object.keys(proptable.properties).forEach(function (prop) {
    var match;
    var property;
    var payload_prop;

    property = proptable.properties[prop];

    if (property.flattenable) {
        assert(flattenable.hasOwnProperty(property.flattenable));
        flattenable[property.flattenable].push(prop);
    }

    if (property.json) {
        vmobj_json_fields.push(prop);
    }

    match = prop.match(/^nics\.\*\.(.*)$/);
    if (match && property.updatable) {
        updatable_nic_props.push(match[1]);
    }

    match = prop.match(/^disks\.\*\.(.*)$/);
    if (match && property.updatable) {
        updatable_disk_props.push(match[1]);
    }

    match = prop.match(/^pci_devices\.\*\.(.*)$/);
    if (match && property.updatable) {
        updatable_pci_device_props.push(match[1]);
    }

    if (property.zonexml) {
        zonexml[property.zonexml] = {
            objname: prop
                .replace(/^disks\.\*\./, '')
                .replace(/^pci_devices\.\*\./, '')
                .replace(/^filesystems\.\*\./, '')
                .replace(/^nics\.\*\./, ''),
            loadValueTranslator: property.loadValueTranslator,
            ignore: !!property.ignore
        };
        assert(vmobj_zonexml_fields.indexOf(prop) === -1, 'duplicate "' + prop
            + '" in proptable');
        // ignored properties don't go in the list because they're only there
        // to know they're ignorable (not just unhandled), so they can't be used
        // for lookups, etc.
        if (!property.hasOwnProperty('ignore')) {
            vmobj_zonexml_fields.push(prop);
        }
        // zone.attr.* are stored as strings. If the type is not a string and
        // there is no translator, save the developer a few hours of debugging.
        if (property.zonexml.substring(0, 10) === 'zone.attr.'
            && !property.loadValueTranslator
            && property.payload && property.payload.type) {
            var str_types = ['flat-object', 'string', 'uuid'];
            assert(str_types.indexOf(property.payload.type) !== -1,
                'prop "' + prop + '" type "' + property.payload.type
                + '" is not one of "' + str_types.join('", "')
                + '" and has no loadValueTranslator.');
        }
    } else if (property.zonexml_depends) {
        /*
         * zonexml_depends is used for things like transition_expire which
         * aren't real properties in the XML but *only* show up when another
         * property is loaded.
         */
        vmobj_zonexml_fields.push(prop);
    }

    if (property.load_depends) {
        load_deps[prop] = property.load_depends;
    }

    if (property.sysinfo) {
        sysinfo[property.sysinfo] = {
            field: prop,
            loadValueTranslator: property.loadValueTranslator
        };
        assert(vmobj_sysinfo_fields.indexOf(prop) === -1, 'duplicate "' + prop
            + '" in proptable');
        vmobj_sysinfo_fields.push(prop);
    }

    if (property.zoneinfo) {
        zoneinfo[property.zoneinfo] = {
            field: prop,
            loadValueTranslator: property.loadValueTranslator
        };

        assert(vmobj_zoneinfo_fields.indexOf(prop) === -1, 'duplicate "' + prop
            + '" in proptable');
        vmobj_zoneinfo_fields.push(prop);
    }

    if (property.zfs) {
        vmobj_zfs_fields.push(prop);

        if (property.zfs.hasOwnProperty('types')) {
            property.zfs.types.forEach(function (t) {
                if (zfs_types.indexOf(t) === -1) {
                    zfs_types.push(t);
                }
            });
        }
        if (property.zfs.hasOwnProperty('fields')) {
            property.zfs.fields.forEach(function (f) {
                if (zfs_fields.indexOf(f) === -1) {
                    zfs_fields.push(f);
                }
            });
        }

        zfs_depends[prop] = property.zfs;
    }

    if (property.payload) {
        payload_prop = {pr_type: property.payload.type};
        if (property.payload.hasOwnProperty('default')) {
            payload_prop['pr_default'] = property.payload.default;
        }
        if (property.payload.hasOwnProperty('check_as')) {
            payload_prop['pr_check_as'] = property.payload.check_as;
        }
        if (property.payload.hasOwnProperty('min')) {
            payload_prop['pr_min'] = property.payload.min;
        }
        if (property.payload.hasOwnProperty('max')) {
            payload_prop['pr_max'] = property.payload.max;
        }
        if (property.payload.hasOwnProperty('valueValidator')) {
            payload_prop['pr_valueValidator'] = property.payload.valueValidator;
        }
        if (property.payload['keep_zero']) {
            keep_zero_props.push(prop);
        }
        payload_props[prop] = payload_prop;

        if (property.payload.allowed) {
            Object.keys(property.payload.allowed).forEach(function (brand) {
                var bo = brand_options;

                if (!bo.hasOwnProperty(brand)) {
                    bo[brand] = {};
                }
                if (!bo[brand].hasOwnProperty('allowed_properties')) {
                    bo[brand].allowed_properties = {};
                }
                bo[brand].allowed_properties[prop]
                    = property.payload.allowed[brand];
            });
        }

        if (property.payload.required) {
            Object.keys(property.payload.required).forEach(function (brand) {
                var bo = brand_options;
                if (!bo.hasOwnProperty(brand)) {
                    bo[brand] = {};
                }
                if (!bo[brand].hasOwnProperty('required_properties')) {
                    bo[brand].required_properties = {};
                }
                bo[brand].required_properties[prop]
                    = property.payload.required[brand];
            });
        }
    }
});

output = 'exports.VMOBJ_JSON_FIELDS = '
    + JSON.stringify(vmobj_json_fields, null, 2) + ';\n\n'
    + 'exports.FLATTENABLE_ARRAYS = '
    + JSON.stringify(flattenable['array'], null, 2) + ';\n\n'
    + 'exports.FLATTENABLE_ARRAY_HASH_KEYS = '
    + JSON.stringify(flattenable['array_hash_key'], null, 2) + ';\n\n'
    + 'exports.FLATTENABLE_HASH_KEYS = '
    + JSON.stringify(flattenable['hash_key'], null, 2) + ';\n\n'
    + 'exports.KEEP_ZERO_PROPERTIES = '
    + JSON.stringify(keep_zero_props, null, 2) + ';\n\n'
    + 'exports.LOAD_DEPENDS = '
    + JSON.stringify(load_deps, null, 2) + ';\n\n'
    + 'exports.PAYLOAD_PROPERTIES = '
    + JSON.stringify(payload_props, null, 2) + ';\n\n'
    + 'exports.VMOBJ_SYSINFO_FIELDS = '
    + JSON.stringify(vmobj_sysinfo_fields, null, 2) + ';\n\n'
    + 'exports.SYSINFO_PROPERTIES = '
    + JSON.stringify(sysinfo, null, 2) + ';\n\n'
    + 'exports.UPDATABLE_DISK_PROPS = '
    + JSON.stringify(updatable_disk_props, null, 2) + ';\n\n'
    + 'exports.UPDATABLE_NIC_PROPS = '
    + JSON.stringify(updatable_nic_props, null, 2) + ';\n\n'
    + 'exports.UPDATABLE_PCI_DEVICE_PROPS = '
    + JSON.stringify(updatable_pci_device_props, null, 2) + ';\n\n'
    + 'exports.VMOBJ_XML_FIELDS = '
    + JSON.stringify(vmobj_zonexml_fields, null, 2) + ';\n\n'
    + 'exports.XML_PROPERTIES = '
    + JSON.stringify(zonexml, null, 2) + ';\n\n'
    + 'exports.VMOBJ_ZFS_DEPENDENCIES = '
    + JSON.stringify(zfs_depends, null, 2) + ';\n\n'
    + 'exports.VMOBJ_ZFS_FIELDS = '
    + JSON.stringify(Object.keys(zfs_depends), null, 2) + ';\n\n'
    + 'exports.VMOBJ_ZONEINFO_FIELDS = '
    + JSON.stringify(vmobj_zoneinfo_fields, null, 2) + ';\n\n'
    + 'exports.ZONEINFO_PROPERTIES = '
    + JSON.stringify(zoneinfo, null, 2) + ';\n';

// XXX there's probably a better way to de-string these...
output.split(/\n/).forEach(function (line) {
    var matches;

    [
        new RegExp('^( *\"loadValueTranslator\": )\"(.*)$'),
        new RegExp('^( *\"pr_valueValidator\": )\"(.*)$')
    ].forEach(function (re) {
        if (!matches) {
            matches = line.match(re);
        }
    });

    if (matches) {
        console.log(matches[1] + matches[2].replace('"', ''));
    } else {
        console.log(line);
    }
});

output = 'exports.ZFS_FIELDS = '
    + JSON.stringify(zfs_fields, null, 2) + ';\n\n'
    + 'exports.ZFS_TYPES = '
    + JSON.stringify(zfs_types, null, 2) + ';\n';
console.log(output);

console.log('exports.BHYVE_MEM_OVERHEAD = ' + proptable.BHYVE_MEM_OVERHEAD
    + ';\n');
console.log('exports.KVM_MEM_OVERHEAD = ' + proptable.KVM_MEM_OVERHEAD + ';\n');

output = 'exports.BRAND_OPTIONS = '
    + JSON.stringify(proptable.brand_options, null, 2) + ';\n\n';
console.log(output);

output = 'exports.HVM_BRANDS = '
    + JSON.stringify(proptable.HVM_BRANDS, null, 2) + ';\n\n';
console.log(output);
