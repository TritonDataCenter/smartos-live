/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright 2019 Joyent, Inc.
 *
 */

// Ensure we're using the platform's node
require('/usr/node/node_modules/platform_node_version').assert();

var async = require('/usr/node/node_modules/async');
var bunyan = require('/usr/node/node_modules/bunyan');
var events = require('events');
var net = require('net');

function Qmp(logger)
{
    var id;
    var ids = [];
    var qmp = this;

    qmp.cmd_id = 0;
    qmp.in_transit = {};
    qmp.connected = false;
    qmp.emitter = new events.EventEmitter();

    if (!logger) {
        qmp.log = new bunyan({
            name: 'Qmp',
            stream: process.stderr,
            level: 'debug'
        });
    } else {
        qmp.log = logger;
    }

    qmp.emitter.on('send', function () {
        var msg;

        if (qmp.connected) {
            for (id in qmp.in_transit) {
                ids.push(id);
            }
            ids.sort(function (a, b) {
                return Number(a) - Number(b);
            });

            for (id in ids) {
                id = ids[id];
                msg = qmp.in_transit[id];
                if (msg && !msg.sent) {
                    qmp.send(msg);
                }
            }
        } else {
            qmp.log.debug('Got "send", but not connected.');
        }
    });
}

Qmp.prototype.send = function (msg)
{
    var cb;
    var qmp = this;

    if (qmp.stream.writable) {
        qmp.log.info('sending[' + msg.packet.id + ']: ' + JSON.stringify(msg));
        qmp.stream.write(JSON.stringify(msg.packet) + '\n');
        msg.sent = true;
    } else {
        qmp.log.warn('send() called when disconnected, returning error '
            + 'for command ' + msg.packet.id + '.');
        cb = qmp.in_transit[msg.packet.id].callback;
        cb(new Error('disconnected while sending'));
        delete qmp.in_transit[msg.packet.id];
    }
};

Qmp.prototype.connect = function (socket, callback)
{
    var qmp = this;
    var chunks, result, buffer = '', id, cb;
    qmp.stream = new net.Stream();

    qmp.stream.setEncoding('utf8');
    qmp.stream.on('data', function (chunk) {
        buffer += chunk.toString();
        chunks = buffer.split('\n');
        while (chunks.length > 1) {
            result = JSON.parse(chunks.shift());
            if (result.hasOwnProperty('QMP')) {
                // This is the initial banner/greeting message
                qmp.log.info('QMP greeting:' + JSON.stringify(result));
            } else if (result.hasOwnProperty('return')) {
                qmp.log.info('QMP[' + result.id + '] result: '
                    + JSON.stringify(result));
                if (result.hasOwnProperty('id')) {
                    id = result.id;
                    cb = qmp.in_transit[id].callback;
                    cb(null, result['return']);
                    delete qmp.in_transit[id];
                } else {
                    qmp.log.warn('WARNING: no id in result [', result, ']');
                }
            } else if (result.hasOwnProperty('event')) {
                result.timestamp = new Date((result.timestamp.seconds * 1000000
                    + result.timestamp.microseconds) / 1000).toISOString();
                qmp.log.debug('QMP event: ' + JSON.stringify(result));
            } else {
                qmp.log.error('QMP error: ' + JSON.stringify(result));
            }
        }
        buffer = chunks.pop();
    });

    qmp.stream.on('close', function () {
        qmp.log.info('QMP socket was closed');
        qmp.connected = false;
        qmp.stream.end();

        // force any remaining messages to fail
        for (id in qmp.in_transit) {
            qmp.send(qmp.in_transit[id]);
        }
    });

    qmp.socket = socket;

    qmp.stream.on('error', function (e) {
        callback(e);
    });

    function on_connect(err) {
        if (!err) {
            qmp.command('qmp_capabilities', null, function (e) {
                // response to our capabilities request, ready for others to
                // send now.
                qmp.connected = true;
                // send anything that's been waiting.
                qmp.emitter.emit('send');
            });
        }
        callback(err);
    }

    qmp.stream.connect(qmp.socket, on_connect);
};

Qmp.prototype.disconnect = function ()
{
    var qmp = this;

    qmp.stream.end();
};

Qmp.prototype.command = function (command, args, callback)
{
    var qmp = this;
    var cmd_id = qmp.cmd_id++;
    var packet = { 'execute': command, 'id': cmd_id };

    qmp.log.info('QMP[' + cmd_id +'] command: ' + command);

    if (args) {
        packet.arguments = args;
    }

    qmp.in_transit[cmd_id] = { 'packet': packet, 'sent': false,
        'callback': callback };

    if (command === 'qmp_capabilities' && !qmp.connected) {
        qmp.send(qmp.in_transit[cmd_id]);
    } else {
        qmp.emitter.emit('send');
    }
};

exports.Qmp = Qmp;
