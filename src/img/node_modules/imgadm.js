/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at http://smartos.org/CDDL
 *
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file.
 *
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 *
 * Copyright (c) 2012, Joyent, Inc. All rights reserved.
 *
 *
 * === SmartOS Image Library ===
 *
 * This library is specifically written to manage and manipulate
 * images in SmartOS. An image is a binary blob which is presented
 * to a virtual machine as a local storage volume; The image usually
 * contains an operating system.
 *
 * When an image is installed, it is downloaded from the appropriate
 * server or service and piped to zfs. custom properties are set. Those
 * custom properties include 'imgadm:uuid', which represents the UUID
 * image that was installed.  This can be used to identify the image
 * if the imgadm database is missing.
 *
 * The database is a collection of manifests stored in /var/lib/imgadm
 * Those manifests are saved in order to be able to have local information
 * about the image, and its requirements.
 *
 * If at any time the database is destroyed, you can try and run the
 * repair.sh tool which will - in a rather brutish manner - attempt
 * to rebuild the database by comparing the uuids of existing images
 * with the ones available in imgapi.
 *
 * Images may be destroyed only if they do not have any children.
 * Children includes 'snapshots' and 'clones' of those snapshots.
 * If any children other than the snapshot of the image itself
 * exists, then you will not be able to remove the image from the
 * compute node.
 *
 */

var assert = require('assert');
var common = require('./common');
var db = require('./db');
var dns = require('dns');
var fs = require('fs');
var http = require('http');
var https = require('https');
var log = common.log;
var path = require('path');
var spawn = require('child_process').spawn;
var url = require('url');
var zfs = require('./zfs');

var ZPOOL_NAME = 'zones';
var IMGAPI_URL = 'https://datasets.joyent.com/datasets/'; // need trailing slash
var DB_CACHE = '/var/db/imgadm/imgcache.json';
var DB_SOURCES = '/var/db/imgadm/sources.list';

var CURL = '/usr/bin/curl';
var BZIP2 = '/usr/bin/bzip2';
var GZIP = '/usr/bin/gzip';
var MOUNT = '/usr/sbin/mount';

var FILTER_FIELDS = [
    'name',
    'version',
    'uuid',
    'urn',
    'type',
    'description',
    'os',
    'published_at',
    'creator_uuid',
    'creator_name',
    'owner_uuid'
];

var _isUuid = function (obj) {
    var uuidReg =
        /[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}/;

    if (typeof (obj) === 'string') {
        return (uuidReg.test(obj));
    }
    return false;
};

var _isUrn = function (obj) {
    var urnReg = /[a-z0-9-_]+:[a-z0-9]+:[a-z0-9._-]+:[a-z0-9._-]+/;
    if (typeof (obj) === 'string') {
        return (urnReg.test(obj));
    }
    return false;
};

var _isUrl = function (obj) {
    var o;

    if (typeof (obj) === 'string') {
        o = url.parse(obj);
        if (o.host && o.protocol && o.pathname) {
            return true;
        }
    }
    return false;
};

var _curlHost = function (options) {
    var auth = '';

    if (typeof (options) !== 'object') {
        throw new TypeError('options must be an object');
    }

    if (options.auth) {
        auth = options.auth + '@';
    }
    return (options.protocol + '//' + auth + options.host + options.path);
};

var imageExists = function (uuid, callback) {
    db.load(uuid, function (err, record) {
        if (err || record.uuid == undefined) {
            callback(false);
        } else {
            callback(true);
        }
    });
};

var httpOptions = function (manifestId, callback) {
    var auth;
    var opts;
    var s;

    if (!manifestId) {
        opts = url.parse(IMGAPI_URL);
    } else if (_isUrl(manifestId)) {
        opts = url.parse(manifestId);
    } else if (_isUuid(manifestId)) {
        opts = url.parse(IMGAPI_URL + manifestId);
    } else {
        throw new Error('options requires a URL or UUID');
    }

    opts.headers = {
        'accept': 'application/json'
    };

    // nodev4 fixup (url and http client reqs dont match)
    if (opts.pathname) {
        opts.path = opts.pathname;
        opts.pathname = undefined;
    }
    if (opts.auth) {
        s = opts.host.split(/@/);
        opts.host = s[s.length-1];
        auth = 'Basic ' + new Buffer(opts.auth).toString('base64');
        opts.headers['Authorization'] = auth;
    }

    // SmartOS DNS is disabled by default. We rely on node to
    // resolve the host for us.
    dns.resolve4(opts.hostname, function (err, addresses) {
        if (err) {
            throw new Error('could not resolve host: ' + opts.hostname);
        }
        // pick one at random?
        opts.host = addresses[0];
        callback(opts);
    });
};

var httpClient = function (options) {
    var client;

    switch (options.protocol) {
        case 'https:':
            client = https;
            break;
        case 'http:':
            client = http;
            break;
        default:
            throw new Error('Unsupported protocol: ' + options.protocol);
    }
    return client;
};

// Todo just replace this with Array.filter and create
// a list of filter functions (ele, idx, arr)
var filterResults = function (fields, toFilter) {
    var filterOn = FILTER_FIELDS;
    var results = [];

    for (var i = 0; i < toFilter.length; i++) {
        var item = toFilter[i];
        var r = {};
        for (var f = 0; f < filterOn.length; f++) {
            r[filterOn[f]] = item[filterOn[f]];
        }
        results.push(r);
    }

    return results;
};

var loadSources = function (sourcefile) {
    // config only supports comments starting with '#',
    // whitspace then a '#', or empty lines
    // '#' characters in the URL are not supported either
    var i;
    var line;
    var lines;
    var results = [];
    var sources;

    if (path.existsSync(sourcefile) === false) {
        return false;
    }

    log.debug('using sources file %s', sourcefile);
    sources = fs.readFileSync(sourcefile, 'utf8');
    lines = sources.split(/\n/);

    for (i = 0; i < lines.length; i++) {
        line = lines[i];
        if (line.match(/^\s*[$#]/) || line === '') {
            continue;
        }
        if (_isUrl(line)) {
            results.push(line);
        }
    }

    return results;
};

var loadCache = function (cachefile) {
    var cache;
    var rawcache;

    if (path.existsSync(cachefile) === false) {
        return false;
    }

    log.debug('loading cache file %s', cachefile);
    rawcache = fs.readFileSync(cachefile, 'utf8');
    cache = JSON.parse(rawcache);

    return cache;
};

var cacheList = function (callback) {
    var cache = loadCache(DB_CACHE);
    var results;

    if (!cache) {
        callback('Cache file couldn\'t be loaded. Try \'imgadm update\' first');
        return;
    }

    results = filterResults(null, loadCache(DB_CACHE));
    callback(null, results);
};

var cacheUpdate = function (callback) {
    var body;
    var cache = [];
    var complete;
    var counter;
    var i;
    var next;
    var options;
    var source;
    var sources = loadSources(DB_SOURCES);

    counter = sources.length;

    if (!sources) {
        callback('couldn\'t load source file ' + DB_SOURCES, null);
        return;
    }

    next = function () {
        --counter;
        if (counter === 0) {
            complete();
        }
    };

    complete = function (err) {
        if (err) {
            callback('error downloading image list', null);
        }
        fs.writeFileSync(DB_CACHE, JSON.stringify(cache), 'utf8');
        console.log('done');
    };

    log.info('updating local images database...');
    for (i = 0; i < sources.length; i++) {
        body = '';
        source = sources[i];
        options = url.parse(sources[i]);

        // SmartOS DNS is disabled by default
        dns.resolve4(options.hostname, function (err, addresses) {
            var client;

            if (err) {
                callback('could not resolve host: ' + options.hostname);
                return;
            }

            options.host = addresses[0];
            delete (options.hostname); // XXX

            client = httpClient(options);

            console.log('Get %s...', source);

            client.get(options, function (res) {

                res.on('data', function (chunk) {
                    body += chunk.toString();
                });

                res.on('end', function () {
                    var imgdb = JSON.parse(body);
                    for (var d = 0; d < imgdb.length; d++) {
                        // set url property so relpaths work later
                        imgdb[d]['_url'] = source;
                        cache.push(imgdb[d]);
                    }

                    next();
                });
            });
        });
    }
};

// returns manifest specified by uuid
var show = function (uuid, callback) {
    var cache = loadCache(DB_CACHE);
    var i;
    var result = null;

    if (!cache) {
        callback('error loading cache', null);
        return;
    }

    for (i = 0; i < cache.length; i++) {
        if (cache[i].uuid == uuid) {
            result = cache[i];
            break;
        }
    }

    if (result) {
        callback(null, result);
    } else {
        callback('not found', null);
    }
};

var dump = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    var onLoad;
    var result = {
        volume: {},
        children: {
            snapshots: [],
            clones: []
        },
        manifest: {}
    };

    onLoad = function (err, manifest) {
        var _name;

        if (err) {
            callback(err, null);
            return;
        }

        result.manifest = manifest;
        _name = ZPOOL_NAME + '/' + name;

        zfs.getRecursive(_name, function (error, snapshots) {
            if (error) {
                callback(error);
                return;
            }

            result.volume = snapshots.shift();
            result.children.snapshots = snapshots;

            zfs.list(null, function (e, list) {
                var d;
                var i;
                var snapNames;

                if (e) {
                    callback(e, null);
                    return;
                }

                snapNames = snapshots.map(function (val) {
                    return val.name;
                });

                for (i in list) {
                    d = list[i];
                    if (snapNames.indexOf(d.origin) >= 0) {
                        result.children.clones.push(d);
                    }
                }
                callback(null, result);
            });
        });
    };

    imageExists(name, function (exists) {
        if (!exists) {
            callback('image not found', null);
        } else {
            db.load(name, onLoad);
        }
    });
};

var spawnInflater = function (type) {
    assert.ok(type);

    var inflater = null;
    var args = ['-cdfq'];

    switch (type) {
        case 'gz':
            inflater = spawn(GZIP, args);
            break;
        case 'bz2':
            inflater = spawn(BZIP2, args);
            break;
        default:
            throw new Error('inflater type must be one of "gz" or "bz2"');
    }

    return inflater;
};

var importLocal = function (mfile, filename, callback) {
    assert.ok(mfile);
    assert.ok(filename);
    assert.ok(callback);

    var inflater;
    var manifest;
    var rs;
    var uuid;
    var valid;

    manifest = JSON.parse(fs.readFileSync(mfile, 'utf8'));
    valid = db.validateManifest(manifest);
    if (valid != true) {
        callback(valid);
        return;
    }

    uuid = manifest.uuid;

    imageExists(uuid, function (exists) {
        if (exists) {
            callback('image already installed');
        } else {
            var imgfile = manifest.files[0];
            log.debug('%s urn: %s',               uuid, manifest.urn);
            log.debug('%s size (bytes compressed): %s',  uuid, imgfile.size);
            log.debug('%s checksum: (sha1) %s',   uuid, imgfile.sha1);
            log.debug('%s path: %s',              uuid, imgfile.path);

            zfs.getPool(ZPOOL_NAME, function (err, pool) {
                var volname = ZPOOL_NAME + '/' + uuid;
                var volnameTemp = volname + '-partial';
                var zfsIn;

                var localImport = function () {
                    if (/\.gz$/.test(imgfile.path)) {
                        inflater = spawnInflater('gz');
                    } else if (/\.bz2$/.test(imgfile.path)) {
                        inflater = spawnInflater('bz2');
                    }

                    if (inflater) {
                        log.debug('%s requires inflate stream', uuid);

                        inflater.stderr.on('data', function (chunk) {
                            log.err('%s got inflater error: %s', uuid,
                                chunk.toString());
                        });

                        inflater.stdout.pipe(zfsIn.stdin);
                        rs = fs.createReadStream(filename, {end: false});
                        rs.pipe(inflater.stdin);
                    } else {
                        rs = fs.createReadStream(filename, {end: false});
                        rs.pipe(zfsIn.stdin);
                    }
                };

                log.info('%s doesnt exist. continuing with install', uuid);
                log.debug('%s zpool has %sMB free', ZPOOL_NAME, pool.free);
                log.debug('%s importing to %s', uuid, volname);

                zfsIn = zfs.spawnReceiveStream(volnameTemp);
                localImport();

                zfsIn.on('exit', function (code, signal) {
                    if (code != 0) {
                        log.debug('%s zfs recieve exited non-zero: %s', uuid,
                            code);
                        callback('zfs receive exited non zero: ' + code, uuid);
                        return;
                    } else {
                        onImport(manifest, callback);
                    }
                });
            });
        }
    });
};

var onImport = function (manifest, callback) {
    var uuid = manifest.uuid;
    var volname = ZPOOL_NAME + '/' + uuid;

    zfs.rename(volname + '-partial', volname, function (rename_err) {
        if (rename_err) {
            callback(rename_err);
            return;
        }
        zfs.setProp(volname, 'imgadm:uuid', uuid, function (set_err) {
            if (set_err) {
                callback(set_err);
                return;
            }
            db.save(manifest, function (save_err) {
                if (save_err) {
                    callback(save_err);
                    return;
                }
                log.info('%s successfully installed',  uuid);
                callback(null, uuid);
            });
        });
    });
};

var importRemote = function (uuid, callback) {
    assert.ok(uuid);
    assert.ok(callback);

    show(uuid, function (error, manifest) {
        var inflater, imgfile;

        if (error) {
            callback(error);
            return;
        }

        imageExists(uuid, function (exists) {
            if (exists) {
                callback('image already installed');
                return;
            }

            // The file to download is comprised of:
            // https://host/images/:uuid/:imgfile.path
            imgfile = manifest.files[0];

            log.debug('%s urn: %s',               uuid, manifest.urn);
            log.debug('%s size (bytes compressed): %s',  uuid, imgfile.size);
            log.debug('%s checksum: (sha1) %s',   uuid, imgfile.sha1);
            log.debug('%s path: %s',              uuid, imgfile.path);

            zfs.getPool(ZPOOL_NAME, function (err, pool) {
                var args = ['--insecure'];
                var curl, zfsIn;
                var downloadImage;
                var options;
                var volname = ZPOOL_NAME + '/' + uuid;
                var volnameTemp = volname + '-partial';

                downloadImage = function () {
                    if (/\.gz$/.test(imgfile.path)) {
                        inflater = spawnInflater('gz');
                    } else if (/\.bz2$/.test(imgfile.path)) {
                        inflater = spawnInflater('bz2');
                    }

                    if (inflater) {
                        log.debug('%s requires inflate stream', uuid);

                        inflater.stderr.on('data', function (chunk) {
                            log.err('%s got inflater error: %s', uuid,
                                chunk.toString());
                        });

                        inflater.stdout.pipe(zfsIn.stdin);
                        curl = spawn(CURL, args);
                        curl.stdout.pipe(inflater.stdin);
                    } else {
                        // args.push(_curlHost(options));
                        curl = spawn(CURL, args);
                        curl.stdout.pipe(zfsIn.stdin);
                    }
                };

                zfsIn = zfs.spawnReceiveStream(volnameTemp);

                zfsIn.on('exit', function (code, signal) {
                    if (code != 0) {
                        log.debug('%s zfs recieve exited non-zero: %s', uuid,
                            code);
                        callback('zfs receive exited non zero: ' + code, uuid);
                    } else {
                        onImport(manifest, callback);
                    }
                });

                options = url.parse(manifest._url);
                log.info('%s doesnt exist. continuing with install', uuid);
                log.debug('%s zpool has %sMB free', ZPOOL_NAME, pool.free);
                log.debug('%s importing to %s', uuid, volname);
                log.debug('%s downloading file from: %s',  uuid,
                    options.hostname);

                // SmartOS DNS is disabled by default
                dns.resolve4(options.hostname, function (e, addresses) {
                    if (e) {
                        callback('could not resolve host: ' + options.hostname);
                        return;
                    }
                    options.host = addresses[0];
                    delete (options.hostname); // XXX
                    options.path = path.join(options.path, uuid, imgfile.path);
                    args.push(_curlHost(options));
                    downloadImage();
                });
            });
        });
    });
};

var destroyImage = function (name, callback) {
    assert.ok(name);
    assert.ok(callback);

    dump(name, function (err, dmp) {
        var numClones;

        if (err) {
            callback(err);
            return;
        }
        log.debug('%s checking number of children', name);
        numClones = dmp.children.clones.length;

        if (numClones > 0) {
            log.debug('%s has %s dependent clones. cannot destroy', name,
                numClones);
            callback('image has children. cannot destroy');
        } else {
            log.info('destroying image %s', name);
            zfs.destroy(dmp.volume.name, {recursive: true}, function (e) {
                log.debug('%s destroying zfs volume', name);
                if (e) {
                    callback(e);
                    return;
                }
                db.destroy(name, function (error) {
                    log.debug('%s removing database record', name);
                    callback(error);
                });
            });
        }
    });
};

module.exports = {
    importRemote: importRemote,
    importLocal: importLocal,
    destroyImage: destroyImage,
    listLocal: db.all,
    dump: dump,
    cacheUpdate: cacheUpdate,
    cacheList: cacheList,
    show: show
};
